<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>opc协议概要</title>
      <link href="2021/09/01/opc%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%A6%81/"/>
      <url>2021/09/01/opc%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>opc协议是一种中间层物联协议抽象模型，目前在用的主要是opc ua. 相关基础只是请自行百度，这里仅记录编码通信所需要的知识。</p><p>OPC UA的抽象模型就是OOP，将物理设备的物模型映射成地址空间里的**节点(Node)**。</p><p>例子：</p><ol><li>空调有风扇，有温度传感器，在地址空间中可以将其定义为空调对象包含的对象；</li><li>空调还有温度、风速，可以定义为空调对象下的变量；</li><li>空调还可以开、可以关，开和关的动作可以定义为空调对象的方法；</li><li>空调也许还具有报警功能，向外发送通知，则可以定义为事件；</li><li>由此，对象、变量和方法构成了OPC UA最重要的节点类别。对象拥有变量和方法，而且可以触发事件。</li></ol><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>标准的节点类有如下几种：</p><ul><li>基本节点类：能够派生所有其他节点类，对应Java中的Node基类</li><li>对象类型节点类：对应实例的类型，比如AirControllerNode extends Node</li><li>对象节点类：对应一个实例，new AirControllerNode()</li><li>变量节点类：定义数据变量，AirController里面的成员变量，比如temprature表示温度</li><li>变量类型节点类：定义特性，成员变量的类型（temprature类型是Double）</li><li>方法节点类：定义方法，AirController里面的method，如setTemprature</li><li>引用类型节点类：定义引用。AirController里面，比如引用了一个空调遥控器实例，对应有一个引用类型。</li><li>视图节点类：定义地址空间中节点子集，默认是全部开放的，可以筛选自己感兴趣的节点组成一个视图。视图还可以用来跟踪配置的版本变更。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu13liqbmpj6087062glr02.jpg" alt="img"></p><p>对象模型见上图，对象有对应的类型节点，对象代表<strong>一组</strong>变量和方法节点，变量也有对应的类型节点；方法可以被调用，其他节点可以引用节点，同时节点可以触发事件。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu13tdv3v2j60cr04b0sz02.jpg" alt="img"></p><p>变量与变量类型之间的引用如上。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu13qdvas6j607g067t8r02.jpg" alt="image-20210901141720112"></p><p>节点模型见上图，节点由属性和引用构成，NodeClass分为Type和Object。所有的节点（除了方法）都有对应的类型节点。</p><p>包含引用的节点为源节点，被引用的节点称目标节点。引用的目标节点可以与源节点在同一个地址空间，也可以在另一个OPC服务器的地址空间，甚至是目标节点可以不存在。引用是通过BrowseName来实现的，同一个地址空间里引用类型必须唯一（即类名不能重复）。</p><p>节点类常用的基础属性(attribute)：</p><table><thead><tr><th align="center">名称</th><th align="center">使用</th><th align="center">数据类型</th></tr></thead><tbody><tr><td align="center">NodeId</td><td align="center">M</td><td align="center">NodeId</td></tr><tr><td align="center">NodeClass</td><td align="center">M</td><td align="center">NodeClass</td></tr><tr><td align="center">BrowseName</td><td align="center">M</td><td align="center">QualifiedName</td></tr><tr><td align="center">DisplayName</td><td align="center">M</td><td align="center">LocalizedText</td></tr><tr><td align="center">Description</td><td align="center">O</td><td align="center">LocalizedText</td></tr><tr><td align="center">WriteMask</td><td align="center">O</td><td align="center">UInt32</td></tr><tr><td align="center">UserWriteMask</td><td align="center">O</td><td align="center">UInt32</td></tr></tbody></table><blockquote><p>注：M代表必备项，O代表可选项</p></blockquote><ul><li><strong>NodeId</strong>：节点ID，在服务器中唯一标识一个节点。是定位和在服务器间交换信息的最重要概念。浏览地址空间时，服务器返回NodeId，客户端在服务调用时使用NodeId来定位节点。</li><li><strong>BrowseName</strong>：浏览名称，仅用于浏览目的，不宜用来显示节点的名称，用作浏览地址空间浏览路径的一个非本地化人员可读的名称。</li><li><strong>DisplayName</strong>：显示名称，包含了节点的本地化名称。如果客户端响应显示节点名称给用户，宜使用该属性。</li><li><strong>Description</strong>：描述，本地化的文本中解释节点的含义。</li><li><strong>WriteMask</strong>：写入掩码，公开了客户端写入节点属性的可能性。该属性不考虑任何用户访问权。</li><li><strong>UserWriteMask</strong>：考虑用户访问权时，公开的客户端写入节点属性的可能性。指定哪个节点属性可被当前连接到服务器上的用户修改。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu1du66am5j61hd0u043802.jpg" alt="《OPC UA 学习教程 — 总览和核心概念》"></p><p>各类节点之间的关系如上图。</p><p>对象节点除了上述属性外，还有下图中的属性和可能的引用：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu13vmxod5j60ey0e0jt202.jpg" alt="img"></p><blockquote><p>注：0…* 表示没有限制，不使用或者可以无限次用；0…1 表示最多用一次；1 表示必须提供一次</p></blockquote><ul><li>必备的EventNotifier属性表示对象是否可以被用于订阅事件或者读和写事件的历史；</li><li>HasTypeDefinition引用指向被用作对象的类型定义的对象类型；</li><li>使用HasComponent引用来定义数据变量、对象和对象的方法；</li><li>使用HasProperty引用来定义对象的特性，特性都是PropertyType类型；</li><li>HasModellingRule规定了建模规则，对象最多只能指定一个该引用；</li><li>HasModelParent引用规定了对象的父模型；</li></ul><p>对象类型节点可能的属性和引用：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu13zbjt8nj60eu09pt9p02.jpg" alt="img"></p><p>注意property翻译为<strong>特性</strong>。</p><p>变量节点：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu1409r1l0j60fp0dmwg902.jpg" alt="img"></p><p>变量类型节点（即变量节点中的HasTypeDefinition):</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu14160wopj60fp0bsjsz02.jpg" alt="img"></p><p>方法节点：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu141vc4fij60fn0b0dh802.jpg" alt="img"></p><p>引用类型节点：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu14h8g7q1j60ew080wf702.jpg" alt="img"></p><p>IsAbstract属性指示引用类型是否抽象，抽象的引用类型不能被实例化，只能用于组织。</p><p>视图节点：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu14lufi6mj60f908adgq02.jpg" alt="img"></p><p>这些概念实际上有点绕，下面是一个例子：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu1fgdpbf8j61480o178w02.jpg" alt="《OPC UA 学习教程 — 总览和核心概念》"></p><p>温度、压力传感器这里被定义为对象（而不是变量），连续两个黑色箭头表示ObjectType实例化为Object，连续两个白色箭头表示继承的子类型。<code>+</code>表示<code>hasComponent</code>, <code>-H-</code>表示<code>hasProperty</code>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu1fgodn7xj613h0oeq7w02.jpg" alt="《OPC UA 学习教程 — 总览和核心概念》"></p><h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><p>把信息建模分为四个详细步骤：</p><p>(1) 需求获取主要是从系统框架图和应用场景图中获取建模需要的设备类型、设备的参数即属性、设备具有的方法即事件，以及设备之间或设备与属性、设备与方法之间的关系,然后，根据特定领域相关规范来验证建模需要的信息，同时进行必要的补充，最后对这些节点信息归入八个标准的节点类别。</p><p>(2) 定义类型模型主要根据节点类别中的 4 个类型，分别定义对象类型模型、变量类型模型、引用类型模型、数据类型模型，然后合并为统一的类型模型，在定义这些模型时，UA 规范中已经存在的内置类型，可以不定义，在定义类型模型中仅仅显示根据特定领域扩展的类型，</p><p>(3) 类型模型定义之后，根据特定领域的具体实例对 4 个类型模型进行实例化，同时按照 OPC UA 服务器的标准地址空间方式，建立实例化信息模型。</p><p>(4) 利用 UA Address Space Model Designer 工具导出 XML 和 CSV 文档，作为实现实例化信息的数据来源。<br>OPCUA建模工具有：UAmodeler,opcua-modeler等。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>实际上OPC的建模和写Java代码差不多，就是在opc server上添加各种节点，并和PLC输入/输出端子做物理连接映射。</p><p>一般约定的建模方式：每个PLC建立一个dir，<code>/Objects/PLC1/device1</code></p><p>device1可以用设备sn命名，是一个Object，其Type是抽象的设备类型。里面含有多个变量，对应传感器的采集值。</p><p>那么遍历device1节点下的<code>Variable</code>就可以拿到所有需要采集的属性值，只要保证<code>Variable</code>的displayName一致（通过实例化Type创建的Object，变量的displayName肯定是一致的），在产品参数里面定义好物模型字段和displayName的映射就可以。</p><p>录入设备时，录入设备对应的节点路径就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iot </tag>
            
            <tag> opc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark3速记</title>
      <link href="2021/08/30/spark3%E9%80%9F%E8%AE%B0/"/>
      <url>2021/08/30/spark3%E9%80%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>spark的核心抽象概念是RDD，但是到了spark2就不再推荐直接使用rdd来编程，而是使用sparkSQL和StructStreaming（代替旧的spark streaming）。</p><p>由于架构问题，spark无法做到真正的realtime，所以在流处理这里，国内团队基本都是以flink为主。这就造成了lambda架构中，离线数仓以hive+spark sql为主；实时数仓以flink+kudu/doris为主的两条链路。</p><p>根据业界目前公认的“批是有界流”抽象思路，Flink流批一体的架构是正确的方向。未来，大数据处理逻辑会简化成以Flink为计算中心，配合实时存储（HTAP数据库）的简化路径。甚至于，对于流量不太大的场景，直接使用TiDB+Flink/Spark的架构就可以同时满足流批处理需求。</p><h2 id="RDD概念"><a href="#RDD概念" class="headerlink" title="RDD概念"></a>RDD概念</h2><p>RDD is an <strong>immutable</strong>, <strong>fault-tolerant</strong>, <strong>partitioned</strong> collection of elements that can be operated on <strong>in parallel</strong>。</p><p>将数据集进行拆分，变为一个不可变、多分区的元素组合，这样就可以在多结点进行并行计算。</p><p>RDD支持比MapReduce多的多的算子，一般分为两类：</p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>此类算子是延迟执行的，直到Action算子出现。用于将RDD变换成新的RDD。</p><p>对应参数可以简单分为KV类型和纯value类型。</p><p>value类型包括：</p><ul><li>map</li><li>flatMap</li><li>mapPartitions: 遍历算子，可以改变RDD格式，会提高RDD并行度，遍历单位是partition，也就是在遍历之前它会将一个partition的数据加载到内存中。一般比map效率更高，但是可能会OOM，此时用repartition增加rdd数目即可解决；</li><li>mapPartitionsWithIndex</li><li>cartesian: 笛卡尔积</li><li>groupBy</li><li>groupByKey</li><li>filter</li><li>distinct</li><li>union: rdd数据并集</li><li>subtract: 差集</li><li>intersection: 交集</li><li>sample</li><li>cache/persist:  缓存/持久化，加快重复计算</li></ul><p>kv型包括：</p><ul><li>mapValues</li><li>combineByKey</li><li>reduceByKey</li><li>repartition</li><li>cogroup：将(k, v), (k, w)组合成(k, [v], [w])，即k和v的数组</li><li>join：连接，将(k, v)和(k, w)连接成(k, [v,w])，其中[v, w]是对k相同的集合value做笛卡尔积，即(1, 2) (1, 3)合并成(1,(2,2)), (1, (3,3))和(1,(2,3))，该操作用处较少</li><li>leftOuterJoin/rightOuterJoin/fullOuterJoin，类似数据库的左|右|全连接</li></ul><h3 id="action算子"><a href="#action算子" class="headerlink" title="action算子"></a>action算子</h3><p>spark会立刻执行action算子。</p><ul><li>foreach</li><li>saveAsTextFile</li><li>saveAsObjectFile</li><li>collect：收集结果，注意防止OOM</li><li>collectAsMap</li><li>count/countByKey/CountByValue</li><li>take/takeSample</li><li>reduce</li><li>aggregate：聚合，常用</li><li>zip/zipWithIndex</li></ul><h2 id="SparkSQL"><a href="#SparkSQL" class="headerlink" title="SparkSQL"></a>SparkSQL</h2><p>spark目前推荐直接使用sparksql进行操作，而不是使用低级的rdd。</p><p>这也符合整个大数据届从DBMS -&gt; NoSQL -&gt; NewSQL的发展趋势，Flink/Hive/Spark都重新回归SQL了。甚至ES、Clickhouse这些新型数据库也都是主推SQL了。</p><p>但是注意：使用sparkSQL和直接用hive on tez use llap的sql来计算，速度已经差不多了。</p><p>所以如果直接从hadoop3.x搭建基础设施的话，可以考虑回归到离线直接用hive来算，不再引入spark的旧路上。</p><p>一般使用步骤：</p><ol><li>先创建sparkSession</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.SparkSession;</span><br><span class="line"></span><br><span class="line">SparkSession spark = SparkSession</span><br><span class="line">  .builder()</span><br><span class="line">  .appName(<span class="string">&quot;Java Spark SQL basic example&quot;</span>)</span><br><span class="line">  .config(<span class="string">&quot;spark.some.config.option&quot;</span>, <span class="string">&quot;some-value&quot;</span>)</span><br><span class="line">  .getOrCreate();</span><br></pre></td></tr></table></figure><p>然后从数据源里面创建dataframe:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dataset&lt;Row&gt; df = spark.read().json(<span class="string">&quot;examples/src/main/resources/people.json&quot;</span>);</span><br></pre></td></tr></table></figure><p>df本身支持一些常见的数据库操作，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//select * from table where age &gt; 21</span></span><br><span class="line">df.filter(df.col(<span class="string">&quot;age&quot;</span>).gt(<span class="number">21</span>)).show();</span><br><span class="line"><span class="comment">//select age, count(*) from table group by age</span></span><br><span class="line">df.groupBy(<span class="string">&quot;age&quot;</span>).count().show();</span><br></pre></td></tr></table></figure><p><code>DataSet&lt;POJO&gt;</code>就是讲Row反序列化到具体的Java Bean，其实就是ORM的思路。</p><p>所以这玩意儿到最后就和一般的Java程序没啥区别了……</p><p>比如定义一个Person的POJO:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个encoder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Encoder&lt;Person&gt; encoder = Encoders.bean(Person.class);</span><br></pre></td></tr></table></figure><p>然后用<code>df.as(encoder)</code>就可以完成类型转换。</p><p>或者用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person().setName(<span class="string">&quot;xx&quot;</span>).setAge(<span class="number">18</span>);</span><br><span class="line">spark.createDataset(</span><br><span class="line">  Collections.singletonList(person),</span><br><span class="line">  encoder</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>也可以创建一个<code>DataSet&lt;Person&gt;</code>.</p><p>也可以从RDD逐步创建出DataFrame，步骤比较繁琐，必须要手动创造出schema：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an RDD</span></span><br><span class="line">JavaRDD&lt;String&gt; peopleRDD = spark.sparkContext()</span><br><span class="line">  .textFile(<span class="string">&quot;examples/src/main/resources/people.txt&quot;</span>, <span class="number">1</span>)</span><br><span class="line">  .toJavaRDD();</span><br><span class="line"></span><br><span class="line"><span class="comment">// The schema is encoded in a string</span></span><br><span class="line">String schemaString = <span class="string">&quot;name age&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the schema based on the string of schema</span></span><br><span class="line">List&lt;StructField&gt; fields = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String fieldName : schemaString.split(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">  StructField field = DataTypes.createStructField(fieldName, DataTypes.StringType, <span class="keyword">true</span>);</span><br><span class="line">  fields.add(field);</span><br><span class="line">&#125;</span><br><span class="line">StructType schema = DataTypes.createStructType(fields);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert records of the RDD (people) to Rows</span></span><br><span class="line">JavaRDD&lt;Row&gt; rowRDD = peopleRDD.map((Function&lt;String, Row&gt;) record -&gt; &#123;</span><br><span class="line">  String[] attributes = record.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> RowFactory.create(attributes[<span class="number">0</span>], attributes[<span class="number">1</span>].trim());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the schema to the RDD</span></span><br><span class="line">Dataset&lt;Row&gt; peopleDataFrame = spark.createDataFrame(rowRDD, schema);</span><br></pre></td></tr></table></figure><p>可以通过集成<code>UserDefinedAggregateFunction</code>实现UDF，类似DBMS里面的函数/存储过程。</p><p>sparkSQL可以直接在文件、Hive和JDBC上连接上运行.</p><p>如果需要用spark分析hive数据，推荐将hive存为parquet格式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bigdata </tag>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数仓模型理论知识笔记</title>
      <link href="2021/08/29/%E6%95%B0%E4%BB%93%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
      <url>2021/08/29/%E6%95%B0%E4%BB%93%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>枚举类型：标称属性</li><li>排序：序数属性</li><li>布尔类型：二元属性</li><li>普通数值：<ul><li>有0点：可以计算比率，所以称为比率标度属性，比如开氏温度</li><li>无0点：区间标度属性，比如摄氏温度</li></ul></li><li>字符串</li></ul><h2 id="统计维度"><a href="#统计维度" class="headerlink" title="统计维度"></a>统计维度</h2><ul><li>均值：普通均值、加权均值、截尾均值（舍去最大、最小的一部分之后）</li><li>分位数：从小到大排序后位于每个分位的数，常用的包括中位数、4分位数、100分位数等<ul><li>4分位第一个点叫$Q_1$, 第三个是$Q_3$, $IQR=Q_3-Q_1$，这是四分位极差</li><li>识别可疑离群点的通常规则是：挑选落在$Q_3$之上或者$Q_1$之下至少$1.5 \times IQR$位置的值</li><li>五数概括：4分位点加上最小、最大值；可用<strong>盒图</strong>表示</li></ul></li><li>众数：出现最频繁的值</li><li>中列数：最大和最小值的均值</li><li>方差：个体与均值的差的平方和</li></ul><h2 id="可视化技术"><a href="#可视化技术" class="headerlink" title="可视化技术"></a>可视化技术</h2><ul><li>像素图</li><li>散点图</li><li>直方图</li><li>切尔诺父脸</li><li>人物线条画</li><li>标签云</li></ul><h2 id="相似性与相异性"><a href="#相似性与相异性" class="headerlink" title="相似性与相异性"></a>相似性与相异性</h2><p>使用邻近性度量来量化该值。对于上文所说的集中数值类型，都有对应的公式。</p><p>对于字符串相似性，也有大量成熟算法（一般用于搜索引擎）。</p><h2 id="建模方式"><a href="#建模方式" class="headerlink" title="建模方式"></a>建模方式</h2><ul><li>星型：实际一般使用该方式，事实表+维度表<ul><li>事实表一般表示某些动作，维度表表示实体的属性</li><li>维度表属性可能会发生改变，称为渐变维(SCD)。所以需要有一个代理主键而不能直接用维度主键。渐变维有多种处理方案：<ul><li>SCD1: 直接用新的覆盖旧的</li><li>SCD2: 增加一个version字段，都存下来；另外还需要增加生效时间、过期时间字段；</li><li>SCD3：增加一个old_xxx字段，只最近两个版本（用的比较少）</li></ul></li></ul></li><li>星海：多个星型共用维度表</li><li>雪花：多个事实表彼此关联（速度较慢，一般不用）</li><li>DV: data vault，另外一种建模思路，理论模型更好，但性能较差。</li></ul><h2 id="维度表的维护"><a href="#维度表的维护" class="headerlink" title="维度表的维护"></a>维度表的维护</h2><ul><li>增加列：比较简单，直接alter表结构就行。注意hive的ORC表在低版本是无法加列的；</li><li>维度子集：一般是针对基础维度做物化视图，将其中某些值固定下来；</li><li>角色扮演维度：多个字段共用同一张维度表，使用alias即可解决；</li><li>层次维度：<ul><li>固定深度：可以用with rollup直接查</li><li>递归：使用UDTF查询，或者用其他sql引擎；如果递归的层次不剩，建议直接展开平面化</li><li>多层次路径：建立多个维度表</li><li>退化维度：将维度合入事实表</li><li>杂项维度：避免维度表过多，可以将一些枚举项的笛卡尔积放在同一个维度表里，称为杂项维度</li><li>维度合并：将多个维度合入一张表，也是利用笛卡尔积减少维度表</li><li>分段维度：将数值划成多个区间，相当于加了一个枚举字段作维度</li></ul></li></ul><h2 id="事实表的维护"><a href="#事实表的维护" class="headerlink" title="事实表的维护"></a>事实表的维护</h2><p>事实表一般分为：</p><ul><li>事务性事实：最基本的操作性事实表；</li><li>周期快照：按一定周期聚合的事实表；</li><li>累计快照：基于状态变化，将整个流程记录下来。如电商发货流程；</li><li>无事实的事实表：仅表明维度之间的关联关系，表本身就代表了某种事实；</li><li>迟到事实：补录的数据，这个非常麻烦，所有快照表都要重新生成。如果存在这种数据，需要修改的地方比较多。</li></ul><h2 id="数仓分层"><a href="#数仓分层" class="headerlink" title="数仓分层"></a>数仓分层</h2><p>习惯上将离线数仓分为以下几层：</p><ul><li>ODS层：源数据，基本不做任何处理</li><li>DW层：中间层，一般又可以分为2~3层：<ul><li>DWD: 与ODS隔离，增加日期维度，可以用增量ODS层和前一天的DWD层进行增量计算（快照比较）</li><li>DWB: 清洗层，矫正数据错误、空值处理、字段合并、数据规范化等</li><li>DWS：聚合数据</li></ul></li><li>ADS层：业务用的数据需求</li></ul><p>一般对业务开放ADS和DWS层，其它层仅给数仓内部使用。</p><h2 id="数据抽取"><a href="#数据抽取" class="headerlink" title="数据抽取"></a>数据抽取</h2><p>常用工具：</p><ul><li>sqoop: dbms -&gt; hadoop/hive</li><li>kettle: 类似</li><li>dataX: 同上</li></ul><p>全量抽取一般分为初装和后续增量抽取(CDC)。</p><p>初装比较简单，就是直接将目前数据库中所有数据全部抽过来作为ODS层。</p><p>CDC的增量方案：</p><ul><li>基于时间戳：一般数据有一个类似<code>update_time</code>类似的字段，表示数据更新时间，给一个阈值就可以判断出增量数据了；注意该方案无法得到物理删除（逻辑删除是可以的）；</li><li>基于触发器：在从库上建立触发器，实际上类似用基于变更日志的方式了；</li><li>基于快照：即上文所说的ODS层与DWD层做full join对比，可能会性能较差；</li><li>基于日志：比较正规的CDC方式，如MySQL的binlog；开发难度较大，不过目前使用Flink/Spark来开发也比较成熟了；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> bigdata </tag>
            
            <tag> theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive速记</title>
      <link href="2021/08/24/hive%E9%80%9F%E8%AE%B0/"/>
      <url>2021/08/24/hive%E9%80%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>众所周知，hadoop可以大略分为hdfs文件系统+MR引擎两部分构成，然后再加上yarn这个调度引擎（有的公司改用k8s调度了）。</p><p>Hive是用来将SQL语句转成MR的，最初是Facebook贡献，后转为Apache开源项目。</p><p>现在流行的是Hive on tez，后者取代MR作为DAG计算引擎。此外还有Hive On Spark，使用spark代替MR，Hadoop3之后，默认引擎变成了tez。</p><p>Hive依赖MySQL（或其他数据库），用来存放元数据(hive meta)。命令行下一般使用<em>beeline</em>访问hive server。</p><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">external</span>] <span class="keyword">table</span> [if <span class="keyword">not</span> exist] xxx (</span><br><span class="line">name type comment <span class="string">&#x27;&#x27;</span> # 列定义，语法类似MySQL</span><br><span class="line">) comment <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> ()  # 分区</span><br><span class="line">  clustered <span class="keyword">by</span> () <span class="keyword">into</span> n buckets # 分桶</span><br><span class="line">  [<span class="type">row</span> format delimited] # 序列化定义</span><br><span class="line">  <span class="keyword">NULL</span> defined <span class="keyword">as</span> <span class="string">&#x27;&#x27;</span> # <span class="keyword">null</span>值处理</span><br><span class="line">  fields terminated <span class="keyword">by</span> x # 字段分隔符</span><br><span class="line">  stored <span class="keyword">as</span> xxx # 存储格式</span><br><span class="line">  [location <span class="string">&#x27;/xxx&#x27;</span>] # 存储位置</span><br><span class="line">  tblproperties (); # 其他属性</span><br></pre></td></tr></table></figure><ul><li><p>CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXIST 选项来忽略这个异常。</p></li><li><p>EXTERNAL 关键字可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION），Hive创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</p></li><li><p>LIKE 允许用户复制现有的表结构，但是不复制数据。</p></li><li><p>用户在建表的时候可以自定义 SerDe 或者使用自带的 SerDe。如果没有指定 ROW FORMAT 或者 ROW FORMAT DELIMITED，将会使用自带的 SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的 SerDe，Hive 通过 SerDe 确定表的具体的列的数据。</p></li><li><p>如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCE；新版本一般使用ORC文件或者PARQUET格式，如果不使用复杂数据列，或者spark引擎，则优先考虑orc格式；</p></li><li><p>有分区的表可以在创建的时候使用 PARTITIONED BY 语句。一个表可以拥有一个或者多个分区，每一个分区单独存在一个目录下。而且，表和分区都可以对某个列进行 CLUSTERED BY 操作，将若干个列放入一个桶（bucket）中。也可以利用SORT BY 对数据进行排序，这样可以为特定应用提高性能。用来partition的维度<strong>并不是实际数据的某一列</strong>，具体分区的标志是由插入内容时给定的；</p></li><li><p>表名和列名不区分大小写，SerDe 和属性名区分大小写；表和列的注释是字符串；</p></li><li><p>SequenceFile支持三种压缩选择：NONE，RECORD，BLOCK。Record压缩率低，一般建议使用BLOCK压缩。</p></li><li><p>数据库常用间隔符的读取。我们的常用间隔符一般是Ascii码5，Ascii码7等。在hive中Ascii码5用’\005’表示， Ascii码7用’\007’表示，依此类推。使用不可见字符是为了防止和真实数据冲突；</p></li><li><p>分隔符设置：</p><blockquote><p>FIELDS TERMINATED BY：设置字段与字段之间的分隔符<br>COLLECTION ITEMS TERMINATED BY：设置一个复杂类型（array,struct)字段的各个item之间的分隔符<br>MAP KEYS TERMINATED BY：设置一个复杂类型(Map)字段的key value之间的分隔符<br>LINES TERMINATED BY：设置行与行之间的分隔符</p></blockquote></li><li><p>hive中不存在主键、外键的概念，也不推荐使用索引；</p></li><li><p>HIVE表中默认将NULL存为\N，可查看表的源文件（hadoop fs -cat或者hadoop fs -text），文件中存储大量\N，<br>这样造成浪费大量空间。而且用java、python直接进入路径操作源数据时，解析也要注意。</p><p>另外，hive表的源文件中，默认列分隔符为\001(SOH)，行分隔符为\n（目前只支持\n，别的不能用，所以定义时不需要显示声明）。<br>元素间分隔符\002，map中key和value的分隔符为\003。</p></li></ul><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>一般使用<code>LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)]</code>直接装载数据到分区。</p><p>或者使用<code>INSERT OVERWRITE TABLE tablename PARTITION (partcol1[=val1], partcol2[=val2] ...) select_statement FROM from_statement</code>从别的表里插入数据。</p><p>也可以倒装成<code>from ... insert </code></p><p>其中<code>overwrite</code>用来先清空表格再插入。</p><h3 id="单条插入"><a href="#单条插入" class="headerlink" title="单条插入"></a>单条插入</h3><p>当建表时使用orc格式时，可以对单行数据CURD，甚至可以使用事务。语法类似MySQL。</p><h2 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><p><code>INSERT OVERWRITE [LOCAL] DIRECTORY directory1 SELECT ... FROM ...</code></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p><code>delete from ... where...</code>，仅orc支持。</p><p>其他存储格式，只能删除整张表，不允许修改或者删除单行数据。</p><h2 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h2><p>如上文所述，事务支持必须使用ORC存储，且表必须分桶。orc不支持直接LOAD DATA，必须从其他表插入。</p><p>修改hive-site.xml配置，做以下修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.support.concurrency<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.dynamic.partition.mode<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>nonstrict<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.txn.manager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hive.ql.lockmgr.DbTxnManager<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.compactor.initiator.on<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.compactor.worker.threads<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在MySQL里面插入元数据（3.x不需要）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> next_lock_id <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> next_compaction_queue_id <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> next_txn_id <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>修改结束后，需要重启服务。如果使用CDH或者HDP，可以直接在控制台上修改。</p><p>建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (id <span class="type">int</span>, name string) clustered <span class="keyword">by</span> (id) <span class="keyword">into</span> <span class="number">8</span> buckets stored <span class="keyword">as</span> orc tblproperties (<span class="string">&#x27;transactional&#x27;</span><span class="operator">=</span><span class="string">&#x27;true&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>NOTE</strong>：需要先安装好Hadoop并启动(<code>brew install hadoop</code>，然后修改一些配置)</p><p>可以手动插入一条数据做测试：<code>insert into t1 values(1, &quot;aaa&quot;)</code>，可以看到插入速度是非常慢的。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 (id <span class="type">int</span>, name string, cty string, st string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>创建一个txt文件，随便写点数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,a,us,ca</span><br><span class="line">2,b,us,cb</span><br><span class="line">3,c,cn,cc</span><br><span class="line">4,d,fr,cd</span><br></pre></td></tr></table></figure><p>然后使用语句导入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/tmp/test.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> t2;</span><br></pre></td></tr></table></figure><p>筛选导入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> t3 <span class="keyword">select</span> id,name,cty,st <span class="keyword">from</span> t2 <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>分区分桶：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t4 (id <span class="type">int</span>, name string) partitioned <span class="keyword">by</span> (country string, state string) clustered <span class="keyword">by</span> (id) <span class="keyword">into</span> <span class="number">8</span> buckets stored <span class="keyword">as</span> orc tblproperties (<span class="string">&#x27;transactional&#x27;</span><span class="operator">=</span><span class="string">&#x27;true&#x27;</span>);</span><br></pre></td></tr></table></figure><p>筛选导入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> t4 <span class="keyword">partition</span>(country,state) <span class="keyword">select</span> id, name, cty <span class="keyword">as</span> country,st <span class="keyword">as</span> state <span class="keyword">from</span> t2;</span><br></pre></td></tr></table></figure><p>注意partition后面的分区列必须和建表语句中声明的一致，后面select 需要用as转换出分区列的名字。</p><h2 id="优化与技巧"><a href="#优化与技巧" class="headerlink" title="优化与技巧"></a>优化与技巧</h2><ul><li><p>可以设置<code>set hive.mapred.mode=strict</code>强制使用分区过滤；</p></li><li><p>使用<code>hive -e</code>执行外部sql脚本；</p></li><li><p>外部表也可以建立分区，在外部添加分区目录后，使用<code>alter table xx add partition(col=$name) location &#39;&#39;</code>增加分区即可；</p></li><li><p>在hive命令行里可以执行<code>dfs</code>命令，和在bash里面跑<code>hdfs dfs</code>的命令一样；</p></li><li><p><code>load</code>命令不支持动态分区插入，所以必须建立一个中间表过渡；</p></li><li><p>null相关处理函数有：</p><ul><li><code>nullif(a, b)</code>，如果a==b返回null，否则返回a</li><li><code>coalesce(a1,a2,a3...)</code>，返回第一个非null值</li><li><code>nvl(a, b)</code>，如果a==null返回b，否则返回a</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> bigdata </tag>
            
            <tag> hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flink学习纪要</title>
      <link href="2021/08/12/flink%E5%AD%A6%E4%B9%A0%E7%BA%AA%E8%A6%81/"/>
      <url>2021/08/12/flink%E5%AD%A6%E4%B9%A0%E7%BA%AA%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>flink有两套API，一套是datastream，类似spark的RDD；另外一套则是TableSQL，这是一种更新的流批一体技术，两者可以相互转换。至于传统的批处理DataSet技术，将会在未来被废弃，不必再学习。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>根据Google的dataflow论文，批处理可以视为有界流，这是流批一体的理论基础。</p><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/program_dataflow.svg" alt="A DataStream program, and its dataflow."></p><p>上图是一段官方的示例代码，一个典型flink应用程序，数据从source中抽取，然后经过一系列<em>Operator</em>的<em>Transformation</em>，最后汇集到<em>sink</em>里。</p><p>注意，所有的operator之间是可以并发执行的，前提是对流进行按key hash，这也是为啥最后有一个sink等待结果汇总。</p><p>一般情况下，流数据都有一个时间戳<em>Event Time</em>，事件本身发生的时间顺序非常重要；与之对应的还有摄取时间（<em>ingestion time</em>）和算子的<em>processing time</em>。由于乱序到达问题，需要对事件进行按<em>Event Time</em>重排序，但是我们不能<strong>无限制</strong>的等待较早事件到来的可能，这会导致所有的事件都会被放弃处理。引入<em>watermark</em>的概念来解决这个问题，这是一个特殊事件发生器，将一个特殊时间戳插入流中，表示t之前的数据都已经全部到达。如果真的有事件早于t在watermark之后到来，称之为延迟事件。默认情况下，延迟事件将被删除。可以使用旁路输出单独获取这些延迟流；或者加一个允许延迟，在允许延迟范围内仍然会单独触发窗口；</p><p>Flink的算子可以<strong>保留状态</strong>，这种保留可以是持久化的，即便发生故障，也能达到<strong>精确一次计算</strong>( 每一个事件都会影响 Flink 管理的状态精确一次)的语义。当然端到端的精确一次需要程序本身的幂等性来实现。</p><p>可以看出，整体执行路径是一个有向图。</p><p><em>window</em>:  将事件流拆分成窗口，常见的方式有固定时间、滑动窗口、固定数量、滑动数量以及会话窗口（最小间隔），一些注意事项：</p><ol><li>滑动窗口是通过复制实现的；</li><li>时间窗口会和整数时间对齐；</li><li>如果窗口之间的距离足够小，窗口就会merge；</li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>flink提供了四层抽象等级，最上面一层是纯SQL</p><p>然后是Table SQL</p><p>然后是DataStream/DataSet的抽象</p><p>目前推荐使用的是：TableSQL/DataStream，这两类API，并根据需求创建UDF</p><h3 id="datastream"><a href="#datastream" class="headerlink" title="datastream"></a>datastream</h3><p>流式处理模式，主要需要掌握的是如何写自定义Function，使用state和window；以及Watermark的配置和使用。</p><h3 id="CEP"><a href="#CEP" class="headerlink" title="CEP"></a>CEP</h3><p>复杂事件处理</p><p>配合规则引擎可以动态处理事件规则</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:apache/flink-training.git</span><br><span class="line">git checkout release-1.13</span><br><span class="line"><span class="built_in">cd</span> flink-training</span><br></pre></td></tr></table></figure><p>通过readme进行练习测试。</p>]]></content>
      
      
      
        <tags>
            
            <tag> flink </tag>
            
            <tag> bigdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于阿里云iot平台的简化版设计方案</title>
      <link href="2021/08/03/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E7%89%A9%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%AE%80%E5%8C%96%E7%89%88%E6%96%B9%E6%A1%88/"/>
      <url>2021/08/03/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E7%89%A9%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%AE%80%E5%8C%96%E7%89%88%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象概念"><a href="#抽象概念" class="headerlink" title="抽象概念"></a>抽象概念</h2><ul><li><p>产品(Product)：使用相同连接方式+相同物模型的一类设备。基本字段：</p><ul><li><p>唯一标识：平台生成的产品唯一标识，一般是uuid；</p></li><li><p>名称；</p></li><li><p>描述；</p></li><li><p>节点类型：直连设备、网关设备和网关子设备；</p></li><li><p>联网方式：WiFi、蜂窝、以太网，以及lora，lora需要填入一些参数（前期先不支持）；</p></li><li><p>连接协议：指的是数据到上一级节点的通信协议。我们暂时<strong>不使用阿里云那种自定义topic+脚本转换</strong>的方式，而是选择已经对接好的协议：</p><ul><li>对于直连设备和网关设备：</li><li>标准MQTT协议：使用规定好的topic进行pub/sub，格式可以参考阿里云；<ul><li>标准HTTP(S)协议：使用规定好的url进行上报；如果想要下控，需要对端host地址；或者参考阿里云，<strong>不支持通过HTTP协议下控</strong>；</li><li>其他协议：手动对接的各类协议。所有协议都有唯一编码；</li></ul></li><li>对于网关子设备，可以实现一些常见的硬件协议，如：<ul><li>modbus协议；</li><li>opc ua协议；</li><li>ZigBee协议；</li><li>蓝牙协议；</li><li><strong>未知协议</strong>：这里的网关还包括云云对接的情况，此时网关产品下挂载的设备实际是一种虚拟设备；此时设备如何上第三方云平台我们是不必知晓的，此时标记为未知协议即可，该协议不需要任何参数；</li></ul></li><li>无论哪种设备，这里选择的协议都是设备与拓扑模型中的<strong>上一层</strong>通信的协议，协议需要的参数一般是配置在设备层的。</li></ul></li><li><p>物模型：<strong>暂不允许自定义物模型</strong>，只能从预置的物模型里面筛选；</p><ul><li>属性：属性其实是一种综合了事件+命令的抽象，自动生成对应的get/set命令，以及post属性的event；</li></ul></li><li><p>事件：设备上报的信息，使用json schema定义；</p><ul><li>命令：即服务，为了重构简单，仍然叫命令。也是json schema定义。</li></ul><p>注：</p><ol><li>物模型和连接协议都是通过<strong>使用场景+设备类型</strong>进行筛选的，移除以前设计的设备品牌+设备型号的抽象，更便于维护；</li></ol></li></ul><ol start="2"><li>与以前的设计不同，属性、事件和命令的标识符，只需要保证在同一设备类型下唯一即可。</li><li>参考阿里云的设计，属性上报的事件都固定叫<code>EVENT_POST_ATTR</code>，设置属性的命令叫<code>CMD_SET_ATTR</code>，获取属性的命令叫<code>EVENT_GET_ATTR</code>。实际上大部分设备都是定时上报属性，并不支持主动询问。所以属性应该分为：1：可读，2：可设置，4：可询问，这三种的位运算组合；</li><li><strong>非标准协议一般选择了协议就自动绑定了物模型</strong>，不再需要手动绑定；</li><li>选择了标准协议，但是没有绑定物模型，那就默认支持所有物模型。</li></ol><ul><li><p>校验类型：不可选，目前都是强校验，数据不符合要求的，塞入异常数据的kafka topic里；</p></li><li><p><strong>协议参数</strong>：某些协议参数可能需要在产品级别确定；</p></li><li><p><strong>注意</strong>：除了名称和描述，其他字段都是<strong>禁止编辑</strong>的，想改的话，就删除产品后重新添加；如果产品下面挂载的有设备，禁止删除产品；</p></li></ul></li><li><p>设备(Device)。设备是挂在产品下面的，继承产品的所有信息。由于大部分信息都定义在产品里了，设备这边的字段就很少：</p><ul><li>ID：平台对设备的唯一标识；</li><li>名称；</li><li>设备本身的标识：一般是硬件本身的序列号，但是也可以是别的，阿里这里用了deviceName；productKey+deviceName构成唯一索引；</li><li>状态：启用、禁用设备；</li><li>在线状态：只读数据；</li><li>对于网关子设备，还需要选择实际对接的网关设备（不考虑集群场景）；</li><li>secretKey：可以沿用以前的accessToken；</li><li><strong>协议参数</strong>：如设备的内外网host地址，设备自身访问密钥等；阿里云无此类参数的原因是其要求子设备与网关的通信自行协商。</li><li><strong>注意</strong>：设备的大部分信息也禁止编辑，要改的话也是删除后重新添加；</li></ul></li><li><p>设备分类：参考阿里云的设计，分为领域-场景-设备类型三层。不同场景可以包含统一设备类型；</p></li><li><p>TAG: 产品和设备都可以增加自定义的kv字段作为tag，主要用于搜索。之前设计的设备品牌、型号，都可以迁移到tag中，不影响接口返回值。可以沿用以前ext的json设计，也可以单独开表，为了节省时间可暂时沿用ext设计；</p></li><li><p>初期暂时不需要实现的功能：</p><ul><li>设备影子。该设计主要是为了解决设备网络情况不佳收不到下发命令的情况，以及主动索取设备属性导致请求过于频繁到设备压力较大的情况。后者可以使用事件/属性缓存完成，前者暂时让用户手动重发；</li><li>设备分组。该功能放在应用层做即可，只是为了方便管理；</li><li>任务(Job)功能：后期根据情况添加，可以和规则引擎融合；</li><li>证书相关功能：暂不需要；</li><li>通过脚本解析协议：优先级靠后，目前在代码层实现（脚本的性能较低，只是灵活度更高）；</li></ul></li></ul><h2 id="与阿里云平台的区别"><a href="#与阿里云平台的区别" class="headerlink" title="与阿里云平台的区别"></a>与阿里云平台的区别</h2><p>阿里云添加设备的流程是：</p><ol><li>添加产品；</li><li>添加设备；</li><li>设备/网关使用sdk<strong>主动连接</strong>阿里云平台，激活设备；</li><li>仅支持固定的云云对接场景；</li></ol><p>注意第3步是要求设备/或者设备网关适配阿里云平台，所以如果设备采用我们自研的MQTT软网关，可以使用同样的对接流程。但是我们要考虑更广泛的云云对接的场景，所以我们需要更多的参数。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里拿个人曾经对接过的一些设备类型作为例子，说明添加流程。</p><h3 id="标准协议设备直连"><a href="#标准协议设备直连" class="headerlink" title="标准协议设备直连"></a>标准协议设备直连</h3><p>任意设备使用标准协议，步骤都类似。</p><p>先新建一个产品，对应该类设备。然后选择标准协议，绑定物模型。</p><h3 id="标准协议网关连接"><a href="#标准协议网关连接" class="headerlink" title="标准协议网关连接"></a>标准协议网关连接</h3><p>创建一个网关产品，然后选择标准协议。</p><p>理论上，网关会根据实际连接的网关子设备来决定物模型，所以网关无须绑定物模型。</p><p>创建一个网关设备。</p><p>创建网关子设备产品，然后选择子设备连接网关的协议（一般是非标协议，物模型自动绑定）。</p><p>创建网关子设备，然后将其挂到网关设备管理之下。</p><h3 id="非标协议直连"><a href="#非标协议直连" class="headerlink" title="非标协议直连"></a>非标协议直连</h3><p>新普惠环境监测仪，采用自定义的modbus over tcp协议，蜂窝通信。在设备上设定服务器地址后，设备会主动连接服务器。但是上报数据需要服务器主动发送请求索取。</p><p>建立产品：节点选择直连设备，协议选择“智慧工地-环境监测-新普惠环境监测仪“</p><p>产品协议参数：采样间隔</p><p>添加设备：正常添加序列号即可</p><h3 id="非标协议边缘网关连接"><a href="#非标协议边缘网关连接" class="headerlink" title="非标协议边缘网关连接"></a>非标协议边缘网关连接</h3><p>宇泛人脸检测设备离线版，采用以太网通信，http+ftp协议（限局域网）。必须经过边缘网关转换才能正常与云端通信。</p><p>首先建立网关产品：假设这里是自研网关，采用标准MQTT协议（无须产品参数）；</p><p>然后在网关产品下面添加实际的网关设备，需要参数：</p><ul><li>ip地址；</li><li>其他协议通信地址；</li></ul><p>然后建立网关子设备产品：通信方式选择”智慧园区-人脸识别-宇泛设备离线版“；</p><p>网关子设备产品协议参数：</p><ul><li><p>上报地址：当有人通过考勤机时，上报到哪里。该参数也可以在实施的时候一次性设置好；</p></li><li><p>心跳间隔：该参数需要设置给设备，然后设备主动发起心跳与网关通信；</p></li></ul><p>然后添加网关子设备，关联到上文中网关产品下的设备，设备协议参数：</p><ul><li>局域网ip地址；</li><li>通信端口；</li><li>通信密钥；</li></ul><p><strong>注意</strong>：如果仅仅需要设备上报考勤信息，而无需人员、照片下发功能，也可以作为云端直连设备接入。此时所有参数都已经预先设置好，云端其实不需要任何参数。这种情况可以单独设置一个简化版协议。</p><p>同样，大部分直连设备都可以通过自研的边缘网关中转。</p><h3 id="非标协议云云对接"><a href="#非标协议云云对接" class="headerlink" title="非标协议云云对接"></a>非标协议云云对接</h3><p>宇泛人脸检测设备wo平台版，采用以太网通信，直连宇泛自家的wo平台，属于云云对接。</p><p>首先建立网关产品：通信协议选择”智慧园区-人脸识别-宇泛设备wo平台版”，产品本身不需要协议参数；</p><p>在网关产品下面增加网关设备，填入参数：</p><ul><li>wo平台appId；</li><li>wo平台appKey；</li><li>wo平台appSecret；</li></ul><p>增加网关子设备产品，通信协议选未知协议，不需要任何参数。</p><p>在网关子设备产品下，录入真正的人脸识别设备，也不需要额外参数。</p><h2 id="MySQL-schema设计"><a href="#MySQL-schema设计" class="headerlink" title="MySQL schema设计"></a>MySQL schema设计</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> device</span><br><span class="line">(</span><br><span class="line">    id              <span class="type">bigint</span> auto_increment comment <span class="string">&#x27;设备id&#x27;</span></span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    name            <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>                <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;设备名称&#x27;</span>,</span><br><span class="line">    sn              <span class="type">varchar</span>(<span class="number">128</span>)                           <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;设备标识&#x27;</span>,</span><br><span class="line">    product_code    <span class="type">varchar</span>(<span class="number">100</span>)                           <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;归属产品&#x27;</span>,</span><br><span class="line">    access_token    <span class="type">varchar</span>(<span class="number">100</span>)                           <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;直连访问密钥&#x27;</span>,</span><br><span class="line">    protocol_params json                                   <span class="keyword">null</span> comment <span class="string">&#x27;协议参数&#x27;</span>,</span><br><span class="line">    ext             json                                   <span class="keyword">null</span> comment <span class="string">&#x27;tags&#x27;</span>,</span><br><span class="line">    create_time     datetime     <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    update_time     datetime     <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> update <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">constraint</span> unq_product_device</span><br><span class="line">        <span class="keyword">unique</span> (product_code, sn)</span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;设备表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> device_category</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    domain_type <span class="type">int</span>    <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;领域code，中文在sys_dict里&#x27;</span>,</span><br><span class="line">    scene_type  <span class="type">int</span>    <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;场景&#x27;</span>,</span><br><span class="line">    device_type <span class="type">int</span>    <span class="keyword">null</span> comment <span class="string">&#x27;设备类型&#x27;</span>,</span><br><span class="line">    <span class="keyword">constraint</span> unq_relation</span><br><span class="line">        <span class="keyword">unique</span> (domain_type, scene_type, device_type)</span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;设备分类&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> product</span><br><span class="line">(</span><br><span class="line">    code            <span class="type">varchar</span>(<span class="number">100</span>)                           <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;随机生成的唯一标识&#x27;</span></span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    name            <span class="type">varchar</span>(<span class="number">100</span>)                           <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;产品名称&#x27;</span>,</span><br><span class="line">    conn_type       <span class="type">smallint</span>                               <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;联网方式&#x27;</span>,</span><br><span class="line">    node_type       <span class="type">smallint</span>                               <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;结点类型&#x27;</span>,</span><br><span class="line">    memo            <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>                <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">    protocol_code   <span class="type">varchar</span>(<span class="number">100</span>)                           <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;与上级的通信协议&#x27;</span>,</span><br><span class="line">    protocol_params json                                   <span class="keyword">null</span> comment <span class="string">&#x27;协议参数&#x27;</span>,</span><br><span class="line">    ext             json                                   <span class="keyword">null</span> comment <span class="string">&#x27;tags&#x27;</span>,</span><br><span class="line">    owner_app       <span class="type">bigint</span>                                 <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    schema_attrs    json                                   <span class="keyword">null</span> comment <span class="string">&#x27;物模型-属性&#x27;</span>,</span><br><span class="line">    schema_events   json                                   <span class="keyword">null</span> comment <span class="string">&#x27;物模型-事件&#x27;</span>,</span><br><span class="line">    schema_cmds     json                                   <span class="keyword">null</span> comment <span class="string">&#x27;物模型-命令&#x27;</span>,</span><br><span class="line">    create_time     datetime     <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    update_time     datetime     <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> update <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;产品表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> protocol</span><br><span class="line">(</span><br><span class="line">    code           <span class="type">varchar</span>(<span class="number">100</span>)            <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;协议唯一标识&#x27;</span></span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    name           <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;协议中文名称&#x27;</span>,</span><br><span class="line">    device_type    <span class="type">smallint</span>     <span class="keyword">default</span> <span class="number">0</span>  <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;协议适配设备类型&#x27;</span>,</span><br><span class="line">    product_params json                    <span class="keyword">null</span> comment <span class="string">&#x27;使用该协议通信的产品参数&#x27;</span>,</span><br><span class="line">    device_params  json                    <span class="keyword">null</span> comment <span class="string">&#x27;使用该协议通信需要的设备参数&#x27;</span>,</span><br><span class="line">    node_type      tinyint      <span class="keyword">default</span> <span class="number">7</span>  <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;适配结点类型。位运算：1-直连，2-网关，4-网关子设备&#x27;</span>,</span><br><span class="line">    conn_type      tinyint      <span class="keyword">default</span> <span class="number">0</span>  <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;0-我方服务端，1-我方客户端&#x27;</span>,</span><br><span class="line">    schema_attr    <span class="type">bigint</span>                  <span class="keyword">null</span> comment <span class="string">&#x27;协议绑定的物模型中的属性id&#x27;</span>,</span><br><span class="line">    schema_events  json                    <span class="keyword">null</span> comment <span class="string">&#x27;物模型中的事件数组&#x27;</span>,</span><br><span class="line">    schema_cmds    json                    <span class="keyword">null</span> comment <span class="string">&#x27;物模型中的命令数组&#x27;</span></span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;设备协议&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `schema_meta` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `device_type` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;设备类型&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `code` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;属性/命令/事件的编码，属性固定为ATTR&#x27;</span>,</span><br><span class="line">  `type` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;1-属性，2-事件，3-命令&#x27;</span>,</span><br><span class="line">  `data` json <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;属性的json schema描述&#x27;</span>,</span><br><span class="line">  `reply` json <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;对端回复的schema，一般只有命令需要&#x27;</span>,</span><br><span class="line">  `mode` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;事件的优先级：0,1,2；命令的执行方式0-异步，1-同步&#x27;</span>,</span><br><span class="line">  `required` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否必选&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unq_schema_elem` (`code`,`device_type`,`type`)</span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;物模型&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>具有相同物模型的设备应被归类为同一设备类型；</li><li>设备分类引用的都是系统字典里面的value_str；</li><li>物模型最终是由product中的字段确定的；</li><li>如果按着阿里云的设计，选择标准品类之后，物模型仍然是可以编辑的；也就是说，product里面保存的是数据的copy而非引用；</li><li>protocol表里关联的物模型，是私有协议对应的物模型，是schema_meta表里id的数组；举个例子：<ul><li>人类识别上传考勤信息时，体温信息是一个标准物模型里“考勤上传”这个事件的可选字段；定义在schema_meta里；</li><li>私有协议里的schema_events里面含有该事件；</li><li>产品在选择该私有协议后，自动绑定了该事件的副本。用户可以编辑物模型，将体温参数删除。</li></ul></li></ol><h2 id="物模型数据结构设计"><a href="#物模型数据结构设计" class="headerlink" title="物模型数据结构设计"></a>物模型数据结构设计</h2><p>阿里云是自定义了一套json来描述schema，我们这里直接用<a href="https://www.apifox.cn/help/reference/json-schema">json schema标准</a>，并进行扩展。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;temprature&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;温度&quot;</span>, <span class="comment">//名称</span></span><br><span class="line">      <span class="string">&quot;symbol&quot;</span>: <span class="string">&quot;°C&quot;</span>, <span class="comment">//符号</span></span><br><span class="line">      <span class="string">&quot;unit&quot;</span>: <span class="string">&quot;摄氏度&quot;</span>, <span class="comment">//中文单位</span></span><br><span class="line">      <span class="string">&quot;mode&quot;</span>: <span class="number">3</span>, <span class="comment">//1-可读取，2-可设置</span></span><br><span class="line">      <span class="string">&quot;minimum&quot;</span>: <span class="number">15</span>, <span class="comment">//最小值</span></span><br><span class="line">      <span class="string">&quot;maximum&quot;</span>: <span class="number">40</span>, <span class="comment">//最大值</span></span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="number">26</span>, <span class="comment">//默认值</span></span><br><span class="line">      <span class="string">&quot;step&quot;</span>: <span class="number">1</span> <span class="comment">//步长</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;windSpeed&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;风速&quot;</span>,</span><br><span class="line">      <span class="string">&quot;enum&quot;</span>: [ <span class="comment">//枚举值</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;enumDesc&quot;</span>: <span class="string">&quot;自动\n一级\n二级\n三级&quot;</span>, <span class="comment">//枚举描述</span></span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;0&quot;</span>, <span class="comment">//默认值</span></span><br><span class="line">      <span class="string">&quot;mode&quot;</span>: <span class="number">3</span> <span class="comment">//可读可写</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;required&quot;</span>: [ <span class="comment">//必选</span></span><br><span class="line">    <span class="string">&quot;temprature&quot;</span>,</span><br><span class="line">    <span class="string">&quot;windSpeed&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的细节可以参考阿里云进行扩展</p><h3 id="事件和命令"><a href="#事件和命令" class="headerlink" title="事件和命令"></a>事件和命令</h3><p>其实与属性类似，但是标识符需要分别手动设置。</p><p>此外：</p><ol><li>事件有个优先级设置（0-低，1-一般，2-高）；</li><li>命令有个同步、异步的设置，不过目前所有命令都是异步设计；</li><li>命令的回复也有一个schema；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> design </tag>
            
            <tag> iot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud-alibaba学习笔记</title>
      <link href="2021/07/01/springcloud-alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/07/01/springcloud-alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>公司技术选型决定使用<code>spring-cloud-alibaba</code>作为基础框架，这里简单记录一下对没用过组件的学习笔记。</p><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p>主要完成服务发现、配置分发、流量管理等功能。</p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>namespace：不同命名空间下，可以存在相同的group或者dataID。一般创建生产环境、测试环境等命名空间，方便隔离；</p><p>dataId: 配置集的ID，多个配置项组成一个配置集，对应普通模式下的配置文件名字；dataId一般按包名命名，但并非强制；</p><p>group: 一组配置集，即一个项目的多个配置文件。一般每个微服务独立一个group；</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs1g1cgqsaj30j40g6dho.jpg" alt="nacos_data_model"></p><p>使用主要看<a href="https://nacos.io/zh-cn/docs/nacos-spring.html">跟spring的集成</a>，和<a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">跟spring cloud的集成</a>，以及Java的<a href="https://nacos.io/zh-cn/docs/sdk.html">SDK</a>。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>这个就比较简单，应用将服务名和自身的ip:port注册到到nacos，并提供健康检查的url。其他服务通过服务名调用服务时就可以自动路由到正确的服务实例上，方便动态添加服务而无需修改配置文件。</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>主要完成熔断降级。即：任意资源调用出现异常比例上升时，让调用快速失败，避免服务雪崩。</p><p>一般使用较为简单，可以配合nacos持久化配置。支持<a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7">集群限流</a>和<a href="https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81">网关限流</a>。</p><p>生产环境使用的注意事项也较多，B端产品一般不需要限流。</p><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>这个就不用说了，RPC框架，我们暂时不会用。</p><p>新版本v3.0改了架构，支持跨平台通信了。</p><h2 id="scheduleX"><a href="#scheduleX" class="headerlink" title="scheduleX"></a>scheduleX</h2><p>这玩意儿没开源，估计还是用xxl-job的可能性更大。</p><p>前期可以先单点跑吧。</p><h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><p>这是spring cloud里面用于链路追踪的组件。但是这玩意儿他不跨语言，所以肯定不能用。</p><p>链路追踪有一个标准规范<code>open-tracing</code>，我们实际使用中zipkin/jaeger/skywalking用的更多。</p><p>Java技术栈的推荐使用skywalking，侵入性很小。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>也是Spring Cloud原生组件，用于操作消息队列。</p><p>如果有更换消息队列的需求或者考虑，可以使用Stream抽象的pub/sub来与消息队列通信，否则建议直接用kafka等组件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> “java&quot; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iot接入平台落地方案</title>
      <link href="2021/06/28/iot%E6%8E%A5%E5%85%A5%E5%B9%B3%E5%8F%B0%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88/"/>
      <url>2021/06/28/iot%E6%8E%A5%E5%85%A5%E5%B9%B3%E5%8F%B0%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>目前设计的物联网平台（以下简称平台）主要负责以下事宜：</p><ol><li>设备管理。设备模型抽象、相关数据维护；</li><li>设备接入。即所有设备的连接工作；</li><li>设备事件上报。设备事件接收-&gt;清洗-&gt;进入MQ的通用流程；</li><li>平台命令下发。提供接口给应用平台，后者可以给设备下命令；</li><li>设备状态维护。在离线、活跃、不活跃等状态；</li><li>[可选]规则引擎。提供通用抽象功能，允许应用平台创建规则触发某些预定义动作。比如温度&gt;37°自动打开喷淋开关并给用户推送高温预警。该功能亦可通过大数据平台实时流处理来实现。</li></ol><p>本设计稿参考了thingsboard、水务平台、阿里云物联网平台，并根据我个人以往设计经验总结。</p><h2 id="设备模型抽象"><a href="#设备模型抽象" class="headerlink" title="设备模型抽象"></a>设备模型抽象</h2><p>物联设备包括以下通用<strong>属性</strong>：</p><ul><li>ID，设备唯一标识；</li><li>名称(name)；</li><li>类型(type)。类型可以分级方便用户选择，比如智慧园区(region)-&gt;人员管理(category)-&gt;考勤设备(type)；</li><li>品牌(brand)。设备制造商的标示；</li><li>型号(model)。设备制造商给设备设计的型号；</li><li>序列号(serialNumber，简称sn)。设备制造商给设备分配的编号；</li><li>通信协议(protocol)。每个协议标识对应一个具体代码的通信模块。即使是同一件设备，不同固件的通信方式可能有所改变，比如v1和v2的接口可能不兼容；</li><li>协议配置(protocolParam)。某些协议可能会依赖其他的字段，比如第三方平台的账号密码等，如果没有的话无法正常建立通信。这里可以选择租户已经添加的配置；</li><li>其他<strong>扩展字段</strong>(extend)。比如设备通信地址（ip地址、蓝牙地址等），安装坐标；或者某类设备独有的属性，摄像头是球机和枪机、门禁是进还是出等等；允许自行添加kv字段，在数据库里可以用json/jsonb或者纵表；</li><li>支持事件(event)。同一类(type)设备往往支持类似的事件，如环境设备都支持上传环境数据，但是具体到设备上要看安装了多少传感器；</li><li>支持命令(command)。设备可执行的命令，同类(type)设备往往支持类似的命令，比如人脸识别设备一般支持远程开/关门；</li><li>租户(tenant)。理论上设备只能同时属于同一个租户，但是可以考虑设备属于多个租户的需求。比如一个设备归属方，其他的属于设备监管方，也有权查看设备数据。当然这个归属问题也可以在应用层来做，平台这边简单设计设备就只有一个租户；</li></ul><p>几个要点：</p><ul><li>设备ID应该由物联网平台生成，支持通过界面添加或者其他服务调用平台接口添加；</li><li>设备的brand-type-sn，应该构成唯一性，即同一品牌同一类型的设备序列号唯一；</li><li>protocol决定了设备通信的方式，添加设备时可以通过设备类型+设备品牌筛选protocol；</li><li>可用的protocol列表是与代码中的通信模块一一映射的，因此该列表由开发人员维护；</li><li>标准HTTP接口和标准MQTT接口是我方提供的两种通用的protocol，选择这两种接入时，服务端会自动生成访问密钥；</li><li>设备通过边缘网关接入和直连上云的唯一区别是协议参数需要选择对应的边缘网关，边缘网关和设备之间仍然使用协议模块通信，边缘网关和平台之间使用标准mqtt接口通信；</li><li>当设备/边缘网关采用标准HTTP接口通信时，仅当设备/边缘端有固定外网地址时，才能接受云端下发的命令。有时需要考虑内网穿透问题；</li><li>理论上，设备的brand-type-model-protocol决定了设备支持的事件和命令，以及事件/命令具体的参数；</li></ul><p>综上，需要设计以下表单/API进行设备数据录入(以下字段并非数据库中的字段，仅为示例)：</p><h3 id="设备类型管理"><a href="#设备类型管理" class="headerlink" title="设备类型管理"></a>设备类型管理</h3><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>code</td><td>int</td><td>类型码，枚举值，唯一标识，如200</td></tr><tr><td>name</td><td>string</td><td>中文名称，如：考勤设备</td></tr></tbody></table><p>为了避免各应用重复添加设备类型，该接口可以不开放，仅能通过界面手动添加。</p><p>如果需要<strong>级联</strong>的设备类型，则需要加入树结构管理，即parentId.</p><h3 id="设备品牌管理"><a href="#设备品牌管理" class="headerlink" title="设备品牌管理"></a>设备品牌管理</h3><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>唯一标识，可以用自增</td></tr><tr><td>name</td><td>string</td><td>如：海康</td></tr><tr><td>deviceTypes</td><td>[int]</td><td>该品牌涉及的设备类型，为了方便搜索</td></tr></tbody></table><h3 id="品牌型号管理"><a href="#品牌型号管理" class="headerlink" title="品牌型号管理"></a>品牌型号管理</h3><p>品牌型号的录入，只是为了细化设备对应的协议和支持事件/命令，其实也可以没有。</p><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>唯一标识，自增</td></tr><tr><td>name</td><td>string</td><td>型号名称</td></tr><tr><td>brandId</td><td>int</td><td>品牌id</td></tr><tr><td>deviceType</td><td>int</td><td>设备类型</td></tr></tbody></table><h3 id="连接协议管理"><a href="#连接协议管理" class="headerlink" title="连接协议管理"></a>连接协议管理</h3><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>code</td><td>string</td><td>唯一标识，如std-mqtt</td></tr><tr><td>name</td><td>string</td><td>中文名称，如标准MQTT接口</td></tr><tr><td>deviceType</td><td>int</td><td>驱动对应的设备类型，默认0表示支持所有设备类型</td></tr><tr><td>connMode</td><td>int</td><td>0-我方服务端(默认)，1-我方客户端</td></tr><tr><td>netMode</td><td>int</td><td>0-可以外网访问(默认)，1-仅支持内网通信</td></tr><tr><td>params</td><td>json schema</td><td>该驱动参数的json schema描述（后端）</td></tr></tbody></table><p>该表<strong>由开发人员维护</strong>。在未正式接入实际项目之前，前期先实现<code>std-mqtt</code>和<code>std-http</code>两类协议。</p><p><a href="https://json-schema.org/">json schema</a>是一种json数据结构自描述规范，前端需要据此动态渲染表格给用户展示，可以参考alibaba的<a href="https://github.com/alibaba/x-render">x-render</a>项目(react)，或者<a href="https://github.com/lljj-x/vue-json-schema-form">vue的版本</a>。</p><h3 id="协议关联管理"><a href="#协议关联管理" class="headerlink" title="协议关联管理"></a>协议关联管理</h3><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>brandId</td><td>int</td><td>品牌id</td></tr><tr><td>deviceType</td><td>int</td><td>设备类型</td></tr><tr><td>protocol</td><td>string</td><td>支持协议</td></tr></tbody></table><p><strong>该表用于用户添加设备时，选取可用协议。</strong></p><p>对于标准HTTP/MQTT接口，brandId设为0，表示该协议支持所有品牌。</p><p>之所以独立成表，是因为存在贴牌设备的问题，比如小米电视贴牌海信，实际通信协议是海信，即多对一可能。</p><p>也可以增加一个deviceModels字段，允许精确到设备型号进行筛选，不过维护列表的工作量较大。</p><h3 id="协议参数管理"><a href="#协议参数管理" class="headerlink" title="协议参数管理"></a>协议参数管理</h3><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>protocol</td><td>string</td><td>协议代码</td></tr><tr><td>name</td><td>string</td><td>该配置的名称</td></tr><tr><td>tenantId</td><td>string</td><td>租户id</td></tr><tr><td>gatewayId</td><td>int</td><td>0-云端直连，其他：边缘网关的id</td></tr><tr><td>data</td><td>json</td><td>对应protocol中的params</td></tr></tbody></table><p>gatewayId决定设备是直接上云，还是通过边缘网关上云。</p><p><strong>当设备仅支持局域网接入，而平台和设备无法在一个局域网时，只能通过边缘网关上云</strong>。如果设备可以使用第三方的边缘网关上云，则我方只需要对接该网关，此时视为<strong>直接上云</strong>，录入设备时协议选择对应硬件网关的协议即可；当平台和设备部署在同一个局域网时，也视为直接上云；<strong>仅当采用自研软边缘网关接入时</strong>，这里需要选择边缘网关的id。</p><p>data为一个动态表格，用户选择协议后填入依赖的参数。不同协议对应的字段需求不同，所以data内容不固定。对于前端，可以</p><p>由于协议依赖往往涉及到第三方的密码之类，所以必须进行数据隔离，加入tenantId字段。<strong>但是有时该协议参数为所有租户公用</strong>，此时可以设置tenantId为空，比如所有租户的视频都要接入我方租用的海康的ISC平台。当然</p><p>另外就是一些允许客户自定义的参数，如采集周期，限流设置等，也可以在协议参数里设置。</p><p>该表由运营人员或者售后人员维护，<strong>一般用户可能无法维护</strong>，涉及技术参数较多。</p><h3 id="设备事件管理"><a href="#设备事件管理" class="headerlink" title="设备事件管理"></a>设备事件管理</h3><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>code</td><td>string</td><td>事件唯一标示，如：EVENT_UPLOAD_ENV</td></tr><tr><td>name</td><td>string</td><td>事件中文名，如：环境数据上传</td></tr><tr><td>data</td><td>json schema</td><td>事件的json描述，通过该字段对接入数据进行validate和normalize</td></tr><tr><td>priority</td><td>int</td><td>事件优先级，不同优先级的消息将被push到不同的kafka topic</td></tr></tbody></table><p>data示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;title&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;personId&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;人员标识&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;一般是人员的身份证号&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;photo&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;图像&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;base64或者url&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;毫秒级时间戳&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;temperature&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;number&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;体温&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;保留一位小数&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;minimum&quot;</span>: <span class="number">30</span>,</span><br><span class="line">      <span class="attr">&quot;maximum&quot;</span>: <span class="number">45</span>,</span><br><span class="line">      <span class="attr">&quot;unit&quot;</span>: <span class="string">&quot;摄氏度&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;gender&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;性别&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;enum&quot;</span>: [</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;enumDesc&quot;</span>: <span class="string">&quot;女\n男&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;required&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;personId&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵从json schema标准语法，也可以根据情况进行扩展。比如上文扩展了一个“unit”字段，表示标量值的单位。扩展字段需要单独出一套语法规范给对接人员参考。</p><p>即使是同一事件，不同设备的参数也可能不同。比如考勤上报时，有的设备有体温数据，有的没有。data一般为同一事件可能数据的<strong>并集</strong>。</p><h3 id="设备命令管理"><a href="#设备命令管理" class="headerlink" title="设备命令管理"></a>设备命令管理</h3><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>code</td><td>string</td><td>命令唯一标示，如：CMD_TOGGLE_SWITCH</td></tr><tr><td>name</td><td>string</td><td>命令中文名，如：切换开关状态</td></tr><tr><td>data</td><td>json schema</td><td>命令的json描述，表示下达命令时需要额外填入的字段，比如status: 1或者0表示切换开还是关</td></tr></tbody></table><p>显然命令和事件可以合并到一个表里，不过命令不支持优先级（除非设备本身支持）。</p><p>即使是同一命令，不同设备需要的参数也可能不同。比如开关可能支持定时参数，此时一般将命令<strong>拆分</strong>成多个。如这里可以拆分成即时开关和定时开关两个命令。</p><p>设备命令原则上不支持重试/上线重发机制，因为可能存在一定的危险性。即所有命令默认都是<strong>即时</strong>的，如果此时设备不在线，不会尝试在设备重新上线后再发送。</p><h3 id="事件-命令关联管理"><a href="#事件-命令关联管理" class="headerlink" title="事件/命令关联管理"></a>事件/命令关联管理</h3><p>即设备支持哪些命令和事件的关联。</p><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>deviceType</td><td>int</td><td>设备类型，为0表示所有设备都支持</td></tr><tr><td>brandId</td><td>int</td><td>设备品牌</td></tr><tr><td>modelIds</td><td>[int]</td><td>设备型号列表</td></tr><tr><td>protocolIds</td><td>[int]</td><td>协议列表</td></tr><tr><td>events</td><td>[string]</td><td>支持事件列表</td></tr><tr><td>cmds</td><td>[string]</td><td>支持命令列表</td></tr></tbody></table><p>这里的设计比较粗犷，为了方便配置，这里在选择设备类型和品牌后，其他的都可以多选。如果要细化配置，可以针对每个type-brand-model指明事件参数，但是这样工作量较大，没有太大必要。</p><p>该关联对于规则引擎与用户交互，是必须的。对于应用层，也可以通过该关联直接判断设备是否支持某个命令。</p><h3 id="边缘网关管理"><a href="#边缘网关管理" class="headerlink" title="边缘网关管理"></a>边缘网关管理</h3><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>name</td><td>str</td><td>中文名称</td></tr><tr><td>tenantId</td><td>str</td><td>边缘网关对应的租户</td></tr></tbody></table><p>其实边缘网关就是一个特殊的设备，与平台采用标准MQTT通信，所以服务端也会自动生成访问的token。</p><h3 id="资产管理"><a href="#资产管理" class="headerlink" title="资产管理"></a>资产管理</h3><p>资产是设备的聚合，严格来说这并不是接入平台需要考虑的功能。产品可以根据需求自行发挥。</p><p>但是需要注意的是，某些设备之间是有关联的。比如视频设备和视频AI设备，可以在录入视频AI设备时，在扩展字段里选择关联设备。</p><h2 id="设备接入"><a href="#设备接入" class="headerlink" title="设备接入"></a>设备接入</h2><p>设备接入采用模块化设计，每个**模块(Module)<strong>对应一个上文中</strong>协议(Protocol)**。</p><p>可以将每个模块写在单独的jar包里，通过bean的生命周期启动(@PostConstruct)/停止(@PreDestroy)服务，最后部署的服务只需要引入实际设备对应模块就可以完成最小化部署。但是saas情况下不宜采用该方案，jar包会非常多；也可以全部写在一个服务里，然后通过<code>ConditionOnBean</code>之类的方式通过配置动态开关服务，唯一缺陷是最终的package体积可能会比较大；或者两种方法进行折中，根据某种方式（如设备品牌）聚合一下。</p><p>一个Module的设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IModule</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onInit</span><span class="params">()</span></span>; <span class="comment">//初始化时启动模块协议</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>; <span class="comment">//模块关闭时清理资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Command command)</span></span>; <span class="comment">//接受外部命令</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">//通用的命令，应用平台通过HTTP/RPC/Kafka发送过来</span></span><br><span class="line">    <span class="keyword">private</span> String code; <span class="comment">//对应上文中的设备命令，如CMD_TOGGLE_SWITCH</span></span><br><span class="line">    <span class="keyword">private</span> String reqId; <span class="comment">//请求的唯一ID，用于链路追踪</span></span><br><span class="line">    <span class="keyword">private</span> String reqSrc; <span class="comment">//请求来源服务的标示，如智慧工地/智慧园区的标示等</span></span><br><span class="line">    <span class="keyword">private</span> Device target; <span class="comment">//目标设备</span></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//请求的具体参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sync; <span class="comment">//同步命令还是异步命令，默认异步</span></span><br><span class="line">  <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> CompleteFuture&lt;String&gt; result; <span class="comment">//请求结果，非传入值。请求为同步命令时，用于将异步转化为同步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Integer type; <span class="comment">//设备类型</span></span><br><span class="line">    <span class="keyword">private</span> String sn; <span class="comment">//设备序列号</span></span><br><span class="line">    <span class="keyword">private</span> Long brandId; <span class="comment">//设备品牌ID</span></span><br><span class="line">    <span class="keyword">private</span> Long modelId; <span class="comment">//设备型号ID</span></span><br><span class="line">    <span class="keyword">private</span> String protocol; <span class="comment">//设备协议</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Module一般是基于Netty编码，Bean的名字就是protocol的名字。</p><p>有一个专门的module负责处理与应用平台通信，接收到平台命令时，通过target的protocol找到对应的通信模块，调用<code>call</code>将命令转发过去即可。Netty一般在自己的线程里处理命令，需要同步返回结果的，将结果放入result字段；异步返回结果的，也可以通过reqId+reqSrc实现。</p><p>事件上报同样由专门的模块实现，其他模块调用该模块的<code>call</code>来上报事件。为了防止数据丢失，必须保证数据放入kafka(ack all)后，再对设备端发ack. 当然设备端必须有重发机制，否则无论如何设备数据都可能丢失。</p><p>如果简化设计，可以使用kafka全异步通信，将所有Event和Command都是通过kafka来传递。<strong>以下会按全异步设计来写具体方案</strong>，同步设计只需要用上面的<code>result</code>进行转换，也可以在平台外面wrap一层同步的HTTP/RPC接口。</p><p>接入层架构图如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs2bfhy91vj31gi0rejvv.jpg"></p><p>这里标准MQTT还是选择用emqx作为broker，thingsboard内置的mqtt服务与thingsboard平台深度绑定，且不支持共享订阅，不建议使用。边缘端设备接入可以用emqx-edge（即设备本身就是用mqtt协议，且接入层部署在边缘端时）。</p><p>按着saas的设计，接入层全部在云端部署，此时接入集群共同订阅kafka的Command即可；还有一种方案是接入层整体部署在用户的本地（上面虚框部分），此时<strong>接入层整体视为一个边缘网关</strong>，云端只需要部署标准MQTT集群，该集群会将命令通过MQTT下发给接入层集群。接入层集群使用MQTT的<strong>共享订阅</strong>功能完成负载均衡。</p><p>如果用户有多个园区/工地/社区要管理，那么在园区/工地/社区本地部署接入层，在用户机房部署其他部分，这种设计可以派上用场。如果仅仅是单独的园区/工地/社区，那么全部部署在本地，此时设备全部视为直接上云。</p><p>接入层可以任意水平扩展，但是如果设备与服务端使用的是长连接，此时如果想要给设备发送命令，就必须知道设备实际连接到哪个结点了。下文会在<strong>设备状态维护</strong>里谈到该问题的解决方案。</p><h3 id="接入模块作为客户端"><a href="#接入模块作为客户端" class="headerlink" title="接入模块作为客户端"></a>接入模块作为客户端</h3><p>理想情况下，接入模块应该是作为服务端，设备主动向平台发送数据。但是实际上设备很多时候连接了厂商的中控平台或者云平台。此时连接模块只能作为客户端，主动向中间平台请求数据。</p><p>该场景下仍然可以用netty来写模块，但是存在一个额外的问题。即<strong>多服务结点时，如何进行通信任务的分发</strong>。</p><p>这里需要一个额外的服务来完成该工作，假设名为scanner。当租户添加的协议参数同时满足：</p><ol><li>这是一个客户端模式的协议；</li><li>该协议为云端接入（非边缘模式）；</li></ol><p>则将该协议视为一个待分发的客户端。scanner定期扫描所有待分发的客户端，将其push到kafka Command topic里，视为一种特殊的Command。获取到Command的接入层结点call协议对应的接入模块，模块则根据协议参数增加定时任务或者建立长连接等。</p><p>模块接受Command之后，要标记该客户端为已分发（比如采用redis kv标记）；在该服务节点关闭前，需要清除该标记，以便scanner重新分发该客户端。</p><p>边缘网关采用的是硬分配原则，所以边缘端从本地数据库扫描到客户端模式的协议配置后，直接启动服务即可。参考<strong>边云数据同步</strong>部分设计。</p><h2 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h2><h3 id="设备事件上报"><a href="#设备事件上报" class="headerlink" title="设备事件上报"></a>设备事件上报</h3><p>上文已经写了上报的大致流程，上报到kafka的数据结构大致如下(json格式)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: <span class="string">&quot;EVENT_UPLOAD_DATA&quot;</span>, <span class="comment">//事件编码</span></span><br><span class="line">  <span class="string">&quot;ts&quot;</span>: <span class="number">1234567890</span>, <span class="comment">//毫秒级Unix时间戳</span></span><br><span class="line">  <span class="string">&quot;deviceId&quot;</span>: <span class="number">12345</span>, <span class="comment">//设备id</span></span><br><span class="line">  <span class="string">&quot;tenantId&quot;</span>: <span class="string">&quot;abc&quot;</span>, <span class="comment">//设备此时的租户id</span></span><br><span class="line">  <span class="string">&quot;data&quot;</span>:&#123; <span class="comment">//具体的事件数据</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据事件的优先级投递到不同的topic. 在投递之前可以根据event的schema进行校验和规格化（也可以不处理，后续再进行流式处理）。</p><p>kafka后接不同消费者组，再对数据进行进一步处理，本平台会实现数据落库以及推送到规则引擎。大数据组或者应用组也可以订阅该数据做进一步处理，如推送给大屏/客户端等。</p><h3 id="设备连接状态维护"><a href="#设备连接状态维护" class="headerlink" title="设备连接状态维护"></a>设备连接状态维护</h3><p>设备连接状态的变化其实就是一类特殊的事件，比如可以命名为<code>EVENT_DEVICE_TOGGLE_ONLINE</code>.</p><p>设备在线一般是通过应用层心跳来维持的，如果采用长连接，可以用netty的<code>IdleStateHandler</code>来设置最小活跃周期（通过读取协议参数）；但是如果是HTTP短链接的话，每次请求可能router到不同接入层结点上，因此不能在内存中维持。此外如果有查询平台/租户所有在线设备等统计需求，也不能只将连接状态维护在内存里。</p><p>这里设计一个简单的解决方案：使用lua脚本，将设备最近一次心跳时间记录在redis zset里（可以根据最小活跃周期设置多个zset）。然后定时（周期比最小活跃周期小即可）扫描这些zset，确定心跳过期后认为设备离线。</p><p>设置设备在线示例代码如下，假设记录的key为<code>iot:device:heartbeat:120</code>，其中120表示心跳过期时间为120秒：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- argv[1]: 设备id, argv[2]: 心跳时间戳</span></span><br><span class="line"><span class="comment">-- ret[1]: 是否由离线变为在线</span></span><br><span class="line"><span class="keyword">local</span> old_ts = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;zrank&#x27;</span>, KEYS[<span class="number">1</span>], argv[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">local</span> update_ts = <span class="built_in">tonumber</span>(argv[<span class="number">2</span>])</span><br><span class="line"><span class="comment">-- 如果原来的值不存在，直接更新；或者时间戳更新</span></span><br><span class="line"><span class="keyword">if</span> old_ts == <span class="literal">nil</span> <span class="keyword">or</span> old_ts &lt; update_ts <span class="keyword">then</span></span><br><span class="line">  redis.call(<span class="string">&#x27;zadd&#x27;</span>, KEYS[<span class="number">1</span>], update_ts)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> old_ts == <span class="literal">nil</span></span><br></pre></td></tr></table></figure><blockquote><p>Redis6.2之后可以直接用<code>GT</code>选项完成上述功能，不再需要lua.</p></blockquote><p>离线扫描直接用<code>ZRANGE</code>配合<code>ZREMRANGEBYSCORE</code>即可完成，也是使用lua脚本保证原子性。</p><p>当然也可以用其他方案来完成该任务，比如<code>etcd</code>的<code>watch</code>等，可以根据平台选型来实现。上述方案是个单点方案，有更好的方案欢迎提出。</p><p>对于长连接，当连接建立时，需要在redis中记录设备和服务结点的<strong>双向映射</strong>。这样当Command的消费者结点接收到命令但是发现设备连接在另一个结点时，可以将命令转发到另一个结点。</p><p>当服务结点关闭时，长连接模块的清理方法需要将所有关联结点设置为离线，然后逐个断开连接并关闭服务。</p><p><strong>注意</strong>：一般不考虑服务端宕机或者网络断开问题，否则要处理的边界条件会大幅增加。</p><h3 id="应用命令下发"><a href="#应用命令下发" class="headerlink" title="应用命令下发"></a>应用命令下发</h3><p>如上文所述，平台可以提供HTTP/RPC/Kafka等多种通信方式供其他平台下发命令，但是考虑到某些命令的执行周期会很长（如向人脸识别设备下发1w个人员信息），全部设计为异步接口更加泛用。</p><p>假设这里使用Kafka通信，所有接入层结点对Command成为一个消费者组。接入层结点有一个专门的模块，假设为<code>module-command</code>,订阅该topic，接收到Command之后查找Module，调用<code>call</code>发送命令. 如果是长连接模块（短链接模块直接执行命令即可），该模块要检查连接是否在本结点，如果是的话直接执行就行；不是的话要考虑转发或者返回”目标不在线”的错误信息。</p><p>注意上面未考虑接入层服务拆分问题。如果拆分的话，还需要一个protocol到服务节点的映射。比如<code>std-mqtt</code>和<code>std-http</code>是两个独立的服务，组成一个Command Topic的消费组，前者拿到命令发现设备实际使用后者通信，那么需要一个机制找到后者服务节点，然后转发命令。</p><p>理论上所有的命令都一个返回值，由于是全异步通信，<code>Command</code>类中就不再需要<code>result</code>字段。netty线程中执行完命令后，直接调用<code>module-command</code>的<code>call</code>，后者将数据push到kafka中专门应答的topic中即可。</p><p>设计数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">//通用的命令，应用平台通过HTTP/RPC/Kafka发送过来</span></span><br><span class="line">    <span class="keyword">private</span> String code; <span class="comment">//对应上文中的设备命令，如CMD_TOGGLE_SWITCH</span></span><br><span class="line">    <span class="keyword">private</span> String reqId; <span class="comment">//请求的唯一ID，用于链路追踪</span></span><br><span class="line">    <span class="keyword">private</span> String reqSrc; <span class="comment">//请求来源服务的标示，如智慧工地/智慧园区的标示等</span></span><br><span class="line">    <span class="keyword">private</span> Device target; <span class="comment">//目标设备</span></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//请求的具体参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String cmd; <span class="comment">//对应请求中的code</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> status; <span class="comment">//状态码</span></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//应答描述，一般是错误信息</span></span><br><span class="line">    <span class="keyword">private</span> String reqId;</span><br><span class="line">    <span class="keyword">private</span> String reqSrc;</span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//具体数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用层订阅该应答的topic，即可获取命令执行的最终结果。可以按reqSrc分为不同业务的topic，避免数据混乱。</p><h3 id="运行时配置变更"><a href="#运行时配置变更" class="headerlink" title="运行时配置变更"></a>运行时配置变更</h3><p>显然，在接入层通信过程中，应用平台依然可以修改设备信息、协议参数等关键配置，这些配置变更必须立刻通知到接入层。</p><p>一个方案是使用maxwell/canon等组件订阅mysql binlog，发现对应表格数据变化后，向kafka Command Topic中push一条特殊的命令。订阅端清除redis中相关的缓存，并通知对应的模块断开原来的连接等。</p><p>如果不想引入额外的组件，也可以在变更save到db之后，手动执行该操作。</p><h3 id="边云数据同步"><a href="#边云数据同步" class="headerlink" title="边云数据同步"></a>边云数据同步</h3><p>当接入层在边缘侧时，需要考虑的问题要更加复杂一些。</p><p>边缘网关启动后，需要定时拉取该网关关联的设备列表和对应的协议参数，并将其save到本地数据库（以保证边云连接断开时，边缘端仍可正常运行）。可以根据数据最后更新的时间(update_time)，决定本地对应条目是否需要更新；或者通过update_time进行筛选增量拉取；</p><p>当配置参数变更时，消费端发现该设备/协议项是通过边缘端接入的，则会直接向mqtt broker publish qos为0对应的信息，边缘端也可以根据该消息进行即时处理。</p><p>但是由于边缘端和云端的连接无法保证稳定性，边缘端简单设计的话，<strong>仅进行定时拉取即可</strong>。</p><p>对于一般的Command，消费者模块发现protocol配置为边缘接入时，也可以直接publish到边缘网关对应订阅的topic，qos也应该为0。</p><h3 id="微服务设计汇总"><a href="#微服务设计汇总" class="headerlink" title="微服务设计汇总"></a>微服务设计汇总</h3><ul><li>接入层。接入层整体作为一个集群，可以全部写在一起，也可以根据需求进行拆分。比如std-mqtt和std-http都作为单独服务。拆分后注意接入层内部需要转发平台的命令；</li><li>单实例的scanner服务（负责客户端模式下的任务的分发），和心跳检测服务，可以写在一起。可以考虑其他方案；</li><li>web服务。基本的API供其他服务调用（根据技术选型，也可能是rpc服务）；如果平台需要做一个界面，相关接口也写在这里；</li><li>物联数据落库服务。订阅kafka数据流并落入时序数据库；</li><li>规则引擎服务。设计见下文；</li></ul><h3 id="组件使用汇总"><a href="#组件使用汇总" class="headerlink" title="组件使用汇总"></a>组件使用汇总</h3><h4 id="kafka相关设计汇总"><a href="#kafka相关设计汇总" class="headerlink" title="kafka相关设计汇总"></a>kafka相关设计汇总</h4><p>综上所述，kafka至少设计以下topic：</p><ul><li>事件上报的topic. 根据优先级可以分为多个；如果有些数据需要经过kafka stream处理后再落库，可以单独划一个优先级；</li><li>命令下发的topic. 所有接入层服务结点组成一个消费者组；运行时配置变更可以作为特殊的Command，比如code为<code>CONF_</code>前缀；</li></ul><h4 id="redis相关设计汇总"><a href="#redis相关设计汇总" class="headerlink" title="redis相关设计汇总"></a>redis相关设计汇总</h4><ul><li>设备配置信息会缓存在redis中，避免与设备通信时频繁查库。当收到配置变更Command时清除缓存；</li><li>设备连接状态会缓存在redis中，可以查询到在线设备id；</li><li>设备与服务结点的长连接映射会存储在redis中，可以查找到设备连接在哪个服务节点上，也可以查找服务节点上具体连接了哪些设备；</li></ul><p>部分功能可以使用别的组件来实现，redis只是说能做。</p><h4 id="mqtt设计汇总"><a href="#mqtt设计汇总" class="headerlink" title="mqtt设计汇总"></a>mqtt设计汇总</h4><ul><li>注意使用emqx的共享订阅，保证服务节点之间的负载均衡；</li><li>标准MQTT接入只有事件上报的topic和命令下发的topic；</li><li>边缘网关使用mqtt通信，必须设置非内存的store，保证qos&gt;0的数据不会遗失；</li><li>边缘网关应用层心跳使用qos为0的通信，其他信息使用qos为1的信息；</li><li>边缘网关只关心自己负责设备相关的配置的变更，所以推送的topic中应含有边缘网关的id，如<code>iot/edge/1/device/update</code>，表示给ID为1的边缘网关推送设备信息变更，<code>iot/edge/2/protocol/create</code>给ID为2的边缘网关推送新增的协议信息；当然<strong>如果采取定时拉取的方案，不必设计这块的东西</strong>；</li></ul><h2 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h2><p>规则引擎的设计较为复杂，需要进一步调研，thingsboard的规则引擎其实是一个数据流处理器（类似flink）。</p><p>这里给出原来的设计方案以供参考，该方案较为简单，但是可以满足一般的设备联动和自定义告警需求。</p><p>通过设备模型抽象，上文中已经明确了设备支持的事件和命令。规则引擎本质上就是when <em>event</em> happens，if match some <em>condition</em>, then do <em>actions</em>.</p><p>我们已经有了event和action，以及他们的参数。那么前端就可以根据这些参数，通过一门DSL，就可以组合出<code>condition</code>。简单的DSL可以直接使用json.</p><p>比如condition这里使用mongo query表达式，例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>:&#123;<span class="string">&quot;$lt&quot;</span>: <span class="number">8</span>&#125;, <span class="comment">//key1小于8; $lt(&lt;), $gt(&gt;), $le(&lt;=), $ge(&gt;=), $ne(!=), $eq(=)</span></span><br><span class="line">    <span class="string">&quot;key2&quot;</span>:&#123;<span class="string">&quot;$ge&quot;</span>: <span class="string">&quot;37.3&quot;</span>&#125;, <span class="comment">//key2大于等于37.3</span></span><br><span class="line">    <span class="string">&quot;$or&quot;</span>:[&#123;<span class="string">&quot;key3&quot;</span>:&#123;<span class="string">&quot;$regex&quot;</span>: <span class="string">&quot;\d&#123;3&#125;&quot;</span>&#125;&#125;,&#123;<span class="string">&quot;key4&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;], <span class="comment">//key3满足正则，或者key4=3，使用$like表示字符串包含</span></span><br><span class="line">    <span class="string">&quot;key4&quot;</span>:&#123;<span class="string">&quot;$in&quot;</span>:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;, <span class="comment">//key4=1或2或3</span></span><br><span class="line">    <span class="string">&quot;key6.0&quot;</span>: <span class="number">10</span>, <span class="comment">//数组第一个元素是10</span></span><br><span class="line">    <span class="string">&quot;key7.subKey1&quot;</span>:&#123;<span class="string">&quot;$lt&quot;</span>: <span class="number">10</span>&#125;, <span class="comment">//object的子元素小于10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端根据用户选择拼凑出条件，就是规则引擎的可视化。</p><p>我们定义一个命令(deviceType=0)，比如叫<code>SYSTEM_NOTIFY</code>，表示系统通知。参数是通知方式（短信、微信、电话等），通知频率等。用户设置condition，并选择该命令，这就完成了通用的告警配置。</p><p>用户也可以配置condition之后，选择一个设备，配置action，就可以完成设备联动。比如当环境监测仪上报的光照度&lt; nLux之后，就打开某个路灯的照明开关。</p><p>复杂的规则引擎支持规则链，或者等待多个条件等等。可以考虑借鉴工作流来实现。</p><h2 id="其他相关平台"><a href="#其他相关平台" class="headerlink" title="其他相关平台"></a>其他相关平台</h2><ul><li>鉴权服务。该平台不开放给普通用户使用，因此本设计方案里不涉及用户和权限部分。可以与其他内部平台共享同一套鉴权系统；另外需要注意，上文设计时仅考虑了单业务系统，如果是多业务系统租户id可能重复的时候，还要加上一个业务系统ID字段；</li><li>数据分析服务。接入平台只负责将物联数据写入到TSDB，数据分析需要独立的服务；</li><li>大数据流处理。原始的物联数据可能无法满足业务层的需要，一个典型的例子是人脸识别只能上报人员身份标示（如身份证号），该数据需要和业务系统中人员数据关联起来，才能被业务使用。此时就需要使用kafka streams等技术进行二次加工数据；</li><li>全平台日志审计。关键业务数据的增删改需要记录操作日志，以免出现问题时无法溯源；</li><li>推送系统（实时/离线，多渠道）。某些物联数据可能需要实时推送给客户端；规则引擎的告警也需要实时推送。显然应该有一个公用的推送系统；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gradle速成</title>
      <link href="2021/06/23/gradle%E9%80%9F%E6%88%90/"/>
      <url>2021/06/23/gradle%E9%80%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="groovy语法简介"><a href="#groovy语法简介" class="headerlink" title="groovy语法简介"></a>groovy语法简介</h2><p>先装个groovy，<code>brew install groovy</code>，然后<code>groovysh</code>进入命令行。注意dock里面会出现一个图标，这点比较蛋疼。</p><ul><li><p>语法其实蛮类似js，但是是强类型，用<code>def</code>声明变量支持类型推断，也可以直接声明类型；</p></li><li><p>内置List<code>[]</code>和Map<code>[:]</code>，Map用索引操作符和dot效果一致。使用<code>&lt;&lt;</code>向List/Map中append元素；</p></li><li><p>支持闭包，直接用<code>def a = &#123;k-&gt; println k&#125;</code>声明，隐藏参数<code>it</code>. </p></li><li><p>支持类似bash的字符串格式化，即<code>$&#123;var&#125;</code>;支持三引号的多行字符串；单双引号使用类似bash；</p></li><li><p>支持范围赋值<code>1..5</code>，支持直接写出正则（类似js），用 <code>=~</code>判断match；</p></li><li><p>类默认public；<strong>顶级表达式支持省略括号</strong>；</p></li><li><p>支持属性，可以直接赋值，但是也会隐式生成getter和setter以便和java保持兼容;</p></li><li><p>支持命名参数，默认构造函数可以直接通过命名赋值；</p></li><li><p>多属性赋值支持with语法；</p></li><li><p>支持<code>?</code>非空判断，支持直接用<code>==</code>判断等于，判断同一个对象用<code>is</code>；</p></li><li><p>更强的switch（类似模式匹配）；</p></li><li><p>True/False的判断类似python；</p></li><li><p>groovy的方法重载，命中优先的是运行时类型（而不是声明时类型）；</p></li></ul><h2 id="gradle基本概念"><a href="#gradle基本概念" class="headerlink" title="gradle基本概念"></a>gradle基本概念</h2><ol><li>projects和tasks，范围概念，从<code>&lt;&lt;</code>语法来看，tasks显然是一个List，可以通过<code>doFirst</code>和<code>doLast</code>在头部和尾部插入任务；</li><li>task可以配置type，相当于父类；</li><li>task里面写具体的groovy代码，执行具体的业务；</li><li>可以动态创建task；</li><li>task可以被跳过，使用<code>onlyIf</code>或者抛出<code>StopExecutionException</code>，或者将task的<code>enabled</code>属性设为false；</li><li>定义任务的inputs和outputs属性，Gradle会通过快照对比，确定该任务是否需要执行。一个例子是C++的单文件编译，如果代码没有修改的话，就不需要再编译了。合理设置会大幅提升编译速度；</li><li>可以用<code>finalizedBy</code>来指定finally任务；</li><li><code>file</code>函数总是相对于Gradle文件的路径，</li><li>Gradle的运行有配置阶段和执行阶段，可以加入对应的hook函数；</li><li>任务之间用<code>dependsOn</code>声明依赖，也可以用<code>taskA.mustRunAfter taskB</code>之类的声明强依赖；</li><li>可以直接声明函数供其他调用；</li></ol><h2 id="java构建"><a href="#java构建" class="headerlink" title="java构建"></a>java构建</h2><p>Gradle是一个配置工具，可以用来编译打包各种类型的项目。如果要用来搞java，就加入<code>apply plugin: &#39;java&#39;</code>引入java插件，它会自动引入各种task。比如使用<code>gradle build</code>跑编译。</p><p>源文件路径：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">    <span class="comment">//修改默认目录，下面还是和默认位置一样，如需配置其他目录修改即可</span></span><br><span class="line">    main&#123;</span><br><span class="line">        java&#123;</span><br><span class="line">            srcDir <span class="string">&#x27;src/java&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        resources&#123;</span><br><span class="line">            srcDir <span class="string">&#x27;src/resources&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖，指明maven中央仓库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后加入依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="attr">group:</span> <span class="string">&#x27;commons-collections&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;commons-collections&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;3.2&#x27;</span></span><br><span class="line">    testCompile <span class="attr">group:</span> <span class="string">&#x27;junit&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;junit&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;4.+&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是编译task、测试task和打包task。</p><h2 id="gradle配置项"><a href="#gradle配置项" class="headerlink" title="gradle配置项"></a>gradle配置项</h2><p>类似<code>pom.xml</code>，Gradle有个<code>build.gradle</code>的配置文件。</p><p>gradle这个项目严格来说做的<strong>很差</strong>，各版本之间兼容性不佳，所以最好直接看需要使用版本的官方文档，网上的教程极可能不适合你在用的版本。</p><p>这玩意儿很难不让人想起前端领域的webpack.</p>]]></content>
      
      
      
        <tags>
            
            <tag> gradle </tag>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thingsboard源码解析</title>
      <link href="2021/06/23/thingsboard%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/06/23/thingsboard%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>看的源码是最新的3.2 release版本，目前支持的最低JDK版本是11. 如果本地默认jdk是8的话，可以用<code>jenv</code>标记成11.</p><p>项目使用了lombok插件，构建系统为Gradle混合maven，通信使用了Protobuf，相关知识可以先自行补完。</p><p>另外，请一定要首先阅读<a href="https://thingsboard.io/docs/user-guide/entities-and-relations/">thingsboard官方文档</a>中<strong>key concepts</strong>这一节，明白它的抽象模型。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先IDE需要安装lombok和Protobuf相关插件，有个proto文件生成的java代码过大(<code>TransportProtos</code>)，默认是不会解析的。需要编辑ide的属性(Help-Edit Custom Properties)，加入<code>idea.max.intellisense.filesize=3000</code>，将上限提高到3M.</p><p>先在本地编译一下代码：<code>mvn clean install -Dmaven.test.skip=true</code>.</p><p>如果在编译过程中提示找不到Gradle，检查全局maven的<code>settings.xml</code>，参考配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun-central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/repositories/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-jcenter<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>jcenter<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun-jcenter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/repositories/jcenter<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-google<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>google<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun-google<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/repositories/google<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-gradle<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>gradle-plugin<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun-gradle<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/repositories/gradle-plugin<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-spring<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun-spring<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/repositories/spring<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-spring-plugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>spring-plugin<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun-spring-plugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/repositories/spring-plugin<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-grails-core<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>grails-core<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun-grails-core<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/repositories/grails-core<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-apache-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>apache snapshots<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun-apache-snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/repositories/apache-snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里将大部分常用的仓库替换成阿里的代理，正常的话，就可以编译成功了。</p><h2 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h2><p>根目录下分为以下几个文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── application # 主服务，单体部署时该服务就是最后跑的jar包</span><br><span class="line">├── common # 通用组件</span><br><span class="line">├── dao # 数据库dao层</span><br><span class="line">├── docker # 容器化部署所需要的docker配置文件和各种脚本</span><br><span class="line">├── img # logo文件夹</span><br><span class="line">├── k8s # k8s部署需要的配置文件和脚本</span><br><span class="line">├── msa # 微服务部署需要的maven子项目</span><br><span class="line">├── netty-mqtt # 使用netty实现的mqttv3服务器</span><br><span class="line">├── packaging # Gradle打包脚本，用于将前后端打包成rpm&#x2F;deb包</span><br><span class="line">├── rest-client # 测试用的rest客户端（可以忽略）</span><br><span class="line">├── rule-engine # 规则引擎</span><br><span class="line">├── tools # 一个迁移pg数据到timescaledb的工具</span><br><span class="line">├── transport # msa部署时独立的接入层服务</span><br><span class="line">└── ui-ngx # 前端项目，基于angular</span><br></pre></td></tr></table></figure><p>其中netty-mqtt这个库应该是fork了<a href="https://github.com/jeffreykog/netty-mqtt">这个库</a>，简单改了一些代码。</p><p>顶级transport文件夹下其实没有业务代码，只是一个独立的springboot application。真正的业务代码在<code>common/transport</code>下，通过<code>pom.xml</code>和 <code>ComponentScan</code>将对应的包加到依赖里，并随着springboot启动而自启动。</p><h3 id="actor模型"><a href="#actor模型" class="headerlink" title="actor模型"></a>actor模型</h3><p>首先要看一下这里tb自己实现的actor模型（替换掉原来的akka），在<code>common/actor</code>这里。actor模型是规则引擎的基础，规则链上每一个结点都是一个actor，显然这里如果用go的话，每个做一个goroutine就行；actor这里是创建了各类消息的一堆线程池。</p><p>自己写结点只需要用<code>@RuleNode</code>注解，然后实现<code>TbNode</code>接口就行。</p><p>actor服务的入口在application下的<code>DefaultActorService</code>，这里初始化了整个actor系统。</p><p><code>DefaultTbRuleEngineConsumerService</code>和<code>DefaultTbCoreConsumerService</code>是调用actor的入口，<code>AbstractConsumerService.onApplicationEvent</code>这里会在服务启动完毕之后拉起所有的消息队列consumer.</p><h3 id="设备数据处理逻辑"><a href="#设备数据处理逻辑" class="headerlink" title="设备数据处理逻辑"></a>设备数据处理逻辑</h3><p>接入层的代码处理逻辑其实差不多，只是支持的协议不一样。</p><p>查看mqtt的<code>MqttTransportHandler</code>中的<code>processMqttMsg</code>-&gt;<code>processPublish</code>-&gt;<code>processDevicePublish</code>，处理代码定位到<code>DefaultTransportService.process</code>中：</p><ul><li>处理消息时调用了<code>DefaultTransportService.process(deviceSessionCtx.getSessionInfo(), postTelemetryMsg, getPubAckCallback(ctx, msgId, postTelemetryMsg))</code>，这里创建了包装消息TbMsg；</li><li><code>getPubAckCallback</code>显然传入了个处理ack的回调函数，正常才会ack，异常就直接disconnect了。另外process代码中有流量控制（基于bucket4j的令牌桶）；</li><li>然后调用<code>sendToRuleEngine(tenantId, deviceId, sessionInfo, json, metaData, SessionMsgType.POST_TELEMETRY_REQUEST, packCallback)</code>将消息发往规则引擎；注意这里除了遥测数据外，有些数据调用的是<code>sendToDeviceActor</code>，将数据发往core；</li><li><code>packCallback</code>在原来callback的基础上wrapper了一些信息，最后调用实际MQ的send实现；</li><li>假设用的是kafka，这里就是调用<code>TbKafkaProducerTemplate.send</code>将数据放入消息队列，消息的类型是<code>TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;</code>；</li><li>查看thingsboard.yml，可以看到默认的ack设置是all，所以发送端没有exception才会ack，有异常就直接断开连接了；</li></ul><p>所以从发送端来看，接受mqtt消息-&gt;pub到kafka-&gt;wait ack-&gt; ack mqtt的逻辑没有问题，在这里<strong>消息不会丢失</strong>。</p><p>下面看消费端的逻辑：</p><p>消费端的入口比较难找，倒着来看，先找存储到db的代码，最后发现相关逻辑就在于<code>DefaultTelemetrySubscriptionService.saveAndNotify</code>这个方法里。调用方是<code>TbMsgTimeseriesNode.onMsg</code>，因此这里应用了上文所说的actor模型，即存储也是通过规则引擎完成的。</p><p>根据actor模型的入口<code>DefaultTbRuleEngineConsumerService</code>，查看<code>launchConsumer</code>的代码，可以看到这里取出了发送端入列的<code>TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;</code>，然后调用<code>forwardToRuleEngineActor</code>将消息转发给规则引擎。callback在这里被创建，实际调用<code>TbMsgPackProcessingContext</code>的callback，查看实现发现核心逻辑在<code>submitStrategy</code>的callback，而这提交策略来自于<code>ruleEngineSettings.queues</code>，需要查看配置文件<code>thingsboard.yaml</code>里面的<code>queue.rule-engine.queues</code>，这里面根据队列的名称有不同的提交策略。</p><p>查看提交策略相关代码，会发现队列名字取决于设备本身的<code>deviceProfile</code>。查看<a href="https://thingsboard.io/docs/user-guide/device-profiles/">官方文档</a>，会发现默认队列都是Main，此时提交策略是<code>BURST</code>，查看其实现代码，会发现<code>doOnSuccess</code>啥也没做。那么消费端的确认在哪里呢，回到<code>DefaultTbRuleEngineConsumerService</code>，会发现在这里直接就调用<code>consumer.commit()</code>了，并没有等待规则链调用完毕再进行消费确认。</p><p>所以<strong>消息的丢失是因为消费端并未等待真正落地才commit offset</strong>，而是转发给规则引擎后就立刻提交了。</p><p><strong>FIXME</strong>：存储到db层不应该走规则引擎，而是直接存储完成后再触发规则引擎。不过这种设计要考虑如何让应用层自定义数据验证、清洗的逻辑。</p><p>其他设备相关的逻辑，比如设备连接/断开，设备命令等，也是类似的抽象成各种事件，最后使用规则引擎来处理。</p><h3 id="微服务-msa-部署"><a href="#微服务-msa-部署" class="headerlink" title="微服务(msa)部署"></a>微服务(msa)部署</h3><p>从上面可以看出，tb的核心就是<strong>规则引擎</strong>，主要逻辑就是由规则引擎和接入层构成，存储只是规则引擎的一个节点。</p><p>msa这块，tb最开始作为单体服务设计，后面就是把这个单体服务拆分成msa.可以看<a href="https://thingsboard.io/docs/reference/msa/">官方架构文档</a>明白大概设计。</p><p>查看docker-compose文件，可以看到大致分为以下几个服务：</p><ul><li><p>zookeeper. kafka依赖，thingsboard节点服务发现；</p></li><li><p>Kafka. 通信依赖；</p></li><li><p>redis. 缓存；</p></li><li><p>tb-js-executor. 独立的js解释器，基于node.js；单体部署的时候，用的是嵌入式js执行器；</p></li><li><p>主服务. 包括：</p><ul><li><a href="https://thingsboard.io/docs/reference/rest-api/">REST API</a> calls;</li><li>WebSocket <a href="https://thingsboard.io/docs/user-guide/telemetry/#websocket-api">subscriptions</a> on entity telemetry and attribute changes;</li><li>Processing messages via <a href="https://thingsboard.io/docs/user-guide/rule-engine-2-0/re-getting-started/">rule engine</a>;</li><li>Monitoring device <a href="https://thingsboard.io/docs/user-guide/device-connectivity-status/">connectivity state</a> (active/inactive).</li></ul><p>后续版本会把规则引擎移出去作为一个独立的服务。</p></li><li><p>前端web-ui服务；</p></li><li><p>接入层独立服务(mqtt/http/coap)；</p></li></ul><p>可以看到各独立服务和单体的时候的区别就是加了个独立的入口，使得bean在不同的进程中运行而已。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> thingsboard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thingsboard压测报告</title>
      <link href="2021/06/21/thingsboard%E5%8E%8B%E6%B5%8B%E6%8A%A5%E5%91%8A/"/>
      <url>2021/06/21/thingsboard%E5%8E%8B%E6%B5%8B%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>目前thingsboard(以下简称tb)支持http/coap和mqtt三种协议，本次压测内容包括：</p><ol><li>基于http的qps测试；</li><li>基于mqtt的连接数测试；</li><li>基于mqtt的qps测试；</li><li>极限qps下，系统其他相关数据；</li></ol><p>tb使用rpm包单点安装在centos7上，mq采用kafka，db采用pg+timescaledb.</p><p>postgresql和tb安装在同一个节点机器上，采用默认配置，未做优化。</p><p>消息队列采用kafka，在单独的机器上，压测客户端也在此机器。</p><p>客户端和服务器所在机器配置均为4核16G.</p><h2 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h2><p>创建一个csv文件，生成3w台设备，导入系统（主要字段：设备名称、设备类型、accessToken）。</p><p>使用租户管理员登陆设备管理页面，导入创建的设备。</p><p>遇到的问题：导入创建设备时，前端提示超时，设备数量过多导致。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grl2fk5mzlj30hk04a0sw.jpg" alt="截屏2021-06-17 10.42.21"></p><p>最终成功导入29993个，失败7个，导入时长约25分钟。</p><p>在tb所在服务端安装服务器性能监测工具，这里用的是nmon.</p><p>tb服务端采用默认配置，未限制jvm内存，增大数据库连接池线程数到10。适当优化了服务器内核参数和文件描述符限制以更加接近生产环境配置。特别注意这里用的是真机安装，所以systemd本身的文件描述符限制也要改，参考<a href="https://developer.aliyun.com/article/762289">这里</a>。</p><p>压测客户端所在机器需要修改内核设置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">net.ipv4.ip_local_port_range</span> = <span class="number">1024</span> <span class="number">65000</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_mem</span> = <span class="number">786432</span> <span class="number">2097152</span> <span class="number">3145728</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_rmem</span> = <span class="number">4096</span> <span class="number">4096</span> <span class="number">16777216</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_wmem</span> = <span class="number">4096</span> <span class="number">4096</span> <span class="number">16777216</span></span><br></pre></td></tr></table></figure><p>由于只有一台压测机器，所以连接数最大只能测6万多，现在建立3w个设备，模拟3万连接。</p><p>先用curl测一下可用性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -X POST --data <span class="string">&quot;&#123;&quot;</span>temperature<span class="string">&quot;:19,&quot;</span>humidity<span class="string">&quot;:75&#125;&quot;</span> http://172.25.213.216:8080/api/v1/TOKEN-ENV-12230/telemetry --header <span class="string">&quot;Content-Type:application/json&quot;</span></span><br></pre></td></tr></table></figure><p>thingsboard使用的各个表意义可以参看<a href="http://www.atjiang.com/thingsboard-entity-database/">该文档</a>，我们主要需要关注<code>ts_kv</code>这个表，这里是上传遥感数据存放的表。<code>ts_kv_latest</code>则是各设备最新数据的缓存。</p><p>在<code>ts_kv</code>表里增加一列标明最终落库时间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> ts_kv <span class="keyword">add</span> <span class="keyword">column</span> create_ts <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> (<span class="built_in">extract</span>(epoch <span class="keyword">from</span> now()) <span class="operator">*</span> <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这样就可以通过：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ts_kv <span class="keyword">where</span> long_v <span class="operator">&gt;</span> ?;</span><br></pre></td></tr></table></figure><p><code>?</code>处填入本次压测开始的时间戳，筛选出本次压测写入的数据了。</p><h3 id="HTTP压测"><a href="#HTTP压测" class="headerlink" title="HTTP压测"></a>HTTP压测</h3><p>参考文档：<a href="https://thingsboard.io/docs/reference/http-api/">https://thingsboard.io/docs/reference/http-api/</a></p><p>使用工具：<a href="https://github.com/JoeDog/siege">https://github.com/JoeDog/siege</a></p><p>由于上传数据的API里含有设备token，所以这里先生成一个urls.txt，放在<code>/etc/siege</code>下，每行内容类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;172.25.213.216:8080&#x2F;api&#x2F;v1&#x2F;TOKEN-ENV-2&#x2F;telemetry POST &#123;&quot;temperature&quot;: 20, &quot;humidity&quot;:68&#125;</span><br></pre></td></tr></table></figure><p>POST后面的数据是随机生成的。</p><p>使用 <code>siege -c 1 -r 1 -b -v --content-type &quot;application/json&quot;</code>做单次调用测试，服务器正常的话会返回200表示OK。在thingsboard设备页查看最新数据，一切正常的话这里会看到刚才POST的数据。</p><p>siege默认最大并发是255，运行<code>siege.config</code>命令，生成<code>~/.siege/siege.conf</code>，然后修改该文件的<code>limit = 30000</code>打开限制。</p><p>下面模拟正常情况下的设备连接，500个设备，随机休眠0-10s，5分钟测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">siege -q -c 500 -d 10 -i -t 5m -v --content-type=<span class="string">&quot;application/json&quot;</span> | tee /tmp/benchmark.log</span><br></pre></td></tr></table></figure><p>结果如下：</p><blockquote><p>Transactions:               59433 hits<br>Availability:              100.00 %<br>Elapsed time:              299.94 secs<br>Data transferred:            0.49 MB<br>Response time:                0.03 secs<br>Transaction rate:          198.15 trans/sec<br>Throughput:                0.00 MB/sec<br>Concurrency:                5.81<br>Successful transactions:       58256<br>Failed transactions:               0<br>Longest transaction:            2.16<br>Shortest transaction:            0.00</p></blockquote><p>此时qps为59433/300，不到200，但是查看log发现有1177个请求返回400。显然http server的负载能力极差。经过检查源码，发现http transport直接使用的springboot，默认tomcat性能较差，故不再进行相关测试。</p><h3 id="MQTT压测"><a href="#MQTT压测" class="headerlink" title="MQTT压测"></a>MQTT压测</h3><p>mqtt层使用的是netty作为服务端，<a href="https://thingsboard.io/docs/user-guide/install/config/">默认</a>boss线程数1，worker线程数12，且没有打开keepalive。</p><p>参考文档：<a href="https://thingsboard.io/docs/reference/mqtt-api/">https://thingsboard.io/docs/reference/mqtt-api/</a></p><p>使用工具：<a href="https://github.com/krylovsk/mqtt-benchmark">https://github.com/krylovsk/mqtt-benchmark</a></p><p>由于thingsboard限制每个设备只能建立一个连接，且AccessToken必须不同，所以需要修改测试工具的代码。这里fork了一个分支，存放修改后的go源码：<a href="https://github.com/YiuTerran/mqtt-benchmark">https://github.com/YiuTerran/mqtt-benchmark</a></p><p>这个fork增加了从文件中读取配置的功能，并允许配置payload，且payload中有两个占位符可以被动态替换成发送时间和指定长度的随机ASCII码。这就可以满足我们测试的需要了。</p><p>使用以下命令简单测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mqtt-benchmark -broker tcp://172.25.213.216:1883 -clients 1 -count 1 -topic v1/devices/me/telemetry -username TOKEN-ENV-1</span><br></pre></td></tr></table></figure><p>一切正常，开始压测。</p><h4 id="并发连接数压测"><a href="#并发连接数压测" class="headerlink" title="并发连接数压测"></a>并发连接数压测</h4><p>先尝试10000台设备连接，每个1条消息，连接超时时间5s：</p><blockquote><p>Connect Ratio:                1.000<br>Average Connect Time (ms):    0.302<br>Connect Speed(conn/sec)        3310.000<br>Total Ratio:                 1.000 (10000/10000)<br>Total Runtime (sec):         0.700<br>Average Runtime (sec):       0.289<br>Msg time min (ms):           88.167<br>Msg time max (ms):           438.791<br>Msg time mean mean (ms):     283.851<br>Average Bandwidth (msg/sec): 3.622<br>Total Bandwidth (msg/sec):   14294.922</p></blockquote><p>平均每秒建立连接数3310，全部连接成功，消息全部发送成功。</p><p>改为2w台设备：</p><blockquote><p>Connect Ratio:                0.663<br>Average Connect Time (ms):    0.310<br>Connect Speed(conn/sec)        3224.992<br>Total Ratio:                 1.000 (13269/13269)<br>Total Runtime (sec):         0.903<br>Average Runtime (sec):       0.384<br>Msg time min (ms):           63.051<br>Msg time max (ms):           610.933<br>Msg time mean mean (ms):     377.913<br>Average Bandwidth (msg/sec): 2.741<br>Total Bandwidth (msg/sec):   14696.849</p></blockquote><p>此时出现连接失败，成功率为66.3%，连接速率仍然是3200左右。所以<strong>当前环境单节点netty服务器连接速率上限就是每秒3000~3500个连接</strong>，再快的话就会连接失败。</p><p>修改代码，每个连接之间中加入随机sleep 1~3ms，保证绝大部分客户端连接可以成功，继续下面的测试。</p><h4 id="QPS压测"><a href="#QPS压测" class="headerlink" title="QPS压测"></a>QPS压测</h4><p>先模拟正常场景的极限情况：3w台设备，每个1s采集一次数据，qos为1，每个数据1kb左右。<strong>实际场景中，采集频率一般在5s以上，大部分消息体也不足1k。</strong></p><p>每个客户端发送10条数据：</p><blockquote><p>========= TOTAL (29993) =========<br>Connect Ratio:                1.000<br>Average Connect Time (ms):    1.902<br>Connect Speed(conn/sec)        525.700<br>Total Ratio:                 1.000 (299930/299930)<br>Total Runtime (sec):         13.031<br>Average Runtime (sec):       11.441<br>Msg time min (ms):           1.922<br>Msg time max (ms):           2443.148<br>Msg time mean mean (ms):     690.198<br>Average Bandwidth (msg/sec): 0.876<br>Total Bandwidth (msg/sec):   23016.027</p></blockquote><p>实际成功连接数29993，消息发送全部成功。查看数据库ts_kv表，核对落库数据，最终为299669条，比发送端299930少了261条。查看日志发现有：</p><blockquote><p>2021-06-19 09:46:18,129 [nioEventLoopGroup-4-5] ERROR o.t.s.t.mqtt.MqttTransportHandler - [be4a23a5-ec20-4c82-8adf-a9dc317591b7] Unexpected Exception</p></blockquote><p>看来有未知bug导致数据丢失。多次重复该测试发现仍然有数据丢失，看来<strong>已经超出qps上限</strong>（此时写入约为23M/s)。</p><p>不断尝试调整消息发送间隔，最终发现在数据不丢失的情况下，最小消息间隔为1375~1400ms，此时发送端统计数据如下：</p><blockquote><p>Total Ratio:                 1.000 (299930/299930)<br>Total Runtime (sec):         14.542<br>Average Runtime (sec):       13.323<br>Msg time min (ms):           1.796<br>Msg time max (ms):           1218.753<br>Msg time mean mean (ms):     394.088<br>Average Bandwidth (msg/sec): 0.751<br>Total Bandwidth (msg/sec):   20625.662</p></blockquote><p>即最大写入带宽约为20M/s，qps为2w左右，<strong>超出最大qps会导致消息丢失</strong>。</p><p>下面测试负载大小与qps的关系，将负载从1kb降低到256字节，即降低到1/4，将发送间隔降低到1400/4=350ms，理论上此时发送带宽不变。</p><p>发送端统计数据：</p><blockquote><p>Connect Ratio:                1.000<br>Average Connect Time (ms):    1.906<br>Connect Speed(conn/sec)        524.585<br>Total Ratio:                 1.000 (299930/299930)<br>Total Runtime (sec):         6.803<br>Average Runtime (sec):       5.560<br>Msg time min (ms):           30.817<br>Msg time max (ms):           3690.415<br>Msg time mean mean (ms):     1401.135<br>Average Bandwidth (msg/sec): 1.808<br>Total Bandwidth (msg/sec):   44086.667</p></blockquote><p>查询数据库发现最终落库数据为233474条，出现较大数量丢失，可见<strong>qps与写入带宽不成线性关系</strong>。</p><p>反复调整发送消息间隔，最终测得在保证消息不丢失情况下，此时最小发送间隔为750~800ms，此时发送端统计数据如下：</p><blockquote><p>========= TOTAL (29993) =========<br>Connect Ratio:                1.000<br>Average Connect Time (ms):    1.898<br>Connect Speed(conn/sec)        526.812<br>Total Ratio:                 1.000 (299930/299930)<br>Total Runtime (sec):         9.098<br>Average Runtime (sec):       7.817<br>Msg time min (ms):           1.871<br>Msg time max (ms):           1516.970<br>Msg time mean mean (ms):     467.936<br>Average Bandwidth (msg/sec): 1.280<br>Total Bandwidth (msg/sec):   32967.141</p></blockquote><p>写入带宽仅为8M左右，<strong>qps为3w3左右</strong>。</p><p>正常情况下，设备采集间隔为5s左右。所以下面应该测试发送间隔5s，payload为256字节时的最大允许设备数。<strong>由于条件限制，这里暂时不再测试。</strong></p><h4 id="极限情况下落库延迟测试"><a href="#极限情况下落库延迟测试" class="headerlink" title="极限情况下落库延迟测试"></a>极限情况下落库延迟测试</h4><p>采用上面测试的极限参数进行落库延迟测试，3w台设备，发送256字节左右数据，发送延迟800毫秒，每台设备发送100条数据，等待数据全部落库，并使用nmon采集10分钟的服务器性能数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(create_ts<span class="operator">-</span>long_v) <span class="keyword">from</span> ts_kv <span class="keyword">where</span> long_v <span class="operator">&gt;</span>?;</span><br></pre></td></tr></table></figure><p>使用该sql获取最大延迟，此时的最大延迟约为342709ms，即5.7分钟左右，平均延迟为180141ms，约为3分钟，数据库平均写入速度为每秒8700行左右。<strong>这次测试中数据出现少许丢失，故已经达到qps极限</strong>。</p><h4 id="应用服务器性能数据采集"><a href="#应用服务器性能数据采集" class="headerlink" title="应用服务器性能数据采集"></a>应用服务器性能数据采集</h4><p>使用<code>NMONVisualizer</code>打开落库延迟测试中的采集文件。</p><p>CPU使用信息：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grnetwr880j31k00u0gxd.jpg" alt="截屏2021-06-18 17.15.15"></p><p>可以看到图线分为4段，第一段主要是建立mqtt连接(10:56-10:57)，第二段是客户端开始并发发送消息(10:57-10:58)，之后客户端断开连接；10:58到11:04，这6分钟是异步落库的时间，之后处理完毕回到无负载状态。</p><p>这里连接速率较低(每秒500个连接左右)，所以连接阶段的cpu占用只有40%左右。推测如果将连接速率达到极限(3300以上)，CPU将会超载。</p><p>在netty处理数据写入kafka的过程中（kakfa在另外一台机器上），CPU占用率达到95%左右。</p><p>异步落库阶段，CPU占用率在40~45%，由于数据库和应用在同一个机器上，从这张图里不太容易确定每个进程占用了多少CPU，需要使用其他工具辅助。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grnf0l02y6j31jd0u015u.jpg" alt="截屏2021-06-18 17.25.32"></p><p>数据库使用的数据盘，io图线见上，峰值写入达到90Mb/s左右，加权均值45Mb/s.</p><p>内存使用如下图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grnf2c7o3wj31l20u079y.jpg" alt="截屏2021-06-18 17.28.42"></p><p>总量约为16G，使用过程中占用内存从10.5G缓慢增长到12.5G左右，可用内存降到只有几百兆。</p><p>网络使用量如下图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grnf4hxz7ej31j90u0ak1.jpg" alt="截屏2021-06-18 17.32.07"></p><p>客户端峰值写入流量为50M/s左右，加权均值为20M/s左右，落库阶段从kafka读取数据批量写入，故该图线和vdb磁盘写入图线均呈现锯齿状。</p><p>线程使用情况：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grnf7v751aj31e10u0qfa.jpg" alt="截屏2021-06-18 17.34.25"></p><p>推测Netty的worker在数据通信阶段使用线程达到峰值，后续恢复正常。后续呈现锯齿状与数据库连接池或kafka消费线程池的使用有关。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><p>因为是直接用的springboot+tomcat充当web服务，tb的http transport性能较差，在单节点qps为200左右时就出现了上传失败；</p></li><li><p>本次压测服务器，单节点tb最大连接速率约为3300/s，超出该速度后，客户端建立连接失败；</p></li><li><p>Tb的mqtt netty服务端，qps极限值与mqtt payload大小有非线性关系，总体来说payload越大，qps极限值越小。<strong>qps超出极限时，数据会丢失</strong>。</p><ul><li>3w个节点，payload在270个字节左右，在保证数据不丢失的情况下，最小消息发送间隔为750~800ms，qps极限为3w3左右；</li><li>同样条件，payload 1k字节，qps极限值为2w左右；</li></ul></li><li><p>在mqtt测试中，服务端出现了<code>Unexpected Exception</code>错误日志，具体原因待查证；</p></li><li><p>后端异步落库，在qps较大时延迟会较大；此处涉及的原因可能包括：</p><ul><li>kafka参数配置；</li><li>连接kafka的消费端参数配置；</li><li>timescaledb的参数配置；</li><li>批量写入timescaledb的Java端参数配置；</li></ul><p>如果使用tb，此处是需要调优的重点对象。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> iot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用python生成word文档</title>
      <link href="2021/06/08/%E4%BD%BF%E7%94%A8python%E5%B0%86excel%E8%BD%ACword%E8%A1%A8%E6%A0%BC/"/>
      <url>2021/06/08/%E4%BD%BF%E7%94%A8python%E5%B0%86excel%E8%BD%ACword%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>有个任务是根据已有的word模板动态生成一部分内容，需要插入的数据包括：普通文本（部分含编号）；表格以及表格下方的标注（通过excel导入）；图片以及图片下方的标注；</p><p>使用的库主要是<a href="https://github.com/elapouya/python-docx-template">python-docx-template</a>以及pandas.  后者主要用来读取excel，所以还依赖openpyxl.</p><p>python-docx-template其实是<a href="https://python-docx.readthedocs.io/en/latest/">python-docx</a>这个库的扩展，两边的文档都要看一下。</p><p>需要先做好word的模板，可以参考python-docx-template项目下的<code>tests/templates</code>文件夹，里面是一些做好的word模板。注意几个点：</p><ol><li>除了内置样式(style)外，其他都通过样式窗格创建，这些样式需要使用<strong>英文命名</strong>；</li><li>内置样式的英文名称可以查看这里的<a href="https://python-docx.readthedocs.io/en/latest/api/enum/WdBuiltinStyle.html">文档</a>，总之出现在代码里<code>style=&#39;&#39;</code>，引号只能是英文；</li><li>一些简单的样式调整（如字体颜色、粗体、斜体、下划线），临时的对齐等，可以通过硬编码；</li><li>编号的生成是通过样式完成的，而不是手动在代码里生成；</li><li>无法生成目录，需要创建完成后手动更新域；</li><li>动态表头的生成非常复杂，目前可能完成不了某些需求；可以使用python-docx-template的replace dummy file思路进行替换，但是插入的表格可能会有点丑；</li></ol><p>其实大部分精力都是在<strong>调整样式</strong>上。</p><p>创建模板时，使用python-docx-template的类jinja2语法插入标签当做占位符：</p><ul><li>简单的变量替换都是<code>&#123;&#123; var1 &#125;&#125;</code>；</li><li>占位符特别需要注意空格的使用，普通占位符两边有空格，有前缀的占位符就不一定了；</li><li>大段复杂数据生成，使用<code>Sub-documents</code>技术，在文档里面放一个<code>&#123;&#123;p subdoc1&#125;&#125;</code>，注意p前面没有空格；</li><li>非完全动态的表格，可以先画个模板上去，参考templates里面<code>horizontal_merge_tpl.docx</code>和<code>vertical_merge_tpl.docx</code>这两个文档。可以满足一定的动态化需求；</li></ul><p>模板完成后就写代码，逻辑比较简单，就打开模板-&gt;渲染数据-&gt;另存为文件，三板斧结束。主要业务是生成占位符对应的渲染内容（一个dict），反正写的时候多看文档。</p><p>这个方案目前只能满足比较简单的文档需求，复杂的还是要手动调整的。只能说可以减轻部分工作量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty编程要点</title>
      <link href="2021/05/31/netty%E7%BC%96%E7%A8%8B%E8%A6%81%E7%82%B9/"/>
      <url>2021/05/31/netty%E7%BC%96%E7%A8%8B%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>现阶段的网络编程，更推荐使用golang而不是java，但是netty这个事件驱动的框架，在Java技术栈里面也算必须掌握的内容。对我个人而言，在熟悉go的<code>leaf</code>框架后，再回头来看netty，它的很多概念就不言自明了。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>首先回忆我们在leaf中是如何写一个<code>Module</code>的，我们定义接口如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Module <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line">OnInit()</span><br><span class="line">OnDestroy()</span><br><span class="line">Run(closeSig <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">RPCServer() *chanrpc.Server <span class="comment">//如果module可以接受外来的指令，则必须有一个chanrpc server，否则返回nil即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然一个模块拥有名称，生命周期管理的回调，<code>Run</code>就是启动事件循环，通过<code>RPCServer()</code>返回的结果进行模块间的事件传递通信。<code>chanrpc.Server</code>支持通过事件标示进行消息路由，最后发送到成员<code>chan *CallInfo</code>这个管道里，在<code>Run</code>中通过<code>for..select</code>从该管道中循环取出事件进行处理即可。</p><p>那么在netty中，我们定义一个事件循环为<code>EventLoopGroup</code>。需要有一个<code>Channel</code>来接受各种消息并注册回调函数，即<code>ChannelHandler</code>.使用<code>Bootstrap</code>容器类将eventloop和channel连接起来，就启动了一个模块。如果是我方作为客户端，只需要启动一个<code>EventLoopGroup</code>即可。</p><h2 id="抽象连接"><a href="#抽象连接" class="headerlink" title="抽象连接"></a>抽象连接</h2><p>在<code>leaf</code>中一个连接被抽象为一个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span> &#123;</span><br><span class="line">ReadMsg() ([]<span class="keyword">byte</span>, error)</span><br><span class="line">WriteMsg(args ...[]<span class="keyword">byte</span>) error</span><br><span class="line">LocalAddr() net.Addr</span><br><span class="line">RemoteAddr() net.Addr</span><br><span class="line">Close()</span><br><span class="line">Destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同协议实现该接口，并提供一个函数将<code>Conn</code>转变为<code>Agent</code>，然后再单独的协程里运行Agent:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Agent <span class="keyword">interface</span> &#123;</span><br><span class="line">Run()</span><br><span class="line">OnClose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即每个连接agent都运行在<strong>单独的协程</strong>里。</p><p>netty这里没法让每个连接在单独的线程里跑（线程太重），因为采用的是传统的池化处理方式。<code>EventLoop</code>在创建时实际创建了一个线程池，因此多个Channel实际上可能会公用同一个线程。</p><p>连接建立后，Channel会自动创建一个线程安全的<code>ChannelPipeline</code>，然后调用<code>Bootstrap</code>上面绑定<code>ChannelInitializer</code>将需要的<code>ChannelHandler</code>依次加到这个<code>ChannelPipeline</code>里，每个回调的<code>channelRead0</code>里要调用<code>fireChannelRead(msg.retain())</code>向下传递消息。</p><p>如果可以保证<code>ChannelHandler</code>是线程安全的，就用<code>@Sharable</code>注解该类，此时所有的连接可都共享同一个实例（pipeline直接添加这个单例），否则每个连接应new一个Handler添加到pipeline里。前者一般用<code>AttributeKey</code>来共享statefull的数据，后者可以直接用类的私有变量。</p><p><code>ChannelInitializer</code>是一个特殊的ChannelHandler，在向pipeline中添加相关组件后，该handler就会被移除(参考go中的Once). handler在初始化时就会执行，而childHandler会在客户端成功connect后才执行，这是两者的区别。</p><h2 id="数据分包"><a href="#数据分包" class="headerlink" title="数据分包"></a>数据分包</h2><p>直接扩展<code>ByteToMessageDecoder</code>，实现分包逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext cxt, Channel channel, ChannelBuffer channelBuffer)</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure><p>重载上述方法，返回null表示没有取到有意义的帧，否则表示解析正确的帧。</p><p>和leaf的设计不同，这里一般习惯在这里直接反序列化到具体的对象。</p><p>netty自带了一些拆包器，一般能满足大部分情况下的需求：</p><ol><li>FixedLengthFrameDecoder: 定长解码器来解决定长消息;</li><li>LineBasedFrameDecoder和StringDecoder:解决以回车换行符作为结束符的消息;</li><li>DelimiterBasedFrameDecoder: 特殊分隔符解码器;</li><li>LengthFieldBasedFrameDecoder: 自定义长度解码器</li></ol><p>其中最后一个可以灵活配置，他的四个参数分别表示：</p><ol><li>lengthFieldOffset 长度字段的偏差</li><li>lengthFieldLength 长度字段占的字节数</li><li>lengthAdjustment 添加到长度字段的补偿值</li><li>initialBytesToStrip 从解码帧中第一次去除的字节数</li></ol><p>当然如果协议比较复杂，还是需要手动解包。需要注意在数据到齐之前，不能移动游标，一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">   <span class="comment">//判断当前缓存中的数据是否满足一条指令的最小基础数据</span></span><br><span class="line">   <span class="keyword">if</span>(byteBuf.readableBytes() &gt;= BASE_LENTH)&#123;</span><br><span class="line">       <span class="comment">//寻找包头</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">           <span class="comment">//记录数据包开始的指针位置</span></span><br><span class="line">           byteBuf.markReaderIndex();</span><br><span class="line">           <span class="comment">//判断是否是属于包头</span></span><br><span class="line">           <span class="keyword">if</span>(byteBuf.readInt() == HEAD)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//不是包头</span></span><br><span class="line">           <span class="comment">//指针复位</span></span><br><span class="line">           byteBuf.resetReaderIndex();</span><br><span class="line">           <span class="comment">// 缓存指针向后移动一个字节</span></span><br><span class="line">           byteBuf.readByte();</span><br><span class="line">           <span class="comment">//判断当前缓存是否依然满足一条指令的最小长度</span></span><br><span class="line">           <span class="keyword">if</span>(byteBuf.readableBytes() &lt; BASE_LENTH)&#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//找到了当前的包头</span></span><br><span class="line">       <span class="keyword">byte</span> cmdOf1st = byteBuf.readByte();</span><br><span class="line">       <span class="keyword">short</span> cmdOf2nd = byteBuf.readShort();</span><br><span class="line">       <span class="keyword">int</span> dataLength = byteBuf.readInt();</span><br><span class="line">       <span class="comment">//检验当前指令的数据长度</span></span><br><span class="line">       <span class="keyword">if</span>(dataLength &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           channelHandlerContext.channel().close();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断当前数据是否已经到齐</span></span><br><span class="line">       <span class="keyword">if</span>(byteBuf.readableBytes() &lt; dataLength)&#123;</span><br><span class="line">           <span class="comment">//没到齐</span></span><br><span class="line">           <span class="comment">//复位到最开始的地方</span></span><br><span class="line">           byteBuf.resetReaderIndex();</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//数据到齐了</span></span><br><span class="line">       <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[dataLength];</span><br><span class="line">       byteBuf.readBytes(data);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据传递顺序"><a href="#数据传递顺序" class="headerlink" title="数据传递顺序"></a>数据传递顺序</h2><ul><li>Inbound event propagation methods:<ul><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#fireChannelRegistered--"><code>ChannelHandlerContext.fireChannelRegistered()</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#fireChannelActive--"><code>ChannelHandlerContext.fireChannelActive()</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#fireChannelRead-java.lang.Object-"><code>ChannelHandlerContext.fireChannelRead(Object)</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#fireChannelReadComplete--"><code>ChannelHandlerContext.fireChannelReadComplete()</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#fireExceptionCaught-java.lang.Throwable-"><code>ChannelHandlerContext.fireExceptionCaught(Throwable)</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#fireUserEventTriggered-java.lang.Object-"><code>ChannelHandlerContext.fireUserEventTriggered(Object)</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#fireChannelWritabilityChanged--"><code>ChannelHandlerContext.fireChannelWritabilityChanged()</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#fireChannelInactive--"><code>ChannelHandlerContext.fireChannelInactive()</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#fireChannelUnregistered--"><code>ChannelHandlerContext.fireChannelUnregistered()</code></a></li></ul></li><li>Outbound event propagation methods:<ul><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#bind-java.net.SocketAddress-io.netty.channel.ChannelPromise-"><code>ChannelHandlerContext.bind(SocketAddress, ChannelPromise)</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#connect-java.net.SocketAddress-java.net.SocketAddress-io.netty.channel.ChannelPromise-"><code>ChannelHandlerContext.connect(SocketAddress, SocketAddress, ChannelPromise)</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#write-java.lang.Object-io.netty.channel.ChannelPromise-"><code>ChannelHandlerContext.write(Object, ChannelPromise)</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#flush--"><code>ChannelHandlerContext.flush()</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#read--"><code>ChannelHandlerContext.read()</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#disconnect-io.netty.channel.ChannelPromise-"><code>ChannelHandlerContext.disconnect(ChannelPromise)</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#close-io.netty.channel.ChannelPromise-"><code>ChannelHandlerContext.close(ChannelPromise)</code></a></li><li><a href="https://netty.io/4.0/api/io/netty/channel/ChannelHandlerContext.html#deregister-io.netty.channel.ChannelPromise-"><code>ChannelHandlerContext.deregister(ChannelPromise)</code></a></li></ul></li></ul><p>习惯上在pipeline中添加handler时，先加decoder，后面跟着对应的encoder. 如：</p><ol><li>将字节流转换成帧(Bytebuf)的decoder；</li><li>将帧数据转换成字节流的encoder;</li><li>将帧反序列化到POJO的decoder;</li><li>将POJO序列化的encoder;</li><li>业务逻辑handler1（如写日志）；</li><li>业务逻辑handler2（正常逻辑）；</li></ol><p>一般这些handler都是<code>ChannelInboundHandlerAdapter</code>或者<code>ChannelOutboundHandlerAdapter</code>的子类。</p><h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><ol><li>需要注意，一个handler可以反复被添加到同一个pipeline，多个pipeline也可以公用同一个handler，这就造成一个handler可能会有多个context；</li><li>不同handler的context之间没有关系，也就是说这个context是局部上下文而非全局上下文；不同handler之间传递消息后者保存状态就要用<code>attr</code>了，这个是附属于channel的而不是cxt的（netty4.1版本前，ctx本身也有个attr，那个和channel的attr不互通，容易引起歧义，后来就改成channel的alias了）；</li></ol><h2 id="耗时任务"><a href="#耗时任务" class="headerlink" title="耗时任务"></a>耗时任务</h2><p>在go语言里，耗时任务单独开一个协程就可以了（但是要防止io资源耗尽问题）。由于线程的昂贵性，在netty里一般使用线程池或者TaskQueue来解决。</p><p>通过<code>channel.eventLoop.execute</code>在任务队列中插入任务，注意任务在队列中是单线程顺序执行的；通过<code>schedule</code>方法则可以调度定时任务。</p><p>如果需要循环定时执行任务，则调用<code>scheduleAtFixedDelay</code>方法即可，注意这个任务需要手动<code>cancel</code>掉。</p><h2 id="结合springboot使用的思路"><a href="#结合springboot使用的思路" class="headerlink" title="结合springboot使用的思路"></a>结合springboot使用的思路</h2><p>现在我们要写一个网关程序，它会与设备使用各种各样的协议进行通信，并接受应用层（其他服务）下达的命令转发给设备。</p><p>首先每个通信协议对应一个Bean，类似上文中Leaf的<code>Module</code>，Bean的名称采用设备<code>品牌-类型-驱动</code>，并实现一个<code>call(reqId, args…)</code>的方法。对于长连接通信，显然bean里面需要保存设备id与channel的映射（并在断开连接时清理）。</p><p>注意这个设计里，call的执行线程是与应用层通信的bean所在的线程，和实际通信的线程可能并不一样。不过channel.write本身是线程安全的。当应用层发送命令时，通过目标设备的<code>品牌-类型-驱动</code>找到对应的bean，然后调用call发送命令即可。</p><p>更优雅的设计则是，将命令发送到消息循环里。服务端可以通过<code>fireUserEventTriggered</code>向channel中传递一个自定义对象，channel在<code>userEventTriggered</code>回调里面处理对应的消息，可以保证回调和channel的读写在同一个线程里面进行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang文件操作的一个坑</title>
      <link href="2020/06/05/golang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"/>
      <url>2020/06/05/golang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>今天遇到一个蛋疼的问题，定位了很久，发现在windows上<code>path.Dir</code>获取的结果总是<code>.</code>，后来发现：</p><p><strong>在windows上永远只用<code>filepath</code>这个库里面的函数</strong>，不要直接用path</p><p>哎，浪费了一上午=_=</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Workflow入门.md</title>
      <link href="2020/05/21/Workflow%E5%85%A5%E9%97%A8/"/>
      <url>2020/05/21/Workflow%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>目前业务需要引入工作流引擎，现在开始调研相关技术和概念。目前开源的工作流引擎基本都是base在BPMN这套概念上的，所以对其深入了解是必须的（其实也很简单）。</p><p>入门文档最好的材料是<a href="https://docs.awspaas.com/reference-guide/aws-paas-process-reference-guide/index.html">国产的某个paas官方中文文档</a>，比较翔实。</p><h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>这块其实可选的很少，最知名的是Activiti，目前最新版本是7，亮点是支持k8s集成等云原生组件；然后就是Activiti早期版本fork出来的camunda；最后是Activiti后期版本fork出来的flowable.</p><p>这里我选择flowable，因为资料比较丰富，而且自带的前端界面有中文，方便内部使用。目前我们遇到的问题是不太清楚客户的具体需求，所以要使用工作流引擎保证可扩展性，但是不需要用户自己配置工作流（而是我们替他们配置好），所以自带的中文界面就比较重要了。这样是最简单快速的集成方案，后续可以自己实现一套前后端增删改查的接口，集成到自己的平台上。</p><p>那么这里主要描述如何将flowable集成到我们目前的系统里（一个SpringBoot项目，单db，暂时还没拆分成微服务）。</p><p>目标是：</p><ol><li>搞清楚如何通过自带的界面创建表单、流程；</li><li>如何把flowable整合到现有的业务中；</li><li>理清楚flowable创建表格/数据的意义，自己开发对应的API；</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>因为是测试，所以先切换到一个新分支进行开发。然后根据<a href="https://flowable.com/open-source/docs/bpmn/ch05a-Spring-Boot/">官方指南</a>，先把maven依赖集成到项目中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.flowable&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flowable-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;flowable.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>我这里用的是最新的6.5.0版本，倒入依赖，重新编译项目。发现Jar包比原来大了13M左右，这个引擎的依赖还是挺多的…</p><p>在配置文件里加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowable.async-executor-activate&#x3D;false</span><br><span class="line">flowable.database-schema-update&#x3D;true</span><br><span class="line"># 必要的字体设置</span><br></pre></td></tr></table></figure><p>注意后面那个必须设置为true，即使要手动建表。不过默认就是true，所以可以不设置。</p><h2 id="第一次运行"><a href="#第一次运行" class="headerlink" title="第一次运行"></a>第一次运行</h2><p><code>mvn clean install</code>之后，<code>mvn -o spring-boot:run -Drun.profiles=dev</code>试图跑起来，结果发现缺失某个依赖，加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.module&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-module-jaxb-annotations&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>然后再跑，报bean<code>taskExecutor</code>报冲突。</p><p>这里可以自己配置一下异步线程，避免和自己定义的默认线程池冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowableConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Process</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskExecutor <span class="title">processTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        String threadNamePrefix = <span class="string">&quot;flowable-task-&quot;</span>;</span><br><span class="line">        executor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line"></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">120</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cmmn</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskExecutor <span class="title">cmmnTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">1</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">5</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        String threadNamePrefix = <span class="string">&quot;flowable-cmmn-&quot;</span>;</span><br><span class="line">        executor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line"></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">120</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跑，会报表不存在的错误。在datasource后面加上<code>&amp;nullCatalogMeansCurrent=true</code>，让程序自己建表。</p><p>不过建议还是手动建表，因为默认的编码有点问题。mysql的原始sql在<a href="https://raw.githubusercontent.com/flowable/flowable-engine/flowable-6.5.0/distro/sql/create/all/flowable.mysql.all.create.sql%EF%BC%8C%E4%B8%8B%E4%B8%8B%E6%9D%A5%E6%94%B9%E4%B8%80%E4%B8%8B%E7%BC%96%E7%A0%81%E5%88%B0utf8mb4%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%8B%E5%8A%A8%E5%BB%BA%E8%A1%A8%E3%80%82">https://raw.githubusercontent.com/flowable/flowable-engine/flowable-6.5.0/distro/sql/create/all/flowable.mysql.all.create.sql，下下来改一下编码到utf8mb4，然后手动建表。</a></p><p>现在再跑，应该一切正常了。可以看到flowable的表都是大写的，不管是字段还是表名。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a href="http://www.shareniu.com/flowable6.5_zh_document/bpm/index.html">官方中文指南在此</a></p><p>首先BPMN图形本质上是一段xml代码，然后我们又知道xml可以与bean映射，所以这就完美融合了，即BPMN就是“代码生成器”。</p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>首先通过手动或者springboot的自动注册生成<code>ProcessEngine</code>对象，即规则引擎的工厂（线程安全）。然后手动编写流程bpmn对应的xml，或者通过界面生成也行。</p><p>然后利用服务部署这个流程。</p><p>每个流程有一个唯一id，调用流程就是通过id启动流程。把参数传进去，开始状态机的转换。</p><p>未完待续</p>]]></content>
      
      
      
        <tags>
            
            <tag> flowable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux无人值守安装镜像制作.md</title>
      <link href="2020/04/29/linux%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"/>
      <url>2020/04/29/linux%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>这里需要批量安装的是centos 7服务器版，首先下载centos 7最新版，带上GUI的镜像，装在虚拟机里面。然后下载centos 7 minimal镜像用作批量安装的母盘。</p><p>注意：不要装centos 8，这货特别大，而且没有图形化配置工具。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不同发行版支持的自动安装镜像技术不太一样，红帽这一系的主要使用kickstart，debian则使用<code>preseed</code>。这里安装的是centos7，所以用的主要是kickstart技术。</p><h2 id="kickstart配置"><a href="#kickstart配置" class="headerlink" title="kickstart配置"></a>kickstart配置</h2><p>首先使用yum安装图形化工具<code>system-config-kickstart</code>，对语法熟悉的也可以不用这玩意儿直接撸。</p><p>把镜像挂在到centos里，然后<code>cp -r</code>(需要包含隐藏文件）光盘里面的所有的内容到某个路径，比如<code>/root/iso/</code>。在<code>/root/iso</code>下建立文件夹存放kickstart配置文件，比如<code>/root/iso/kickstart/ks.cfg</code>。</p><p>打开图形化配置工具kickstart，根据个人需求进行配置。具体可以参考<a href="https://pdf.us/2018/08/13/1710.html">这里的介绍</a>。最后保存为刚才路径下的文件即可。</p><p>网络和个人帐户无需配置，因为可以离线安装。如果自己想装的额外的rpm包，使用<code>repotrack</code>工具下载到<code>Packages</code>文件夹里，在ks的<code>packages</code>部分中加入即可。</p><p>最后生成的ks文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#platform&#x3D;x86, AMD64, 或 Intel EM64T</span><br><span class="line">#version&#x3D;DEVEL</span><br><span class="line"># Install OS instead of upgrade</span><br><span class="line">install</span><br><span class="line"># Keyboard layouts</span><br><span class="line">keyboard &#39;us&#39;</span><br><span class="line"># Root password</span><br><span class="line">rootpw --iscrypted $1$0Rnj3JYy$.O6bjrhyiBucwxVpIg8eF1</span><br><span class="line"># System language</span><br><span class="line">lang en_US</span><br><span class="line"># System authorization information</span><br><span class="line">auth  --useshadow  --passalgo&#x3D;sha512</span><br><span class="line"># Use CDROM installation media</span><br><span class="line">cdrom</span><br><span class="line"># Use text mode install</span><br><span class="line">text</span><br><span class="line"># SELinux configuration</span><br><span class="line">selinux --disabled</span><br><span class="line"># Do not configure the X Window System</span><br><span class="line">skipx</span><br><span class="line"></span><br><span class="line"># System bootloader configuration</span><br><span class="line">bootloader --location&#x3D;mbr</span><br><span class="line"></span><br><span class="line"># Firewall configuration</span><br><span class="line">firewall --disabled</span><br><span class="line">services --disabled&#x3D;&quot;chronyd&quot;</span><br><span class="line">services --enabled&#x3D;&quot;sshd&quot;</span><br><span class="line"># System timezone</span><br><span class="line">timezone Asia&#x2F;Shanghai</span><br><span class="line"># Clear the Master Boot Record</span><br><span class="line">zerombr</span><br><span class="line"># Partition clearing information</span><br><span class="line">clearpart --all --initlabel</span><br><span class="line"># Disk partitioning information</span><br><span class="line">part &#x2F;boot --fstype&#x3D;&quot;xfs&quot; --size&#x3D;500</span><br><span class="line">part &#x2F;boot&#x2F;efi --fstype&#x3D;&quot;xfs&quot; --size&#x3D;500</span><br><span class="line">part swap --fstype&#x3D;&quot;swap&quot; --size&#x3D;1024</span><br><span class="line">part &#x2F; --fstype&#x3D;&quot;ext4&quot; --grow --size&#x3D;1</span><br><span class="line">poweroff</span><br><span class="line"></span><br><span class="line">%packages --multilib --ignoremissing</span><br><span class="line">lrzsz</span><br><span class="line">net-tools</span><br><span class="line">openssl</span><br><span class="line">python3</span><br><span class="line">screen</span><br><span class="line">tcpdump</span><br><span class="line">zip</span><br><span class="line">unzip</span><br><span class="line">vim-enhanced</span><br><span class="line">wget</span><br><span class="line">yum-utils</span><br><span class="line">nano</span><br><span class="line">NetworkManager-tui</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%addon com_redhat_kdump --enable --reserve-mb&#x3D;&#39;auto&#39;</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%post --nochroot</span><br><span class="line">cp -fr &#x2F;mnt&#x2F;install&#x2F;repo&#x2F;plus&#x2F;* &#x2F;mnt&#x2F;sysimage&#x2F;root&#x2F;</span><br><span class="line">echo &quot;&#x2F;bin&#x2F;bash &#x2F;root&#x2F;init.sh&quot; &gt;&gt; &#x2F;mnt&#x2F;sysimage&#x2F;etc&#x2F;rc.local</span><br><span class="line">chmod a+x &#x2F;mnt&#x2F;sysimage&#x2F;etc&#x2F;rc.local</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p><strong>每次</strong>修改packages里面的安装条目，需要重新生成repo数据库，语法是在镜像根目录执行<code>createrepo -g repodata/xxxx-c7-minimal-x86_64-comps.xml .</code>，文件的名字可能是一串随机字符，根据个人情况生成。</p><p>下面是修改isolinux.cfg保证使用kickstart文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">default vesamenu.c32</span><br><span class="line">timeout 50</span><br><span class="line"></span><br><span class="line">#省略一部分</span><br><span class="line"></span><br><span class="line">label linux</span><br><span class="line">  menu label ^Auto Install CentOS 7</span><br><span class="line">  menu default</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd&#x3D;initrd.img inst.stage2&#x3D;hd:LABEL&#x3D;CENTOS7 inst.ks&#x3D;hd:LABEL&#x3D;CENTOS7:&#x2F;kickstart&#x2F;ks.cfg quiet</span><br><span class="line"></span><br><span class="line"># 省略一部分</span><br><span class="line"></span><br><span class="line">menu end</span><br></pre></td></tr></table></figure><p>注意这里通过label指定ks文件的路径，防止U盘安装的时候找不到路径。卷标名在生成iso文件的时候可以修改，尽量不要用空格。</p><p>同样在<code>EFI/BOOT/grub.cfg</code>里面增加一个入口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menuentry &#39;Auto Install CentOS 7&#39; --class fedora --class gnu-linux --class gnu --class os &#123;</span><br><span class="line">       linuxefi &#x2F;images&#x2F;pxeboot&#x2F;vmlinuz inst.stage2&#x3D;hd:LABEL&#x3D;CENTOS7 inst.ks&#x3D;hd:LABEL&#x3D;CENTOS7:&#x2F;kickstart&#x2F;ks.cfg quiet</span><br><span class="line">       initrdefi &#x2F;images&#x2F;pxeboot&#x2F;initrd.img</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成iso文件"><a href="#生成iso文件" class="headerlink" title="生成iso文件"></a>生成iso文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/iso &amp;&amp; mkisofs -v -cache-inodes -joliet-long -R -J -T -V CENTOS7 -o /root/centos7.iso -c isolinux/boot.cat -b isolinux/isolinux.bin -no-emul-boot -boot-load-size 4 -boot-info-table -eltorito-alt-boot -e images/efiboot.img -no-emul-boot .</span><br><span class="line">isohybrid /root/centos7.iso</span><br><span class="line">implantisomd5 /root/centos7.iso</span><br></pre></td></tr></table></figure><p>上面是一个简单的脚本用来生成iso文件，注意这里使用-V改了卷标，和上面的hd:label保持一致。最后的alt-boot是efi启动支持。</p><p>最后使用dd刻盘到u盘，就可以安装了。</p><h3 id="自动配置脚本"><a href="#自动配置脚本" class="headerlink" title="自动配置脚本"></a>自动配置脚本</h3><p>注意到ks文件的post段里面，创建了一个一次性自运行的服务。在镜像根目录下创建<code>plus</code>文件夹，把想要复制到系统的文件都拷贝进去。<code>cp -fr /mnt/install/repo/plus/* /mnt/sysimage/root/</code>这句会将所有的文件拷贝到<code>/root/</code>目录下。</p><p>其中<code>init.sh</code>的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># wait other service start</span></span><br><span class="line">sleep 5</span><br><span class="line"><span class="comment"># iot-device</span></span><br><span class="line">mv /root/cron /etc/cron.d/iot-device</span><br><span class="line"><span class="comment"># params</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ClientAliveInterval 30&quot;</span> &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ClientAliveCountMax 86400&quot;</span> &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* - noproc 11000&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root soft nofile 1048576&quot;</span> &gt;&gt;  /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root hard nofile 1048576&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* hard nofile 1048576&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* soft nofile 1048576&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;fs.file-max = 1048576&quot;</span> &gt;&gt;  /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.somaxconn=32768&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;DefaultLimitNOFILE=1048576&quot;</span> &gt;&gt; /etc/systemd/system.conf</span><br><span class="line">sysctl -p</span><br><span class="line">sysctl -w net.core.somaxconn=32768</span><br><span class="line">sysctl -w net.ipv4.tcp_max_syn_backlog=16384</span><br><span class="line">sysctl -w net.core.netdev_max_backlog=16384</span><br><span class="line">sysctl -w net.ipv4.ip_local_port_range=<span class="string">&#x27;1000 65535&#x27;</span></span><br><span class="line">sysctl -w net.core.rmem_default=262144</span><br><span class="line">sysctl -w net.core.wmem_default=262144</span><br><span class="line">sysctl -w net.core.rmem_max=16777216</span><br><span class="line">sysctl -w net.core.wmem_max=16777216</span><br><span class="line">sysctl -w net.core.optmem_max=16777216</span><br><span class="line"></span><br><span class="line">sysctl -w net.ipv4.tcp_rmem=<span class="string">&#x27;1024 4096 16777216&#x27;</span></span><br><span class="line">sysctl -w net.ipv4.tcp_wmem=<span class="string">&#x27;1024 4096 16777216&#x27;</span></span><br><span class="line">sysctl -w net.ipv4.tcp_max_tw_buckets=1048576</span><br><span class="line">sysctl -w net.ipv4.tcp_fin_timeout=15</span><br><span class="line">sed -i <span class="string">&#x27;/.*init.*/d&#x27;</span> /etc/rc.local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空在安装阶段从光盘安装的所有文件</span></span><br><span class="line">rm -fr /mnt/*</span><br><span class="line">rm /root/*.cfg</span><br><span class="line">rm /root/TRAN*</span><br><span class="line">rm <span class="variable">$0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主动启动网卡</span></span><br><span class="line">interface=$(ls /sys/class/net| grep -v <span class="string">&quot;lo&quot;</span> | head -1)</span><br><span class="line">ifup <span class="variable">$interface</span></span><br><span class="line"><span class="keyword">if</span> [$? -ne 0];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;can&#x27;t start network, please run nmtui to connect Wi-Fi&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#获取当前网络信息</span></span><br><span class="line">default_route=$(ip route show)</span><br><span class="line">default_interface=$(<span class="built_in">echo</span> <span class="variable">$default_route</span> | sed -e <span class="string">&#x27;s/^.*dev \([^ ]*\).*$/\1/&#x27;</span> | head -n 1)</span><br><span class="line">address=$(ip addr show label <span class="variable">$default_interface</span> scope global | awk <span class="string">&#x27;$1 == &quot;inet&quot; &#123; print $2,$4&#125;&#x27;</span>)</span><br><span class="line">ip=$(<span class="built_in">echo</span> <span class="variable">$address</span> | awk <span class="string">&#x27;&#123;print $1 &#125;&#x27;</span>)</span><br><span class="line">ip=<span class="variable">$&#123;ip%%/*&#125;</span></span><br><span class="line">mask=$(route -n |grep <span class="string">&#x27;U[ \t]&#x27;</span> | head -n 1 | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line">gateway=$(route -n | grep <span class="string">&#x27;UG[ \t]&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">dns=$(cat /etc/resolv.conf | grep nameserver | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断default_interface是否为空</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$default_interface</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    default_interface=<span class="variable">$interface</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示网络信息</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;The current net info [dynamic]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;------------------------------------------&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot; device: <span class="variable">$default_interface</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot; ipaddr: <span class="variable">$ip</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;netmask: <span class="variable">$mask</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;gateway: <span class="variable">$gateway</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;    dns: <span class="variable">$dns</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;------------------------------------------&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># set last ip to 200</span></span><br><span class="line">IFS=<span class="string">&#x27;.&#x27;</span> <span class="built_in">read</span> -r -a array &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$ip</span>&quot;</span></span><br><span class="line">array[3]=200</span><br><span class="line">newip=$(IFS=. <span class="built_in">eval</span> <span class="string">&#x27;echo &quot;$&#123;array[*]&#125;&quot;&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;newip is <span class="variable">$newip</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#网络配置</span></span><br><span class="line">cp /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span> /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span>.bak</span><br><span class="line">uuid=$(cat /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span> |grep UUID|sed -e <span class="string">&#x27;s/&quot;//g&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;IPV6INIT=yes&quot;</span>               &gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;IPV6_AUTOCONF=yes&quot;</span>         &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;BOOTPROTO=none&quot;</span>            &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;DEVICE=<span class="variable">$default_interface</span>&quot;</span> &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ONBOOT=yes&quot;</span>                &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$uuid</span>&quot;</span>                     &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;TYPE=Ethernet&quot;</span>             &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PROXY_METHOD=none&quot;</span>         &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;BROWSER_ONLY=no&quot;</span>           &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;IPADDR=<span class="variable">$newip</span>&quot;</span>             &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;NETMASK=<span class="variable">$mask</span>&quot;</span>             &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GATEWAY=<span class="variable">$gateway</span>&quot;</span>          &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;DNS1=114.114.114.114&quot;</span>      &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;DEFROUTE=yes&quot;</span>              &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;IPV4_FAILURE_FATAL=no&quot;</span>     &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;IPV6_DEFROUTE=yes&quot;</span>         &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;IPV6_FAILURE_FATAL=no&quot;</span>     &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-<span class="variable">$default_interface</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#DNS配置</span></span><br><span class="line">cp /etc/resolv.conf /etc/resolv.conf.bak</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# Generated by NetworkManager&quot;</span> &gt; /etc/resolv.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 114.114.114.114&quot;</span> &gt;&gt; /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启一下网络 使配置生效</span></span><br><span class="line">systemctl restart network</span><br><span class="line">sleep 5</span><br><span class="line">ping -c 4 www.baidu.com</span><br><span class="line"><span class="keyword">if</span> [ $? != 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">     <span class="built_in">echo</span> -e <span class="string">&quot;Error! Cant link to Internet&quot;</span></span><br><span class="line">     <span class="comment">#break</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>简单来说，根据dhcp自动配置的ip地址，将其最后一位换成200，改成静态ip写死。如果怕ip地址冲突，直接将获得的ip写成静态ip也可以。<br>然后是一些常见服务器参数的改写，最后是禁止并删除掉一次性脚本的自启动，然后删除掉自身。</p><p>如果需要做一些服务相关配置，在这里也可以初始化，比如配置cron定期检查更新。</p><p>上面ks文件设置了安装完毕后自动关机，在合适的环境下插上网线开机，就会自动运行上面的初始化脚本，安装好服务。</p><h2 id="无线网卡"><a href="#无线网卡" class="headerlink" title="无线网卡"></a>无线网卡</h2><p>如果不是插网线，而是用无线网卡，这里的逻辑就比较复杂，必须让用户手动设置Wi-Fi。然后再手动运行脚本设置为静态ip。</p><p>在Package里面增加<code>NetworkManager-tui</code>这个包，init.sh里面判断如果ifup失败，就直接退出。</p><p>此时需要用户运行<code>nmtui</code>设置好Wi-Fi（注意Wi-Fi的ssid应为英文，不然显示是乱码）。然后运行如下脚本来将Wi-Fi设置成静态ip：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取当前网络信息</span></span><br><span class="line">default_route=$(ip route show)</span><br><span class="line">default_interface=$(<span class="built_in">echo</span> <span class="variable">$default_route</span> | sed -e <span class="string">&#x27;s/^.*dev \([^ ]*\).*$/\1/&#x27;</span> | head -n 1)</span><br><span class="line">address=$(ip addr show label <span class="variable">$default_interface</span> scope global | awk <span class="string">&#x27;$1 == &quot;inet&quot; &#123; print $2,$4&#125;&#x27;</span>)</span><br><span class="line">ip=$(<span class="built_in">echo</span> <span class="variable">$address</span> | awk <span class="string">&#x27;&#123;print $1 &#125;&#x27;</span>)</span><br><span class="line">ip=<span class="variable">$&#123;ip%%/*&#125;</span></span><br><span class="line">mask=$(route -n |grep <span class="string">&#x27;U[ \t]&#x27;</span> | head -n 1 | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line">gateway=$(route -n | grep <span class="string">&#x27;UG[ \t]&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">dns=$(cat /etc/resolv.conf | grep nameserver | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断default_interface是否为空</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$default_interface</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no working network, exit! if you want to use Wi-Fi, please run nmtui to set&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">cfg_name=$(<span class="built_in">cd</span> /etc/sysconfig/network-scripts &amp;&amp; grep -l Wireless *|grep ifcfg)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;config file is <span class="variable">$cfg_name</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#download iot-device</span></span><br><span class="line">/bin/python3 /root/cron_update.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示网络信息</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;The current net info [dynamic]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;------------------------------------------&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot; device: <span class="variable">$default_interface</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot; ipaddr: <span class="variable">$ip</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;netmask: <span class="variable">$mask</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;gateway: <span class="variable">$gateway</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;    dns: <span class="variable">$dns</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;------------------------------------------&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># set last ip to 200</span></span><br><span class="line">IFS=<span class="string">&#x27;.&#x27;</span> <span class="built_in">read</span> -r -a array &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$ip</span>&quot;</span></span><br><span class="line">array[3]=200</span><br><span class="line">newip=$(IFS=. <span class="built_in">eval</span> <span class="string">&#x27;echo &quot;$&#123;array[*]&#125;&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#网络配置</span></span><br><span class="line">cp /etc/sysconfig/network-scripts/<span class="variable">$cfg_name</span> /etc/sysconfig/network-scripts/<span class="variable">$cfg_name</span>.bak</span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&quot;/.*dhcp.*/d&quot;</span> /etc/sysconfig/network-scripts/<span class="variable">$cfg_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;IPADDR=<span class="variable">$newip</span>&quot;</span>             &gt;&gt; /etc/sysconfig/network-scripts/<span class="variable">$cfg_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;NETMASK=<span class="variable">$mask</span>&quot;</span>             &gt;&gt; /etc/sysconfig/network-scripts/<span class="variable">$cfg_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GATEWAY=<span class="variable">$gateway</span>&quot;</span>          &gt;&gt; /etc/sysconfig/network-scripts/<span class="variable">$cfg_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;DNS1=114.114.114.114&quot;</span>      &gt;&gt; /etc/sysconfig/network-scripts/<span class="variable">$cfg_name</span></span><br><span class="line"></span><br><span class="line">ifdown <span class="variable">$cfg_name</span> &amp;&amp; ifup <span class="variable">$cfg_name</span></span><br><span class="line">sleep 5</span><br><span class="line">ping -c 4 www.baidu.com</span><br><span class="line"><span class="keyword">if</span> [ $? != 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">     <span class="built_in">echo</span> -e <span class="string">&quot;Error! Cant link to Internet&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;current ip is <span class="variable">$newip</span>&quot;</span></span><br></pre></td></tr></table></figure><p>这里仍然是直接设置成200，实际使用的时候可以根据情况编辑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus自定义枚举</title>
      <link href="2020/02/18/mybatis%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE/"/>
      <url>2020/02/18/mybatis%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h1><p>枚举值在db中存储一般是整形或者字符串，在代码里一般是枚举。我们的需求是在model里使用一种自定义类型，能够：</p><ol><li>校验用户提供的数据在枚举允许范围内，否则自动报错；</li><li>在输出给用户时，json序列化自动加上枚举的中文含义；</li><li>自动通过json反序列化到该类型；</li><li>存入db时自动转化为对应的整形和字符串；</li><li>从db中取出数据时自动转为该自定义类型；</li></ol><p>其中1通过自定义validator实现，2/3通过自定义序列化/反序列化实现，4/5通过自定义typeHandler实现。</p><h1 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h1><p>枚举值有两种实现方式：写死在代码里，或者使用数据字典存储在db/redis里。下面只介绍数据字典存储在db里的方案，其他几种情况处理手段类似。假设数据字典<code>sys_dict</code>包括以下几列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feat_code   <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>   <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;英文代码&#x27;</span>,</span><br><span class="line">value_str   <span class="type">varchar</span>(<span class="number">32</span>)  <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>   <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;枚举值&#x27;</span>,</span><br><span class="line">value_cn    <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>   <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;枚举值（中文）&#x27;</span>,</span><br></pre></td></tr></table></figure><p>并且使用以下服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysDictService</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">SysDictMapper</span>, <span class="title">SysDict</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Cacheable(cacheNames = Constants.AUTO_CACHE_PREFIX)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getCodeEnums</span><span class="params">(<span class="meta">@NotNull</span> String code)</span> </span>&#123;</span><br><span class="line">        Wrapper&lt;SysDict&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;SysDict&gt;()</span><br><span class="line">                .eq(SysDict.COL_FEAT_CODE, code);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list(wrapper).stream().collect(</span><br><span class="line">                Collectors.toMap(</span><br><span class="line">                        SysDict::getValueStr,</span><br><span class="line">                        SysDict::getValueCN</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidValue</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        Wrapper&lt;SysDict&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;SysDict&gt;()</span><br><span class="line">                .eq(SysDict.COL_FEAT_CODE, key)</span><br><span class="line">                .eq(SysDict.COL_VALUE_STR, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getOne(wrapper) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义自定义类型"><a href="#定义自定义类型" class="headerlink" title="定义自定义类型"></a>定义自定义类型</h1><h2 id="使用内置枚举类型"><a href="#使用内置枚举类型" class="headerlink" title="使用内置枚举类型"></a>使用内置枚举类型</h2><p>mybatis-plus其实内置了这部分支持，不过他是直接将枚举值替换成对应的中文。我们在此基础上进行扩展：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDictEnum</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">IEnum</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库中存储的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库保存的字典ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getDictCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，自定义枚举类型实现上述接口。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CorpKindEnum</span> <span class="keyword">implements</span> <span class="title">IDictEnum</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    CORPORATION(<span class="number">0</span>), GOVERNMENT(<span class="number">1</span>), COMMON(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer v;</span><br><span class="line"></span><br><span class="line">    CorpKindEnum(Integer v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDictCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CORP_KIND_CODE&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个整形枚举，我们使用<code>CORP_KIND_CODE</code>作为<code>feat_code</code>，在数据字典里插入对应的值和中文释疑。自定义Json序列化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DictEnumSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">IDictEnum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SysDictService service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JsonSerializer初始化比bean更早，所以不能直接字段注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DictEnumSerializer</span><span class="params">(SysDictService service)</span> </span>&#123;</span><br><span class="line">        DictEnumSerializer.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DictEnumSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(IDictEnum value,</span></span></span><br><span class="line"><span class="function"><span class="params">                          JsonGenerator generator, SerializerProvider provider)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            generator.writeNull();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        generator.writeObject(value.getValue());</span><br><span class="line">        generator.writeFieldName(generator.getOutputContext().getCurrentName() + <span class="string">&quot;CN&quot;</span>);</span><br><span class="line">        generator.writeString(getEnumDesc(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">handledType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IDictEnum.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getEnumDesc</span><span class="params">(IDictEnum dictEnum)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = service.getCodeEnums(dictEnum.getDictCode());</span><br><span class="line">        <span class="keyword">return</span> map.get(dictEnum.getValue().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在序列化的时候将字段名后面加上<code>CN</code>，同时通过数据字典查询对应的中文含义注入。</p><p>由于我们这里扩展了mybatis-plus的内置类型，使用时就不需要加上typeHandler的注解了。</p><p><strong>问题</strong>：<br>jackson在通过整数反序列化到枚举时，无法通过指定的值来反序列化，而是通过整数的顺序(ordinal)来进行的。如果枚举类型不是从0-N这种赋值，则反序列化结果不正确。这是一个存在历史很悠久的<a href="https://github.com/FasterXML/jackson-databind/issues/1850">bug</a>。</p><p>解决方案是在枚举里自定义<code>JsonCreator</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonCreator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CorpKindEnum <span class="title">fromValue</span><span class="params">(Integer v)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (CorpKindEnum element : values()) &#123;</span><br><span class="line">       <span class="keyword">if</span> (element.getValue().equals(v)) &#123;</span><br><span class="line">          <span class="keyword">return</span> element;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//or throw exception if you like...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Java语言的限制，我们无法扩展内置的<code>enum</code>类型，所以每个自定义枚举上都要自己加上<code>JsonCreator</code>。一个简单的解决方案是全部使用字符串枚举，当然这会比使用integer更慢，也比tinyint/smallint更占数据库空间。</p><h2 id="使用自定义类"><a href="#使用自定义类" class="headerlink" title="使用自定义类"></a>使用自定义类</h2><p>上述方案可以解决大部分枚举的问题。但是有些情况下，枚举值特别多，我们又不想在代码里全部列出来，这时候使用内置枚举类型就不太合适了。我们自定义一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDictValue</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">IDictEnum</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDictValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际上和刚才的接口是一致的，不再赘述。然后我们实现自定义的typeHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DictValueHandler</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">BaseDictValue</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;E&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DictValueHandler</span><span class="params">(Class&lt;E&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Type argument cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, E e, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ps.setObject(i, e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">convertResult</span><span class="params">(Object vs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vs <span class="keyword">instanceof</span> Number) &#123; <span class="comment">//这里假设枚举只有整数和字符串两种类型，理论上够用了</span></span><br><span class="line">                <span class="keyword">return</span> type.getConstructor(Integer.class).newInstance(vs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> type.getConstructor(String.class).newInstance(vs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;fail to construct dict value&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getNullableResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> convertResult(resultSet.getObject(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getNullableResult</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> convertResult(resultSet.getObject(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getNullableResult</span><span class="params">(CallableStatement callableStatement, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> convertResult(callableStatement.getObject(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后自定义序列化仍然复用刚才的即可（因为该抽象类实现了对应的接口）。</p><p>最后将刚才的枚举类改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@ToString(callSuper=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorpKindEnum</span> <span class="keyword">extends</span> <span class="title">BaseDictValue</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer CORPORATION = <span class="number">0</span>; <span class="comment">//只需要用来解析的一些枚举，不必全部列出所有枚举值了…</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonCreator</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CorpKindEnum</span><span class="params">(Integer v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDictCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CORP_KIND_CODE&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里必须要实现一个单参数构造函数，用来转换对应的基础类型，并将其标注为<code>@JsonCreator</code>用来反序列化。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>如果要使用mybatis-plus自带的函数进行增删改查，需要在model的<code>@TableName</code>里标注<code>autoResultMap = true</code>；并在对应的字段的<code>@TableField</code>里标注<code>typeHandler = DictValueHandler.class</code>，这样才能正确的进行orm类型转换；</li><li>同样，如果自己写resultMap想要进行类型转换，也要在xml里指定上述<code>typeHandler</code>。</li></ol><h2 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h2><p>这个简单，写一个自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = DictFieldValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DictField &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;参数错误，枚举值不在允许范围内&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现校验逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DictFieldValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">DictField</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysDictService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Object o, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> IDictEnum) &#123;</span><br><span class="line">            IDictEnum v = (IDictEnum) o;</span><br><span class="line">            <span class="keyword">return</span> service.isValidValue(v.getDictCode(), v.getValue().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用的时候，在对应的字段上加上<code>@DictField</code>注解，对应的类参数前面加上<code>@Valid</code>或者<code>@Validated</code>就可以了.</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ol><li>mybatis-plus自带了一个<code>JacksonTypeHandler</code>，可以将数据库字段转换成任意类型，它的原理和上面是一致的。</li><li>上述Jackson的<code>Serializer</code>需要通过<code>SimpleModule</code>手动注册上去。在springboot中可以通过<code>bean</code>进行配置。这里给一个参考配置：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">objectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="comment">// 对于空的对象转json的时候不抛出错误</span></span><br><span class="line">    objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class="line">    <span class="comment">// 禁用遇到未知属性抛出异常</span></span><br><span class="line">    objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line">    <span class="comment">// 序列化BigDecimal时不使用科学计数法输出</span></span><br><span class="line">    objectMapper.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//自定义枚举序列化</span></span><br><span class="line">    DictEnumSerializer dictEnumSerializer = <span class="keyword">new</span> DictEnumSerializer();</span><br><span class="line">    SimpleModule simpleModule = <span class="keyword">new</span> SimpleModule();</span><br><span class="line">    simpleModule.addSerializer(dictEnumSerializer);</span><br><span class="line">    <span class="comment">// 日期和时间格式化</span></span><br><span class="line">    JavaTimeModule javaTimeModule = <span class="keyword">new</span> JavaTimeModule();</span><br><span class="line">    javaTimeModule.addSerializer(LocalDateTime.class, <span class="keyword">new</span> LocalDateTimeSerializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">    javaTimeModule.addSerializer(LocalDate.class, <span class="keyword">new</span> LocalDateSerializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)));</span><br><span class="line">    javaTimeModule.addSerializer(LocalTime.class, <span class="keyword">new</span> LocalTimeSerializer(DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>)));</span><br><span class="line">    javaTimeModule.addDeserializer(LocalDateTime.class, <span class="keyword">new</span> LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">    javaTimeModule.addDeserializer(LocalDate.class, <span class="keyword">new</span> LocalDateDeserializer(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>)));</span><br><span class="line">    javaTimeModule.addDeserializer(LocalTime.class, <span class="keyword">new</span> LocalTimeDeserializer(DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>)));</span><br><span class="line">    javaTimeModule.addSerializer(Date.class, <span class="keyword">new</span> DateSerializer(<span class="keyword">false</span>, <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">    objectMapper.registerModule(javaTimeModule);</span><br><span class="line">    objectMapper.registerModule(simpleModule);</span><br><span class="line">    <span class="keyword">return</span> objectMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mybatis </tag>
            
            <tag> json </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gb28181实现调研</title>
      <link href="2019/12/23/gb28181%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%A0%94/"/>
      <url>2019/12/23/gb28181%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<p>由于工地接入的摄像头五花八门，依靠厂家提供的平台不足以满足需求。公司需要直连摄像头和NVR进行视频取流等工作，我现在进行技术调研。</p><p>首先直接搜gb28181的话，可以看到github上有一个c#的平台，用的<code>.net core</code>实现。然后仔细看相关文档，你会发现这玩意用了sip协议，后者开源的框架就相当多了，不过大部分是c/c++的，纯c的比较多。java的实现也有比较完整的版本，但是很久没更新了。go的话，目前还没有比较稳定的开源实现，有一些不太完整的版本。</p><p>视频流这块，用了RTP/RTCP协议，发送的是PS流，发送给客户端的话，需要转换成可以拿来直播的其他流。</p><p>换句话说，我们需要实现<strong>一个sip网关</strong>用来进行控制，和<strong>一个媒体流网关</strong>用来传输实时媒体数据。</p><p>如果想要做嵌入式网关的话，推荐用纯C版本的库(pjsip实现了sip/RTP/RTCP/RTSP等所有的功能，live555/ffmpeg和gstreamer都是C实现)，自己写上层C++代码实现。</p><p>考虑开发速度可以用高等语言来写其中的一部分，那个开源的<code>.net core</code>就是用C#写的（但是没有流媒体相关的实现）。为了熟悉协议，也可以自己先造个轮子（工作量很大）。</p><p>值得注意的是标准的SDP协议部分使用了扩展字段y，一般开源代码并不支持，需要拿到源码<a href="https://blog.csdn.net/comhaqs/article/details/101760176">!进行修改</a>。</p><h2 id="协议解析"><a href="#协议解析" class="headerlink" title="协议解析"></a>协议解析</h2><p>github上那个c#的repo里面有协议的pdf文件，可以先下载下来。以下部分内容直接引用自协议文本。</p><pre><code>安全注册、实时视音频点播、历史视音频的回放等应用的会话控制采用IETFRFC3261规定的 Register、Invite 等请求和响应方法实现,历史视音频回放控制采用SIP扩展协议IETFRFC2976规定的INFO方法实现,前端设备控制、信息查询、报警事件通知和分发等应用的会话控制采用SIP扩展协议IETFRFC3428规定的Mesage方法实现。</code></pre><p>这里提到的几个方法，都是SIP协议规定的内容。SIP基于TCP/UDP，在应用层是纯文本协议，类似HTTP，也可以使用证书进行加密。</p><p>类似HTTP，sip有标准的header和body。一个标准的SIP Message请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">To:sip:目的设备编码@目的域名</span><br><span class="line">CSeq:1 Message</span><br><span class="line">Cal-ID:a84b4c76e66710</span><br><span class="line">Via:SIP&#x2F;2.0&#x2F;UDP源域名或IP地址</span><br><span class="line">From:&lt;sip:源设备编码@源域名&gt;;tag&#x3D;237f57dc</span><br><span class="line">Content-Type:Application&#x2F;MANSCDP+xml</span><br><span class="line">Max-Forwards:69</span><br><span class="line">Content-Length:消息实体的字节长度</span><br><span class="line"></span><br><span class="line">&lt;?xmlversion&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;Control&gt;</span><br><span class="line">&lt;CmdType&gt;DeviceControl&lt;&#x2F;CmdType&gt;</span><br><span class="line">&lt;SN&gt;11&lt;&#x2F;SN&gt;</span><br><span class="line">&lt;DeviceID&gt;64010000041310000345&lt;&#x2F;DeviceID&gt;</span><br><span class="line">&lt;PTZCmd&gt;A50F4D1000001021&lt;&#x2F;PTZCmd&gt;</span><br><span class="line">&lt;Info&gt;</span><br><span class="line">&lt;ControlPriority&gt;5&lt;&#x2F;ControlPriority&gt;</span><br><span class="line">&lt;&#x2F;Info&gt;</span><br><span class="line">&lt;&#x2F;Control&gt;</span><br></pre></td></tr></table></figure><p>注意sip是长链接协议，所以规定了标准的register流程。</p><p>经过实际调研，最终决定暂时搁置这块的开发，其实SIP服务器实现起来不难，关键是流媒体转码相关的技术水比较深。目前公司还有其他优先级更高的事情，本文等待后续更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> camera </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用多租户自定义角色权限模型</title>
      <link href="2019/12/23/%E9%80%9A%E7%94%A8%E5%A4%9A%E7%A7%9F%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8B/"/>
      <url>2019/12/23/%E9%80%9A%E7%94%A8%E5%A4%9A%E7%A7%9F%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>前段时间在忙一个saas系统的设计，这里总结一下经验。</p><p>首先是用户付费方式一般以模块的形式进行，如果saas系统各租户的需求在细节上有很多不同，那就要对模块进行一些微调，在代码上使用策略模式进行归类区分抽象。但是总的来说，系统大的功能点应该相差不大，否则就属于定制化开发的范畴了。</p><p>权限系统可以抽象为以下部分：</p><ol><li>功能点。功能点是一个全集，与后台的API对应。不同用户能够看到的功能点是不一样的，这取决于购买的需求；</li><li>UI。功能点对应的UI可以由很多套，不同平台的客户端，不同版本的移动端，都可能有不同的UI；功能点分别关联到UI和API；</li><li>角色。各租户除了内置的管理员，其他角色可以由用户自己定义；<strong>注意</strong>：并不是所有的saas系统都有这种需求，统一设计角色的话，系统设计会精简很多；</li><li>权限。角色在定义的时候关联了功能点的权限。</li></ol><p>详细解释如下——</p><h2 id="功能点"><a href="#功能点" class="headerlink" title="功能点"></a>功能点</h2><p>系统按着模块拆分功能点，功能点是最细的权限粒度。保证UI和API相对功能点都是一对多的关系，不存在多对多的关系。</p><p>如果感觉用户操作功能点分配权限过于繁琐，可以对功能点做一个功能集，这样分配的粒度就会比较粗，但是也可以随时细化。</p><p>功能点都有一个对应的权限描述方式，可以采用二进制位运算表示，也可以用权限字符串（参考shiro）。如果权限的判定需要根据用户请求的参数来决定，那就要动态的权限字符串（参考spel）。我这里用了spel的方式来描述权限，可以用Spring security来实现，或者自己用Spring AOP写一个权限描述。最后的形式类似于<code>#prj:device:view</code>，表示某个project的设备查看。</p><p>每个API都有自己的权限需求，这与功能点的权限描述字符串对应。这里也是一对多的关系，API可以要求多个权限。用户必须拥有全部权限才能访问API。</p><p>功能点理论上也是树型的，不过某些功能点可能对其他功能点有额外的依赖。</p><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>UI分为两部分，一个是匹配规则，一个是UI树本身。</p><p>这个比较简单，就是为不同版本、产品，甚至租户设置不同的UI，根据客户端的情况和用户的功能点权限返回UI树给用户渲染。</p><p>UI树不一定需要在服务器存一套完整的，需要权限控制的部分才需要存入数据库。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>简单起见，只有租户的管理员才可以给组织建立对应的角色树。</p><p>角色树关联功能点，某些功能点可能和具体的数据有关，需要额外选择。</p><h2 id="数据权限"><a href="#数据权限" class="headerlink" title="数据权限"></a>数据权限</h2><p>指的是不同人看到的字段都不一样，或者字段的渲染不一样。</p><p>这个比较麻烦，不太好做成通用的。非要做的话，每个API返回的字段都要存到表里，然后在功能点那一层，最后关联到字段。即<code>#prj:device:view:field</code>，但是这样太过繁琐，对执行效率影响很大。如果没有很通用的需求，可以在代码里对一些特殊API做单独的处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sass项目顶层设计</title>
      <link href="2019/11/19/sass%E9%A1%B9%E7%9B%AE%E9%A1%B6%E5%B1%82%E8%AE%BE%E8%AE%A1/"/>
      <url>2019/11/19/sass%E9%A1%B9%E7%9B%AE%E9%A1%B6%E5%B1%82%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>sass本质上是想做一个标准化的平台，供使用者接入。但是由于接入者是付费方，或者说甲方，对于平台使用中总会有各种各样的诉求，这就导致平台在开发过程中总是会收到各种各样的定制化需求。如何处理标准化与定制化之间的取舍成为每个saas平台都要面临的问题。</p><p>几个需要讨论的问题：</p><ol><li>所在行业是否能够做成saas，这是立项之基。很多事情表面上看可以抽象成同一种模式，实际实行起来千差万别，这就导致很难对行业进行标准化的过程抽象。做起来会淹没在无尽的需求细节之中；</li><li>平台的服务边界在哪里。既然要做标准化，那就要知道哪些是平台应该提供的，哪些集成第三方的；</li><li>如何架构系统。saas要满足多租户需求，即一套平台，N种接入。后端服务拆分/微服务化，前端组件化是一种必须；理想情况下，可以做到前端一套代码，根据后端配置动态渲染客户所需的页面；后端接入新客户时，只需要运营在中台进行适当的配置，无需编码即可提供标准化的服务；</li><li>如何应对定制化需求。saas就是上面千条线，下面一根针。客户提出的需求有些是通用的，可以加入标准化组件。有些则是很特殊的，可能需要进行回绝，或者评估工作量进行商务上的会谈；</li><li>如何对现有系统进行改造。平台建设早期被项目推着走，积累了一些经验，但是也产生了一些技术债务。在公司正常运营的情况下，如何将已有项目平缓过渡到重构后的平台服务中去，也是需要商讨的话题之一；</li></ol><h2 id="架构细节"><a href="#架构细节" class="headerlink" title="架构细节"></a>架构细节</h2><p>待议话题：</p><ol><li>目前已有系统如何抽象、拆分服务；</li><li>前端展示层如何设计；</li><li>重构后要保证平台满足当前所有已接入所有业务；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> sass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当代编程语言简评</title>
      <link href="2019/11/09/%E5%BD%93%E4%BB%A3%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AE%80%E8%AF%84/"/>
      <url>2019/11/09/%E5%BD%93%E4%BB%A3%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%AE%80%E8%AF%84/</url>
      
        <content type="html"><![CDATA[<p>著名大喷子王垠最喜欢点评各种语言的优缺点（当然基本上都是缺点居多），作为技术人也写一篇东西表达一下自己的看法。</p><h3 id="原初"><a href="#原初" class="headerlink" title="原初"></a>原初</h3><p>C和Lisp是流行至今的最古老的两门编程语言，从一开始就走向了不同的道路。</p><p>C：高效、简洁，直接操控内存和cpu，面向机器<br>Lisp：抽象，强大，但是效率不高，gc语言，面向业务</p><p>从这时候开始，语言演化就是在这两门语言的基础上取长补短</p><h3 id="C-gt-ObjectC-C-gt-Rust"><a href="#C-gt-ObjectC-C-gt-Rust" class="headerlink" title="C -&gt; ObjectC/C++ -&gt; Rust"></a>C -&gt; ObjectC/C++ -&gt; Rust</h3><p>C++完全兼容C90，这是它成功的原因，也是它失败的原因。</p><p>C++最开始就是C with class，随着OO的流行，C语言抽象能力不足的问题越来越明显。于是C++之父往里面塞入了类，以及随之而来的各种概念。后来，又加了模版，于是才有了STL。</p><p>C++非常复杂，包含了各种流行的编程范式。抽象能力得到了巨大的补充，但是并没有引入GC，仍然坚持zero-cost abstraction。虽然后来在C++11中引入了智能指针，但是已经有一些积重难返的感觉了。</p><p>OC也是C的超集，设计的更加不爽了，苹果自己也想要用Swift替代之。</p><p>Rust也坚持零成本抽象，但是它另辟蹊径，从语言和编译器层面上试图解决内存问题，引入了生命周期、各类指针等各种复杂的设计。Rust有现代语言完善的包管理系统，这是比C++好的地方，但是它试图解决问题的手段有些奇怪，有时候有一些因噎废食的感觉。这也是我不太看好Rust流行的原因。真正的高手，用Modern C++就够了。</p><h3 id="Smalltalk-gt-C-Java-gt-Scala-gt-Kotlin"><a href="#Smalltalk-gt-C-Java-gt-Scala-gt-Kotlin" class="headerlink" title="Smalltalk -&gt; C#/Java -&gt; Scala -&gt; Kotlin"></a>Smalltalk -&gt; C#/Java -&gt; Scala -&gt; Kotlin</h3><p>和C同时期的OO语言，最出名的是Smalltalk（lisp并不是OO语言，它可以抽象出一切，Smalltalk的诞生也是受了lisp的影响）。Java的创造者受够了C++的复杂，决定另起炉灶融合Smalltalk和C++的长处，做出一门新语言。</p><p>Java是工业界长时间以来最流行的语言，虽然C#改进了Java，并引入了linq等方便至极的语法，但是.net core开源的太迟了。</p><p>Java太OO了，这是它成功的地方，也是它失败的地方。Java的流行导致所谓设计模式的泛滥，Java的抽象能力过于局限于OO，导致很多本来很简单的东西写起来复杂无比，Spring这类框架的流行本质上就是在弥补Java语言的缺陷。</p><p>Java7以前的Java足够简单，这为业界量产初级程序员打下了良好的基础。</p><p>Scala是一门学术语言，类似C++，它过于复杂，所以不可能得到流行。Kotlin就好得多，它语言特性优越，并且积极演变。唯一的问题是，它必须运行在jvm上，那到头来你还是承受Java的历史遗留问题。</p><h3 id="Python-Perl-Ruby-Javascript"><a href="#Python-Perl-Ruby-Javascript" class="headerlink" title="Python/Perl/Ruby/Javascript"></a>Python/Perl/Ruby/Javascript</h3><p>虽然动态语言当初走的是完全不同的道路，到最后也慢慢引入类型化，比如Python3也开始支持类型注解，毕竟编译器还是能帮上很多忙的。</p><p>动态语言在开发速度上无与伦比，所以更适合用来搭原型，写脚本。对于I/O密集型工程，也可以选择他们快速开发。</p><p>JS的流行是一个历史上的错误，别的没啥好说的了…</p><h3 id="Erlang-Go-Swift"><a href="#Erlang-Go-Swift" class="headerlink" title="Erlang/Go/Swift"></a>Erlang/Go/Swift</h3><p>Erlang是一门分布式设计语言，它纯粹为了解决工程问题而生，它正确而强大。但是，它的生态不够开放，语法也略显怪异，效率上也不是很尽如人意，所以最终未能大规模流行。</p><p>Go在分布式上做的没有Erlang那么激进，netchan这玩意儿最终还是没有内置到语言里。不过Go的优势是足够快，足够简单。</p><p>Swift目前还是主要用作客户端开发，但是已经开源。啥时候引入async/await以后，也可以用来做服务端开发，可惜没有生态。</p><h3 id="Haskell-OCaml-F"><a href="#Haskell-OCaml-F" class="headerlink" title="Haskell/OCaml/F#"></a>Haskell/OCaml/F#</h3><p>函数式编程语言过于学院派，有一种学之则生，用之则死的感觉，如同Lisp一般。</p><p>不过，他们有一种数学美。</p><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>PHP没啥好说的，在HTML里面写代码决定了这玩意儿的用处太受限了。如果不是Facebook抱残守缺，早就应该被淘汰了。</p><h3 id="最好的语言"><a href="#最好的语言" class="headerlink" title="最好的语言"></a>最好的语言</h3><p>后端来说，目前就是Java，但是Go2有希望超越。</p><p>顺便说一句，我可不喜欢Java了，我宁愿选Go1。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>历史并不能给人们以教训，人们总是犯同样的错误。</p><p>C++引入模版，Java和.NET都是半路引入泛型，Go却还要重滔覆辙。C++开始就用异常代替了错误码，Go非要到Go2再还这些技术债，这是何苦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程模型浅谈</title>
      <link href="2019/11/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%B5%85%E8%B0%88/"/>
      <url>2019/11/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%B5%85%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>当我们设计一个业务模型的代码架构时，不同语言的选择对我们的思维有很大的影响。本文根据个人经验，以设计斗地主服务器为例，试图总结一下其中的区别。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主流设计语言中，C/C++甚至没有线程的概念，全靠调用操作系统自己的接口；Python由于GIL的原因，多线程效率十分底下，一般采用多进程模型；Java是最早采用多线程模型的语言；Erlang是内置Actor模型；Golang是内置CSP模型。值得注意的是，对操作系统而言，最底层的就是线程（不过Windows有内置的Fiber），所以协程（coroutine）在任何语言中其实都可以自己实现，多个协程共同运行在同一个线程中。</p><h2 id="多进程设计"><a href="#多进程设计" class="headerlink" title="多进程设计"></a>多进程设计</h2><p>如果选用Python作为目标任务的编程语言，显然应该采用多进程模型，在进程内部可以使用协程来加快速度。比如我们用Tornado来完成这个游戏：</p><ol><li>首先可以设计一个路由服务（HTTP服务），完成用户身份校验后，根据负载均衡算法随机分配一个实例，将websocket监听地址返回给客户端。并将这个分配地址记录下来，供用户断线重连使用；</li><li>Tornado是单进程单线程模型，这里主要完成游戏逻辑。一个新用户加入后，游戏服在内存中遍历有空闲的房间，将用户加入其中。每个房间有自己的id，游戏逻辑本身靠用户动作来驱动，即通过用户动作来修改房间上下文，直到游戏结束；同时游戏可以使用ioloop的定时器来定义超时，代替用户驱动游戏；</li><li>到游戏结算时，需要入库，可以通过线程池的方法避免阻塞，或者用async-http在路由层完成入库操作。</li></ol><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>上述过程中，可以把路由和Tornado设计到一起，使用类似prefork的方案，在路由进程中启动tornado的进程池，这种情况下可以使用python内置的多进程通信组件（multiprocessing包里面的）。不过这个设计显然不是很好，不符合现在微服务的设计理念。</p><p>将路由和Tornado作为独立的服务，二者之间的进程通信可以用socket（有应答），或者mq等中间件（无应答），同时也将监听的handler加入ioloop的主循环中。</p><p>注意独立进程之间可能存在数据不一致问题，单节点挂掉的话需要考虑如何处理。</p><h2 id="多线程设计"><a href="#多线程设计" class="headerlink" title="多线程设计"></a>多线程设计</h2><p>以Java的Netty为例。其实和多进程差不多，不过这时候路由和游戏本身肯定是在一个进程里作为一个整体的服务了，那么假设这里通过dns进行负载均衡，用户随机连接到一台服务器上。可以通过redis的setnx这种类分布式锁的机制保证用户断线重连到同一台机器。</p><ol><li>一个单独的线程作为路由服务，将用户分配到不同房间；</li><li>建立房间游戏逻辑线程池。这个线程池可以用netty的，也可以用jdk的。不过棋牌类游戏需要使用大量定时器，所以一般还是用netty的。netty的I/O线程和业务线程在这里是分开的，避免相互阻塞；</li><li>只要保证同一个房间的游戏逻辑总是被同一个线程处理，即可达到无锁编程的目的；</li></ol><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>线程间通信的可靠性显然比进程间强了许多，基本无需考虑数据不一致问题。</p><p>一般使用语言自带的组件来完成线程间通信，比如Future/Promise（有应答），或者直接submit到对应的线程（无应答）。耗时任务一般采用线程池的方法来避免阻塞。</p><h2 id="协程设计"><a href="#协程设计" class="headerlink" title="协程设计"></a>协程设计</h2><p>以Go为例。这里就简单多了：</p><ol><li>一个单独的协程完成路由服务；</li><li>每个房间一个单独的协程完成无锁游戏逻辑计算；</li><li>耗时任务单开协程处理，随用随销毁；</li><li>协程间通过channel通信；</li></ol><h2 id="联系与区别"><a href="#联系与区别" class="headerlink" title="联系与区别"></a>联系与区别</h2><p>按着上面这些分析，其实他们的设计思路大体上是一样的。通过IO多路复用，使用尽量少的系统资源完成更多的任务，通过使同一个房间在同一个线程/协程里，尽量达到无锁编程的目的。</p><p>但是由于操作系统的一个基本运行单位是进程，多进程设计其实就是分布式设计。因此多进程需要更多考虑的到数据一致性的问题，进程间通信的代价昂贵。多线程编程和协程其实差不多，但是协程的代价更低，因此可以每个房间一个协程但不能每个房间一个线程。同样，某些耗时的任务协程可以随时开一个新的，用完再销毁。但是线程不行，这么操作的代价有点大，一般需要做一个池化处理。换句话来说，线程编程要更有总体规划一些，要更加精细的设计，因为一个进程最多有几千个线程，但是却可以有上百万个协程。所以Java这边还是建议把耗时操作封装成类，内部使用池化，同时类对外提供阻塞应答和异步调用等常用通信方式。</p><p>同时需要注意的是，IO操作还要关心外部资源的限制。比如MySQL读写，并发量不大的时候，可以随时开一个线程去读。但是并发量有限的情况下，就要池化以限制资源（在Go里面可以通过Channel扇入扇出来限制）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实道理是相通的，上面的思路其实也大同小异，但是具体到代码的书写难度上，肯定是依次递减的。协程编程的时代早已到来，这也是为啥Go能这么快速流行的一个原因。但是go的channel并不能跨进程通信，所以实际上来说，Erlang这门古早的语言，才是集群设计最终的答案。</p><p>注意不管是哪种方案，都有data race的情况，这取决于你对业务的设计和架构。并发编程虽然比以前简单了很多，但是没想清楚的时候，还是很容易出问题的（而且很难调试）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> go </tag>
            
            <tag> concurrent </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leaf框架代码解析和改造</title>
      <link href="2019/10/31/leaf%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0/"/>
      <url>2019/10/31/leaf%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%E5%92%8C%E6%94%B9%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<p>在接游戏外包的一段时间里，选型了golang的leaf框架作为游戏开发的基础框架，但是进行了一系列改造以更好的完成业务需求。简单记录如下：</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>leaf本质上其实不是一个游戏框架，而是一个网络工程的脚手架，换句话来说你可以用它来写任何服务端而不仅仅是游戏。</p><p>它的基本思路是将每个socket封装成一个agent，使用独立的协程进行读写。主要分为几个模块：</p><ol><li>提供<code>Skeleton</code>这个脚手架，可以把它当成一个功能更加完善的协程。它提供了保证函数执行时序的一些工具，允许callback形式的代码；通过<code>chanRPCServer</code>抽象了一种类似RPC的协程间通信（通过channel），方便快速进行开发；</li><li>按业务抽象了Module，进行生命周期管理；</li><li>抽象了网络接口，并提供了裸TCP和websocket的实现，可以通过简单的配置同时支持多种协议；</li><li>提供了protobuf和json的序列化支持；</li><li>路由机制；</li><li>通过telnet提供pprof接口，同时也可以自定义命令，方便进行debug；</li><li>其他一些工具库；</li></ol><h2 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h2><p>下面按着模块进行一些代码难点解析。</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>这个比较简单，规定了一个接口，里面是一些生命周期的回调函数，供leaf启动时注册运行，同时提供了一个<code>chan bool</code>作为关闭的信号。</p><p>注意每个模块运行在单独的协程里。</p><h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><p>序列化接口，支持序列化、反序列化和路由消息到对应的handler。框架给出了json和protobuf两种序列化方案。</p><p>json是明文传输，直接用类的名字作为消息的标示即可。protobuf是二进制传输，需要两个字节来描述消息的id，直到id才能正确的反序列化。</p><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>对TCP和WebSocket通信的抽象，<code>Conn</code>是抽象出的接口。</p><p>TCP和WebSocket最大的不同是前者是传输层协议，后者是应用层协议。所以前者需要自定义消息格式，这里采用的是头X个字节描述消息大小，后面是序列化消息的方式，另外注意这里还有大小端的问题。读的过程很简单，每次都是先读前X个字节，然后读出整个消息体；写的过程也类似。</p><h3 id="Gate"><a href="#Gate" class="headerlink" title="Gate"></a>Gate</h3><p>路由主要作用是将socket封装成Agent，这里为了可以同时当作TCP和WebSocket服务器，将相关设置项直接当作Gate的成员变量了。</p><p>消息的路由通过注册processor来实现，通过<code>Run</code>来启动server，显然gate应该被封装作为一个Module在leaf中运行。这里还注册了打开关闭socket的固定回调(“NewAgent”和”CloseAgent”)。</p><p>下面看一下Server启动后做了啥，以TCPServer为例：</p><ol><li>在一个单独的协程中启动server，server本身是一个死循环；</li><li>Accept请求以后，通过server的<code>NewAgent</code>回调创造agent，并在一个单独的协程中运行agent；</li><li>agent的<code>Run</code>也是一个死循环，它简单的读取消息并进行路由处理；</li><li>agent的写消息是在调用协程里异步完成的，它将消息写入conn的<code>writeChan</code>缓冲区后返回；每个conn有个单独的协程遍历channel并完成真正的写操作；</li><li>因此3，4为一个socket的读写各创建了一个单独的协程；</li></ol><p>3中路由处理，在这里分为几种情况，如果对Processor调用了<code>SetHandler</code>或者<code>SetRawHandler</code>，那么就在读消息的协程里直接同步处理了消息。如果调用了<code>SetRouter</code>选择把消息路由到某个chanrpc中，则会把消息塞到队列中进行异步处理（回调的格式写死为f(args []interface{})。</p><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>一个方便调试的工具。</p><p>用户可以通过telnet访问内存情况，通过自定义command指令获取内存中的数据并进行调试。</p><h3 id="chanrpc"><a href="#chanrpc" class="headerlink" title="chanrpc"></a>chanrpc</h3><p>该模块通过精巧的设计，为协程间通信增加了异步回调执行、同步调用、异步通知等常见模式。我们一般不直接使用它，而是通过Skeleton来使用。</p><h3 id="Skeleton"><a href="#Skeleton" class="headerlink" title="Skeleton"></a>Skeleton</h3><p>可以理解为一个胖协程，我们不再单独使用<code>go func()&#123;&#125;</code>运行协程，而是新建一个Skeleton，通过<code>go skeleton.Run()</code>来运行协程。</p><p>这样创建的协程，就可以通过内置的chanrpc来进行通信。此外，这里还对timer进行了封装，go默认的timer是在单独的协程里运行的，这里在时间到达后，将回调函数重新塞回调用chanTimer里，最终仍然在同一个协程里执行函数。同样，内置的<code>Go</code>也是通过类似的方法保证协程的同步。</p><p>所以Skeleton的<code>Run</code>函数就是一个select的死循环，使用io多路复用，依次中上述组件对应的channel中获取结果并执行对应的动作。</p><h2 id="简单改进"><a href="#简单改进" class="headerlink" title="简单改进"></a>简单改进</h2><p>由于leaf常年不再更新，fork了一个版本并修正了一些问题，地址在：<a href="https://github.com/YiuTerran/leaf">https://github.com/YiuTerran/leaf</a></p><p>主要修正包括：</p><ol><li>移除了一些不需要的模块，如mongo的支持等，这些直接用第三方库即可；</li><li>将自己实现的log模块改为zap的，性能更好并支持json格式的日志；</li><li>将websocket的RemoteAddr返回值改为透过代理的（如果存在）；</li><li>加上go mod支持，修改版本号为规范格式；</li><li>移除了conf文件夹，这个设计不太符合类库的使用规范；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> leaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务设计迷思-数据存储</title>
      <link href="2019/10/31/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E8%BF%B7%E6%80%9D-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
      <url>2019/10/31/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E8%BF%B7%E6%80%9D-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>后台数据的存储，其演变路线是非常明晰的。从全部用传统DBMS(oracle/mysql)到NoSQL配合db，直到现在的分布式数据库(NewSQL)。对应的，后台服务的主流架构也由单体式到SOA到微服务。当然，OLAP还引入了hbase，hive等大数据分析系统；然后各专业领域还有es或者neo4j之类的数据库，这里先不讨论这个。</p><p>这么多年，后端的设计其实没有大的改变，主要解决的就是流量问题：越来越庞大的访问量，和随之产生的数据量。银行证券等金融系统，最开始使用的是db2，sysbase等硬件数据库，然后是oracle这种较为成熟的单点数据库，这两年才逐渐拥抱开源，用pgsql代替oracle或是引入分布式数据库。访问量更为庞大、同时实时性也要求更高的互联网服务（很多金融系统的实时性其实很差，比如跨国swift汇款，可能要一个星期才到账。它涉及到风控等外部因素，实时性并不是第一位的。当然也有要求高的，比如股票购买。），则更为激进，在移动互联网时代就大规模引入redis、mongodb等NoSQL组件，以提高响应速度。</p><h2 id="单点时代"><a href="#单点时代" class="headerlink" title="单点时代"></a>单点时代</h2><p>即使C10K时代，单点数据库一般也足够满足需求。这时候最多考虑的是HA问题，mysql等常见db都提供了副本集的设计，也有比较成熟的集群架构（比如PXC架构）。这些技术在当今也很常见，中小规模的互联网公司仍在使用。oracle自带的分区功能也可以较少单表读写压力。</p><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>稍大规模的服务，也可以根据key值进行手动的分片。虽然麻烦了一些，但是仍然够用，事务的一致性可以通过db得到保证。但是如果引入了NoSQL，如redis，不同组件之间的数据一致性和事务性无法得到保证。</p><p>在代码里进行分库分表耦合太深，所以出现了mycat这一类透明代理，这样代码里仍然把数据库当作单点处理。代理反向解析sql语句，将请求送入正确的db，并进行数据汇总。当然OLAP用这个会有join问题，分页问题等。</p><p>mongodb虽然支持集群，但是不支持表之间的join操作，所以其实也算是一种分片。关于分片的设计，前面的博客有分析（数据密集型应用设计）。</p><h2 id="一库一服"><a href="#一库一服" class="headerlink" title="一库一服"></a>一库一服</h2><p>有人说微服务与SOA最大的区别就是一库一服，实际上这并没有解决任何问题，只是转移了问题，并且带来了新的问题。</p><p>将服务拆分成更小粒度的服务，每个服务使用单独的数据库。这些单独的数据库仍然可以使用分片进行水平扩展分解压力，显然这是一种<strong>分治</strong>的思想。但是分库破坏了db的acid特性，会导致数据失去强一致性。</p><p>以支付服务为例，在同一个db中，可以利用数据库的事务性保证付款和减少库存两个操作的一致性。如果通过微服务，支付服务和库存服务独立的情况下，只能拆分成支付服务扣钱-&gt;通知库存服务减少-&gt;库存减少成功/失败-&gt;回调支付服务确认，这就是所谓的TCC解决方案。</p><p>显然，某些业务（比如股票/火车票购买）是不能用这种模型的，扣钱成功必须保证买到商品，否则用户肯定会投诉的。所以这时候就只能用二阶段提交等一致性搞好的方案，但是效率又得不到保证。</p><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p>NewSQL的分布式数据库，从db层面上解决了数据扩展性的问题。说白了，它是将分布式事务的问题从服务层面重新转回db层面。于是一切又回到了单点时代，对于服务而言，分布式数据库就当作一个单点来使用即可。</p><p>当然分布式数据库至今仍然有一些问题，不过已经可以在生产上使用。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>从程序设计的角度来看，一切正在回到初始。</p><p>ServiceMesh和NewSQL，这两项技术将一切外部组件的复杂性进行了屏蔽，那么很多业务就重新回到CURD的简单工作了。</p><p>然而终究没有银弹，在很长一段时间内，上面的技术都会并存于世。合理的进行选型设计才是架构师应该考虑的问题。</p><p>多嘴说一句，Dubbo, SpringCloud这种架构注定会过时的，它将外部组件的复杂性引入了代码，这不符合低耦合高聚集的程序设计原则，注定会被ServiceMesh替代。</p>]]></content>
      
      
      
        <tags>
            
            <tag> db </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试刷题总结</title>
      <link href="2019/10/18/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>2019/10/18/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h1><h2 id="字符串-数组"><a href="#字符串-数组" class="headerlink" title="字符串/数组"></a>字符串/数组</h2><p>字符串是数组的一个特例，常用处理方案是一致的。思路包括：</p><ol><li>双指针（首尾）</li><li>回溯</li><li>贪心/dp</li><li>Trie树</li><li>二分搜索（各种变种）</li></ol><h3 id="特殊题型"><a href="#特殊题型" class="headerlink" title="特殊题型"></a>特殊题型</h3><ol><li>旋转数组：多次反转</li><li>判断是否存在，超大规模使用布隆过滤器（能精准判断不存在，但是不能精准判断存在）</li><li>矩阵相关：注意遍历的起始位置，根据矩阵的特点从右上角、左下角开始能迅速计算出目标</li></ol><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>在Java中通过PriorityQueue实现最大/最小堆（默认是最小）<br>python中通过heapq这个库来实现数组堆化，当然也可以用queue.PriorityQueue<br>堆可以用来解决<strong>topK问题</strong></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈通常用来解决优先级问题，一系列的操作中，有些优先级高，有些优先级低。可以将优先级低的先压栈，取出优先级高的进行处理。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列可以用来解决二叉树层次遍历问题。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>双指针（快慢）<ol><li>快慢指针能相遇则链表有环</li><li>相遇点和链表头各设一个指针，同时前进，交点即环的入口</li><li>两个链表的问题，可以根据长度差X设置两个指针，长链表指针先走X步</li></ol></li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>概念：<br>    1. 满二叉树：除了叶子节点，所有节点都有两个子节点的二叉树；层数为K，节点数为2^K - 1个<br>    2. 完全二叉树：最后一层节点从左到右连续，其他层节点达到最大值。满二叉树是完全二叉树的特殊情况<br>    3. 二叉搜索树(BST)：左子树的节点均小于根结点，右子树的节点均大于根结点，子节点也是二叉搜索树<br>       1. 中序遍历BST得到排序后的数组；<br>       2. 反向转换：取mid作为根，左边递归是左子树，右边递归是右子树<br>       3. 二叉搜索树的所有操作复杂度为O(h)，h为树的高度，当树高度不平衡时，退化为O(n)，即链表操作<br>    4. 平衡二叉树：左右子树高度差不超过1，且子节点都是平衡二叉树<br>    5. AVL：自平衡二叉搜索树<br>    6. 红黑树：也是自平衡二叉搜索树，理论性能优于AVL树 =&gt; 由于十分难写，很多实现采用skiplist代替<br>    7. 区间树/线段树：二叉搜索树的元素不再是元素，而是某个区间<br>    8. B树：自平衡多叉树，高度较低，适用于磁盘存储<br>    9.  R树：一般用于存储空间位置信息</p><p>解法：<br>    1. 递归。由于二叉树本身就是递归结构，所以几乎所有的解法都需要递归<br>    2. 遍历：前序、中序、后序都是深度优先搜索（DFS），使用递归即可；层次遍历是广度优先搜索（BFS），使用队列辅助完成；<br>    3. 序列化：用层次遍历即可，先把root放进去然后分别放入其子节点</p><h2 id="排序和搜索"><a href="#排序和搜索" class="headerlink" title="排序和搜索"></a>排序和搜索</h2><p>概念：<br>    1. 经典排序算法：插入、选择、冒泡，复杂度都是O(n^2)，实际上一般并不单独使用<br>    2. 普通排序算法的最佳复杂度就是O(nlgn)，一般我们使用快排，但是它的最差复杂度是O(n^2)，相比之下归并排序具有更稳定的复杂度但是却需要占用更多的空间<br>    3. 如果需要稳定排序，一般还是用归并排序<br>    4. 特殊情况下，可以达到线性事件排序，如桶排序、基数排序等<br>    5. 求Kth最大/小的值，一般采用类似快速排序的切割算法，期望复杂度是O(n)，C++中可以用STL中的nth实现<br>    6. 二分搜索的前提是数组已经排好序</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>dp问题没有固定的解法，一般用于最优化问题（统筹规划），需要根据观察列出dp方程，并找到剪枝方式，从而简化求解过程。<br>dp方程的个数取决于状态的个数，自变量的个数则需要分析题意。</p><p>使用动态规划将问题划分为若干个子问题，这些子问题之间相互重叠，通过记忆化查表的方式简化这些计算，动态规划一般分为自底向上和自顶向下两种设计方式。<br>贪心算法则是对子问题直接作出贪心选择，从而简化计算，贪心算法一般都是自顶向下的。</p><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>掌握dfs，bfs和并查集<br>并查集主要是join和search两个操作<br>最短路径算法<br>最小生成树</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常见命令</title>
      <link href="2019/02/17/docker%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
      <url>2019/02/17/docker%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="日志类"><a href="#日志类" class="headerlink" title="日志类"></a>日志类</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f &lt;container&gt; <span class="comment"># 查看日志</span></span><br><span class="line">journalctl</span><br></pre></td></tr></table></figure><h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker ps <span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps -a -q <span class="comment"># 查看全部容器和信息</span></span><br><span class="line">docker ps top</span><br><span class="line">docker pull/commit/tag/push/diff/attach</span><br><span class="line">docker create/build/run/rm</span><br><span class="line">docker start/stop/pause</span><br><span class="line">docker  <span class="built_in">exec</span> -it &#123;&#123;containerName or containerID&#125;&#125; bash  <span class="comment"># 进入容器交互</span></span><br><span class="line">docker cp</span><br></pre></td></tr></table></figure><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本地所有镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 本地镜像名为 ubuntu 的所有镜像</span></span><br><span class="line">docker images ubuntu</span><br><span class="line"><span class="comment"># 查看指定镜像的创建历史</span></span><br><span class="line">docker <span class="built_in">history</span> [id]</span><br><span class="line"><span class="comment"># 本地移除一个或多个指定的镜像</span></span><br><span class="line">docker rmi</span><br><span class="line"><span class="comment"># 移除本地全部镜像</span></span><br><span class="line">docker rmi `docker images -a -q`</span><br><span class="line"><span class="comment"># 指定镜像保存成 tar 归档文件， docker load 的逆操作</span></span><br><span class="line">docker save</span><br><span class="line"><span class="comment"># 将镜像 ubuntu:14.04 保存为 ubuntu14.04.tar 文件</span></span><br><span class="line">docker save -o ubuntu14.04.tar ubuntu:14.04</span><br><span class="line"><span class="comment"># 从 tar 镜像归档中载入镜像， docker save 的逆操作</span></span><br><span class="line">docker load</span><br><span class="line"><span class="comment"># 上面命令的意思是将 ubuntu14.04.tar 文件载入镜像中</span></span><br><span class="line">docker load -i ubuntu14.04.tar</span><br><span class="line">docker load &lt; /home/save.tar</span><br><span class="line"><span class="comment"># 构建自己的镜像</span></span><br><span class="line">docker build -t &lt;镜像名&gt; &lt;Dockerfile路径&gt;</span><br><span class="line">docker build -t xx/gitlab .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s学习纪要</title>
      <link href="2019/02/17/k8s%E5%AD%A6%E4%B9%A0%E7%BA%AA%E8%A6%81/"/>
      <url>2019/02/17/k8s%E5%AD%A6%E4%B9%A0%E7%BA%AA%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>近两年来，由于互联网规模再次扩大，原有的分布式技术（SOA、ESB等）都存在各种各样的缺陷，不能满足日益复杂的需求，所以各种新概念和框架应用而生，目前服务端最流行的是将复杂业务拆分微服务化，以减轻业务和代码的复杂度。在运维端，使用k8s和docker进行快速部署、扩容、监控、编排、回滚等常见运维操作，同时使用istio等Service mesh组件，达到分布式事务、track、router、限流、断路等常见服务需求。</p><h2 id="k8s及其概念"><a href="#k8s及其概念" class="headerlink" title="k8s及其概念"></a>k8s及其概念</h2><p>k8s的架构有一点类似linux的分层技术，比较复杂，所以最好边学变实践，不然根本记不住。<strong>API对象</strong>是K8s集群中的管理操作单元。K8s集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的API对象，支持对该功能的管理操作。例如副本集Replica Set对应的API对象是RS。下面是各种API对象：</p><h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><p>Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>节点是所有Pod运行所在的工作主机，可以是物理机也可以是虚拟机。工作主机的统一特征是上面要运行kubelet管理节点上运行的容器。</p><h3 id="RS"><a href="#RS" class="headerlink" title="RS"></a>RS</h3><p>副本集，在MongoDB中有此概念，这里其实差不多。提供服务的高可用性。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>即部署，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。部署通过创建新的RS，将流量转移到新的RS，然后逐渐关闭旧的RS来实现。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>客户端直接访问的服务对象，长期伺服型。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。在K8s集群中微服务的负载均衡是由Kube-proxy实现的。Kube-proxy是K8s集群内部的负载均衡器。它是一个分布式代理服务器，在K8s的每个节点上都有一个。</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job是K8s用来控制批处理型任务的API对象，有点类似Oracle数据库中的Job，例如定时任务等。</p><h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><p>后台支撑服务集，运行存储，日志和监控等在每个节点上支持K8s集群运行的服务。</p><h3 id="PetSet"><a href="#PetSet" class="headerlink" title="PetSet"></a>PetSet</h3><p>有状态服务集，显然RS是无状态的，这样才能迅速deployment。但是对于db对象，更新的时候显然不能把数据扔了，这时候就需要用PetSet新建一个同名的pod，然后挂载存储继续服务。</p><h3 id="Federation"><a href="#Federation" class="headerlink" title="Federation"></a>Federation</h3><p>集群联邦，为提供跨Region跨服务商K8s集群服务而设计，适用于超大规模集群。</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>类似docker的存储卷，但是更加抽象，pod支持多种存储卷，包括各种云服务的存储（如s3等）</p><h3 id="PV和PVC"><a href="#PV和PVC" class="headerlink" title="PV和PVC"></a>PV和PVC</h3><p>持久存储卷（声明），用以抽象具体的存储逻辑。</p><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><p>Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。</p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>为集群提供隔离功能的命名空间。</p><h3 id="RBAC访问授权"><a href="#RBAC访问授权" class="headerlink" title="RBAC访问授权"></a>RBAC访问授权</h3><p>集群的管理需要一定的授权控制，引入常见的RBAC API对象</p><h2 id="单机搭建k8s环境"><a href="#单机搭建k8s环境" class="headerlink" title="单机搭建k8s环境"></a>单机搭建k8s环境</h2><p>单机使用minikube进行环境搭建，首先使用包管理器安装minikube和推荐的驱动<code>hyperkit</code>（或者你装virtualbox也可以)，然后运行<code>minikube start --vm-driver=hyperkit</code>激活管理器。 在<code>demo</code>文件下创建<code>server.js</code>，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handleRequest = <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Received request for URL: &#x27;</span> + request.url);</span><br><span class="line">  response.writeHead(<span class="number">200</span>);</span><br><span class="line">  response.end(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> www = http.createServer(handleRequest);</span><br><span class="line">www.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>显然这个js只是简单的创建了一个对任意请求返回<code>hello world</code>的http服务器，然后在<code>demo</code>文件夹下创建<code>Dockerfile</code>，内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">6.14</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> server.js .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> node server.js</span></span><br></pre></td></tr></table></figure><p>显然这里就是简单的从node环境中导出8080端口并运行上面的<code>server.js</code>。运行<code>minikube dashboard</code>可以打开网页控制台查看相关信息。</p><p>使用<code>kubectl create deployment hello-node --image=gcr.io/hello-minikube-zero-install/hello-node</code>创建一个部署信息，使用<code>kubectl get deployments</code>获取部署信息，使用<code>kubectl get pods</code>获取节点信息，使用<code>kubectl get events</code>获取事件日志，使用<code>kubectl config view</code>查看配置信息。</p><p>使用<code>kubectl expose deployment hello-node --type=LoadBalancer --port=8080</code>根据刚才的结点创建一个Service，默认情况下pod只能通过内部ip访问，如果想要在k8s外部（即客户端）来访问pod，需要将其导出为服务。现在使用<code>kubectl get services</code>即可看到<code>hello-node</code>的Service。最后使用<code>minikube service hello-node</code>即可访问该服务。</p><p>最后，使用<code>minikube addons enable/disable xxx</code>即可打开/关闭附加服务。使用<code>kubectl delete service hello-node</code></p><p>kubectl最常用的命令格式：</p><ul><li>kubectl get - list resources</li><li>kubectl describe - show detailed information about a resource</li><li>kubectl logs - print the logs from a container in a pod</li><li>kubectl exec - execute a command on a container in a pod</li></ul><h2 id="搭建副本集"><a href="#搭建副本集" class="headerlink" title="搭建副本集"></a>搭建副本集</h2><p>使用<code>scale</code>命令进行副本集的扩展：<code>kubectl scale deployments/kubernetes-bootcamp --replicas=2</code></p><h2 id="滚动升级"><a href="#滚动升级" class="headerlink" title="滚动升级"></a>滚动升级</h2><p>使用<code>set image</code>进行升级，使用<code>rollout undo</code>进行回滚</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影笔记</title>
      <link href="2018/10/07/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/"/>
      <url>2018/10/07/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol><li>快门：取值的倒数，数据越大快门速度越快。高速记录瞬间，低速记录过程；</li><li>光圈：由于光圈值是以 2 的倍数变化的，直接用光圈数值表示镜头的通光量，光圈直径应呈 √2（约等于 1.4）系数关系递增。光圈值越大，通光量越小，景深越小；</li><li>焦距：即镜片中心到 CMOS 底面的距离，焦距越长，景深越浅，且角度越小；短焦距的一般称作广角镜头，长焦距就称为长焦镜头。</li><li>曝光补偿：用以修正曝光值；</li><li>感光度（ISO）：感光度越大，需要的光线越少，但是图像的质量越低。在相同曝光值下，ISO 越低越好；</li><li>长曝光：曝光时间超过 1s，一般用以夜拍，需要三脚架稳定，增大光圈获取更多光线；另外长曝光可以让运动物体呈现梦幻效果（车流、星轨、流水等）；</li></ol><h2 id="快门的参数"><a href="#快门的参数" class="headerlink" title="快门的参数"></a>快门的参数</h2><ol><li>B 门（BuLb），也称为手控快门，是指按下快门时，快门打开，开始曝光，松开快门，快门关闭即停止曝光。也就是说，B 门是由快门按下时间的长短来决定每一次曝光时间的，无需设定曝光时间，可以自由控制。B 门的名称取自英语的“球”（bulb），它起源于旧时照相馆摄影师开启快门时所挤捏的橡皮球。这种橡皮球快门释放装置沿用至今，仍可以在很多现代照相馆的照相机上看到。</li><li>T 门，是指按下快门按钮快门打开，开始曝光，而且快门持续打开，直至再次按下按钮时快门关闭即停止曝光。T 门与 B 门在功能上比较接近，由于 T 门无需一直按住快门按钮，即可使快门持续打开，因此 T 门比 B 门使用方便一些。</li></ol><h2 id="长曝光"><a href="#长曝光" class="headerlink" title="长曝光"></a>长曝光</h2><ol><li>白天的长时间曝光一般都可以直接使用相机的光圈优先模式，先选定光圈，然后由相机决定快门时间，30 秒内的曝光无需进入 M 档，如果相机出现 LO 字样，则需要切换到 M 档进行曝光；白天的长时间曝光，在相机能够自动识别场景，能进行自动对焦的时候，有主体的画面对着主体对焦，无明显主体的场景对着场景的前三分之一处对焦；有主体但是无法自动对焦时，用强光电筒照亮主体对焦处再按相机自动对焦按钮；对焦完成，切记要把对焦模式转为 MF 手动模式。</li><li>夜间长时间曝光选用相机的 M 档（M 模式），先选定光圈，然后旋转相机的主拨轮调节快门时间，超过 30 秒后就出现 BULB，即相机的 B 门，用 B 门进行长时间曝光；用 B 门进行曝光的时候必须使用快门线；靠手按住相机的快门按钮进行长时间曝光是不现实的，晃动的几率太大，非常容易失败；</li></ol><h2 id="倒易率"><a href="#倒易率" class="headerlink" title="倒易率"></a>倒易率</h2><p>倒易律指出底片的响应取决于总曝光量，即光线强度 × 时间。因此，在减少曝光时间但增加光线强度的情况下，底片的响应（比如显影后胶卷的光学密度）不变，反之亦然。<br>换句话说，一般对于某一给定的曝光结果，光圈与快门之间呈反比例关系，即若开大光圈则需要更快的快门以保持曝光不变。</p><h2 id="景深三要素"><a href="#景深三要素" class="headerlink" title="景深三要素"></a>景深三要素</h2><ol><li>与光圈成反比</li><li>与焦距成反比</li><li>与对焦距离成正比</li></ol><p>所以一般拍虚化人像（即散景）时，需要用大光圈长焦镜头。画幅越大越容易拍出更好的虚化效果。</p><h2 id="测光"><a href="#测光" class="headerlink" title="测光"></a>测光</h2><p>手动曝光需要测光，合适的曝光值会显示在屏幕/取景器的测光表上。影响曝光的要素包括：</p><ol><li>快门速度</li><li>光圈大小</li><li>感光度</li><li>曝光补偿</li></ol><p>即使测光宝校 0 成功，也不一定是合适的曝光，需要自己用眼睛去确认。根据被拍摄物体的颜色进行曝光补偿的调整，一般是白加黑减。</p><h2 id="AF-L-amp-AE-L"><a href="#AF-L-amp-AE-L" class="headerlink" title="AF-L &amp; AE-L"></a>AF-L &amp; AE-L</h2><p>「AF-L」用來锁定对焦，「AE-L」用來锁定曝光，两者主要在 AF 模式下使用。其中AE-L使用较多，先选择场景中灰度适中的物体进行测光，点击AE-L后，再进行构图对角拍照；AF-L一般是拍摄运动物体，用于提前锁定焦点。</p><h2 id="AF-S-amp-AF-C"><a href="#AF-S-amp-AF-C" class="headerlink" title="AF-S &amp; AF-C"></a>AF-S &amp; AF-C</h2><p>S和C分别表示单张和连续多张</p><h2 id="BKT"><a href="#BKT" class="headerlink" title="BKT"></a>BKT</h2><p>包围曝光。在测光困难的场景下，可以设置包围曝光，按下快门后根据当前参数下不同的曝光补偿连续拍下多张图片，方便后期进行合成。</p><h2 id="夜景"><a href="#夜景" class="headerlink" title="夜景"></a>夜景</h2><ol><li>使用三脚架（关闭防抖）、长曝光拍摄。如果拍摄星轨，还需要关闭长曝光降噪。</li><li>如果要拍人像，使用闪光灯（后帘同步、白平衡使用闪光灯模式），快门优先，稍高的 ISO、稍大的光圈，先拍摄背景，确定合适的快门速度，在此基础上加快 1~2 倍的快门速度；试拍看一下，根据需要做闪光补偿；</li></ol><h2 id="ND减光镜"><a href="#ND减光镜" class="headerlink" title="ND减光镜"></a>ND减光镜</h2><p>在风光拍摄时，有时候光照可能过于强烈，即使在小光圈+低ISO时，仍然有高光溢出的问题。此时可以使用在镜头前使用减光镜减少进光量。</p><h2 id="恒定光圈变焦镜头"><a href="#恒定光圈变焦镜头" class="headerlink" title="恒定光圈变焦镜头"></a>恒定光圈变焦镜头</h2><p>从进光原理上说，焦距越大光圈越小，相机厂家通过复杂的机械结构实现了无论焦距多大其最大光圈都不变的镜头，即称为恒定光圈镜头。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-数据密集型应用设计</title>
      <link href="2018/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>2018/02/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>本书原著为英文，即《Designing Data-Intensive Applications》，主要讲述数据库底层原理和设计思路，读来受益颇多。</p><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><p>我们期望数据系统可靠、可扩展、可维护，但是由于 CAP 原理的限制，我们无法完全做到这些，因此在设计分布式数据库系统时，必然存在各种考量与限制。这里的数据库，指的不是狭义的关系型数据库，或者非关系型数据库。而是一种广泛的<code>Data System</code>，包括消息队列、RDBMS, NOSQL, 以及图数据库、列式数据库等等负责存储数据的组件。</p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>考量以下几点：</p><ol><li> 提供正常正确的功能；</li><li> 错误容忍性；</li><li> 性能；</li><li> 安全认证；</li></ol><p>其中错误容忍性又分为硬件错误（如断电、内存不足、磁盘不足、网络断开等）和软件错误（各种软件 bug 等），以及人工错误（操作错误、输入错误等）</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>当组件性能、容量无法满足需求时，组件能够通过扩展的方式满足需求，这就是所谓的可扩展性。</p><p>书中举了 Twitter 的 timeline 设计作为例子，我们知道 timeline 展示的是 follower 的发布的状态，那么不考虑任何优化的情况下，设计如下：如果用关系型来描述的话，需要一个 user 表，一个用户 follow 关系表，一个 tweets 表，对于 user id 为 1 的用户，其首页的 timeline 生成是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.<span class="operator">*</span> <span class="keyword">from</span> tweets t <span class="keyword">join</span> follow f <span class="keyword">on</span> f.follower_id<span class="operator">=</span>t.user_id <span class="keyword">where</span> f.user_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> t.created_at limit <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>显然 tweets 表会迅速膨胀成一个超大的表，这种设计不能满足性能的需求。采用写扩散的方案，将每个用户的 timeline 独立存储，用户新的 post 插入 tweets 表后，还要将这个 tweet 插入用户的 follower的timeline 缓存中。除了这个方案以外，还有很多其他的方法，比如使用消息队列。用户 ins/del po, follow/unfollow some one 触发事件，需要对 timeline 进行重新生成。Twitter最终采用了两种方案混合的方式。</p><p>性能描述的常用指标包括：延迟、吞吐量、响应时间等。平均响应时间有时候并不能很好的描述性能，中位数响应时间更合适（一半的请求小于该时间，另一半的大于该时间）。中位数响应时间即 50%分位响应时间，如果要求的更严格，可能需要使用 95%分位响应时间等，甚至 99.9%分位。99%分位以上的又被称为尾部延迟。</p><p>一般将可扩展性分为水平扩展和垂直扩展，两者可以结合起来。如果系统具有自动根据负载进行扩展的能力，这种系统是所谓的“弹性系统”。</p><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>这里主要指的是系统本身简单可维护，且代码清晰易改动。可维护性显然不仅仅是架构的问题，涉及到方方面面吧，比如：</p><ol><li> 系统健康监控</li><li> 错误跟踪系统</li><li> 自动化部署</li><li> 完善的文档系统</li><li> 优雅的抽象，模块化</li><li> 持续迭代</li></ol><p>显然这些其实项目管理的内容。</p><h2 id="数据模型和查询语言"><a href="#数据模型和查询语言" class="headerlink" title="数据模型和查询语言"></a>数据模型和查询语言</h2><p>常见的数据模型包括关系型数据模型，文档性数据模型，网络数据模型和图数据模型</p><h3 id="关系型数据模型"><a href="#关系型数据模型" class="headerlink" title="关系型数据模型"></a>关系型数据模型</h3><p>关系型数据库是最经典的数据库，也是最常用的模型。在 1 对多环境下，文档性数据模型（一般是类 JSON 格式）可以很好的描述数据关系；但是多对多就比较麻烦了。而且现在已有的文档型数据库中，大部分是不支持不同表格之前关联查询的。</p><p>随着技术的进步，关系型数据库和文档型数据库产生了一些融合，现在关系型数据库一般也支持 JSON 字段了，虽然这种有效的融合本质上是反模式的。</p><p>关系型数据库统一使用 sql 语言操作，sql 是一种 DML，类似 CSS。文档型、图数据库的查询语言不通用由各个实现自己定义。当然随着分布式关系型数据库的发展，sql 仍然是最重要的数据操纵语言。</p><p>图数据模型比较复杂，按着一般图的概念，结点和关系构成了整张图。属性图模型的设计如下：</p><ol><li> 一个图中会记录节点和关系</li><li> 关系可以用来关联两个节点</li><li> 节点和关系都可以拥有自己的属性</li><li> 可以赋予节点多个标签(类别)</li></ol><p>在某些应用场景里（如社交网络、金融风控等多对多场景），图数据库在描述关系上具有无与伦比的优势，可以大幅简化查询设计。除了属性图外，还有其他图数据模型实现，如 Triple-Stores，将数据存为主谓宾三元组，一般是使用 SPARQL 进行查询；然后还有 RDF 数据模型，一般使用 XML 语言描述。</p><h2 id="存储和取回"><a href="#存储和取回" class="headerlink" title="存储和取回"></a>存储和取回</h2><p>本章阐述了数据库底层存储和查询的原理。文中先举例了一个 KV 数据库最简单的实现，将数据存在文件中，写入就直接写在文件尾部，读取则用 tail 值（逆序查找即可）。这种直接写到文件尾部的只读文件，本质上是一种 log.</p><p>当然这个实现有个很明显的问题：写入很快，但是查找很慢。如果 key 根本不存在，需要遍历整个文件，因此需要引入索引(index)的实现。比如这里将所有的 key 存入一个红黑树或者哈希表，然后存放对应的偏移量作为值，即成为一个索引。</p><p>由于数据存入文件是 append only 的，很容易导致磁盘空间耗尽，因此需要周期性的对文件进行压缩。对于 KV 数据库而言，每个 key 值最后对应的 value 是唯一的，所谓的压缩其实就是将对同一个 key 的赋值仅保留最后一个。显然这个过程可以分片同步进行（类似归并排序的流程），也可以放在后台进行，不影响前台正常的读写。</p><p>哈希索引是最快的查询索引，仅需要 O(1)时间，但是问题是哈希表必须存入内存之中，一般多用在内存数据库中。而对于存储在磁盘上的数据，一般使用 b-tree 来存放。</p><h3 id="SSTABLE-和-LSM-TREE"><a href="#SSTABLE-和-LSM-TREE" class="headerlink" title="SSTABLE 和 LSM-TREE"></a>SSTABLE 和 LSM-TREE</h3><p>如果将上述实现的 KV 数据库中的 KEY 排序，得到的表就是所谓 SSTABLE(SORTED STRING TABLE)，这种表格归并和查找的速度都明显超过普通的文件，这样就不再需要额外的完整索引来进行查找加速（但是可能需要稀疏索引来加速搜索）。</p><p>SSTABLE 在内存中可以使用各种平衡二叉树，比如红黑树或者 AVL 树。为了性能考虑，先把数据写入内存表（即缓存），然后等到内存中的数据达到一定的阈值后，再序列化写入硬盘，写入硬盘的部分也可以分片。最后，周期性运行数据压缩，消除冗余 key 值。</p><p>SSTABLE 的设计比较完善，考虑到掉电问题，还需要对内存表的操作保留一份日志，以便进行错误恢复。可以使用 WAL（WRITE AHEAD LOG)日志来记录。</p><p>以上思路，就是所谓的 LOG STRUCTURED MERGE-TREE, 即 LSM-TREE，Lucence 这个搜索引擎在底层即使用了这种数据结构，然后 Level DB 等数据库也使用了这种数据结构，Level 指的是数据归并压缩时使用的策略。将 key 根据范围划分为不同的 Level，从而用来加速归并和压缩的速度。</p><p>可以使用<code>Bloom filters</code>算法加速搜索，确认 key 不存在。</p><h3 id="B-TREE"><a href="#B-TREE" class="headerlink" title="B-TREE"></a>B-TREE</h3><p>b-tree 是磁盘存储数据时最常用的索引结构，这是一种自平衡多路查找树，特点是能够保持较低的高度。</p><p>b-tree 将数据抽象成固定大小的 block 或者说 page，一般是 4Kb 每页（机器硬盘），每次读写一页。每个 page 里面是数据和指向其他 page 的指针，这棵树也有一个根节点，是每次搜索的开始。每页包含指向子叶的指针数，即所谓的“分支因子”（一般是几百个）。page 里面是索引列的有序键值，但是这个键值是稀疏的排序，树的高度被保证为较小的值，这样通过 3~4 层的搜索能够找到大部分 key 值。</p><p>还有一些常见的其他的优化措施，如 WAL 啊，多线程保护（latch）啊，写时复制啊，或者使用变体的分型树、<code>b+</code>树、<code>b*</code>树等.</p><p>对比B-Tree和LSM-Tree，后者拥有更好的写性能（速度和吞吐量），前者拥有更好的读性能。同时，后者由于会定期重写SSTables清除碎片，对磁盘空间的需求量也小的多。但是LSM-Tree在压缩数据时会影响磁盘的IO性能，进而影响到数据库的读写速度。</p><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p>简单来说，直接将值放在索引里的是聚簇索引；放的是数据的引用/指针的则是非聚簇索引。后者需要回表索取原始数据，所以性能会差一些。综合两者的被称为覆盖索引。</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>简单的实现是直接将多列拼接成同一个 key，复杂情况使用其他优化的数据结构。Mysql中通常成为复合索引，适用最左匹配原则。</p><p>GIS 中的地理位置索引，包含经度和纬度，一般使用 R-TREE 来实现。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>对于搜索引擎，需要的是进行模糊查询，一般的索引技术不能满足需求。数据结构以外，还需要结合分词技术、机器学习等其他技术才能满足各种需求。</p><h3 id="内存数据库"><a href="#内存数据库" class="headerlink" title="内存数据库"></a>内存数据库</h3><p>随着内存价格的降低和容量的增加，全内存型数据库也开始涌现。对于 IO 性能要求较高的场合，大量使用内存数据库（如游戏）。关系型内存数据库常见的如 voltdb，KV 型的如 redis 等。</p><p>内存数据库速度快的原因不是把所有数据都放在内存里，因为传统关系型数据库也有 cache，这个优势并没有想象的那么大。内存数据库避免了序列化/反序列化的额外负担，同时还可以实现一些无法在磁盘中实现的功能，如 Redis 中的 set, zset 等。</p><p>内存数据库可以存放超过内存大小的数据，简单来说就是将最近未使用的数据写入磁盘，需要的时候再重载入内存，类似操作系统的虚拟内存技术。随着非易失性内存技术的发展，最终硬盘和内存将会殊途同归，也就不用再考虑这些问题了。</p><h3 id="OLTP-与-OLAP"><a href="#OLTP-与-OLAP" class="headerlink" title="OLTP 与 OLAP"></a>OLTP 与 OLAP</h3><p>前者用于大量写入，对事务的性能要求较高，后者用于数据分析。</p><p>刚开始的时候都用普通 db，随着量级的发展，OLAP 一般使用独立的数仓来完成。数仓将 OLTP 数据库中的数据进行 ETL，存入专门用来数据分析的 db. OLAP 数据库和 OLTP 使用不同的优化方式，前者使用了一些其他的索引技术。</p><p>OLAP 一般使用星型模型/雪花模型，将多维度数据聚合到事实表中，从而避免大量 join 查询。此外，OLAP 会使用列式数据库（如HBase），列式可以更方便的进行数据压缩，对查询进行更好的优化。</p><p>列式数据库的写入很麻烦，一般使用 LSM-TREE 进行优化，先写入内存，异步写入文件。</p><p>除了这些技术以外，还有很多其他辅助手段用来提升 OLAP 的查询速度，如物化视图。对于需要经常查询的聚合数据，适用物化视图相当于加了个触发器，自动根据原始数据更新对应的聚合数据表。这样查询的时候就不要实时聚合，大幅度提高了查询速度。</p><h2 id="编码与迭代"><a href="#编码与迭代" class="headerlink" title="编码与迭代"></a>编码与迭代</h2><p>本章主要讨论消息序列化的编码结构（不是字符编码），以及这些编码形式如何应对字段变更、滚动升级等需求。</p><h3 id="二进制序列化"><a href="#二进制序列化" class="headerlink" title="二进制序列化"></a>二进制序列化</h3><p>各个语言有自己的二进制序列化机制，但是一般并不推荐使用，其兼容性、适用性和安全性都有一些问题。不过二进制序列化速度一般比纯文本格式要快一些。</p><h3 id="JSON-XML-和二进制编码"><a href="#JSON-XML-和二进制编码" class="headerlink" title="JSON, XML 和二进制编码"></a>JSON, XML 和二进制编码</h3><p>一般情况下，JSON 和 XML 足够用了，除了一些缺点。JSON 的问题是只支持浮点数，且无法指定精度，有溢出风险。XML 的话就是有点过于笨重，但是支持 XPATH 这种高级检索语言。基于 JSON 和 XML 也有一些二进制编码。</p><p>如果使用 RPC 通信，可以考虑使用二进制编码，例如 Thift 或者 Protobuf，此外还有 Avro 等.</p><p>显然 JSON 是通过字段的 key 值来保持兼容性的，而 XML 则使用属性。而 Thift 和 Protobuf 则使用的是字段的 tag，旧的代码读到不认识的 tag，就会忽略掉对应的字段，从而保持兼容性。当然，这里有个问题，新增的字段不可定义为<code>required</code>，就如同给关系型数据库新增字段不能为 NOT NULL 且没有 DEFAULT 值一样。如果是移除字段，也只能移除<code>optional</code>的，且该字段的 tag 将来一定不能被重复使用。如果想要修改字段类型，就有一定的风险，需要视字段间的兼容性和精度而定。protobuf3移除了这两个关键字（并且加入了map），所有的字段都被视为optional.<code>protobuf</code>的一个问题是他不允许嵌套的array和map（当然可以通过嵌套message变相实现），Thrift则允许。</p><p>对于 Avro，其 IDL 里面根本没有 tag，读方的 schema 和写方的 schema 可以不一致，avro 会自动处理兼容的字段，忽略不兼容的字段（或者赋默认值）。Avro 是为了给 Hadoop 使用的，这种设计的目的是为了关系型数据库增减字段时不需要人工手动修改 IDL 的 schema.</p><h3 id="HTTP-RPC-MQ"><a href="#HTTP-RPC-MQ" class="headerlink" title="HTTP, RPC, MQ"></a>HTTP, RPC, MQ</h3><p>基于不同传输协议的数据封装讨论，都是一些开发者耳熟能详的知识点，不再赘述。</p><h2 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h2><p>副本集一般有三种架构：single leader，multi leader， no leader。对应mysql，一主多从的架构有MHA，多主的架构有PXC。副本集的主要目的是保证数据高可用，副效果是降低单机的负载。</p><h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>即单主模式，写到 leader，leader 通过 log 或者 Stream 同步到 follower，读的时候可以从从库读，也可以从主库读（即读写分离）。</p><p>主库到从库的同步可能是同步或异步的，后者会出现读出的数据是 old data 的情况。</p><p>故障恢复：如果从库 down 了，重启后通过日志重新同步即可；但是如果主库 down 了，就需要重新选举一个 leader，否则整个服务就不可用了。选举的过程包括：</p><ol><li> 认定 leader down，一般使用 timeout</li><li> 选举新的 leader；一般使用具有最新数据的副本当leader（共识问题）</li><li> 使用选举出来的新 leader</li></ol><p>需要解决的问题：</p><ol><li> 如果 follower 与 leader 之间的数据同步是异步进行的，old leader down 之前可能还没来得及将数据同步给其他 follower，那么新的 leader 就有丢失一部分数据。old leader 恢复后，需要成为 follower，并丢弃这部分未同步的内容；这种丢弃是很危险的，有可能出现各种问题；</li><li> 可能会出现两个节点都以为自己是 leader 的问题，即所谓的脑裂问题；</li><li> 判定服务 down 的 timeout 确定；</li><li> 原来的主库重新上线后，可能有冲突要解决；</li></ol><h4 id="副本-log-的实现原理"><a href="#副本-log-的实现原理" class="headerlink" title="副本 log 的实现原理"></a>副本 log 的实现原理</h4><p>对于关系型数据库而言，一种显而易见的实现方式是将所有写语句(CREATE, UPDATE, DELETE, ALTER)都记录到日志里，follower 依序重复执行这些语句。但是这里可能有一些问题：</p><ol><li> 有些函数是不可能重复执行的，如 RAND(), NOW()之类的；</li><li> 如果依赖已经存在的数据，必须保证执行顺序，这意味着不能并发执行 log 中的语句；</li><li> 有副作用的语句在各个副本集中造成的副作用可能不一致；</li></ol><p>这些问题可以通过将非确定性的语句修改为确定性的（即将 NOW()的结果记录）来解决，MySQL 则直接使用了 ROW-BASED 将行数据覆盖的方法（又称为 logic log）来解决。还可以使用 WAL 这种直接修改磁盘字节的方法来进行，这种方法最大的问题是要求所有的 follower 必须和 leader 保持同样的二进制结构（如存储引擎），这会导致无法平滑升级服务。最后还有一种基于触发器实现的同步，一般是在应用层同步数据时当作工具来使用。</p><h4 id="副本-log-的问题"><a href="#副本-log-的问题" class="headerlink" title="副本 log 的问题"></a>副本 log 的问题</h4><ol><li> 读写一致性问题。用户写完以后立刻读，必须保证读到的是刚写的数据，但是由于从库的同步是异步的，所以可能会出问题；主从异步同步模式仅仅能保证最终一致性，而不是实时强一致；</li><li> 数据时序性问题。如果用户使用了一系列的读（落到不同的 follower 上），可能由于同步进度的问题，导致部分读到的是新数据，部分是旧数据；</li></ol><p>解决方案：</p><ol><li>如果能明确区分数据属于用户自己，则直接从主库读取；</li><li>最简单的方案是用户总是从同一个副本中读取（即所谓的单调读）；不过这样还要考虑副本down了的HA；然而除了这种顺序以外，还有一种：假设用户A和用户B在对话，二者读的是不同的从库。那么用户C在旁观这种对话过程中，可能观察到错误的对话顺序。在IM群聊中这种场景比较常见，对应这样的场景，需要保证一个群总是对应唯一的服务器节点，保证这种因果关系的顺序性。</li></ol><p>换句话来说，这两个问题都没有完美的解决方案，只能根据业务的实际情况来区别对待。</p><h3 id="多-leader-模式"><a href="#多-leader-模式" class="headerlink" title="多 leader 模式"></a>多 leader 模式</h3><p>单主模式情况下，如果服务器和主库的网络发生故障，服务就不再可用。在局域网中这种情况基本不太可能，但是如果存在多个数据中心（异地），这时候各个 data center 各有一个 leader 是更合适的，所有的写发往 local 的 leader，然后由 leader 之间相互同步。显然，多 leader 之间的数据同步会引发各种问题。而且新加入的节点需要同步全量数据，开销很大。</p><p>还有一种特殊的多 leader 模式：如果应用需要能够离线工作（如日历），但是设备没有连接上英特网，那么此时设备本地的 db 就是 leader.</p><p>多主模式下，两个不同节点的事务可能都提交成功，但是db之间合并数据时可能会出现冲突。解决方案：</p><ol><li> 避免这种情况，根据用户的 ip 地址就近选择数据中心，游戏分服就是这样解决的。但是如果用户换了地方，原来账号的体验就会比较差了。</li><li> 自动解决冲突：数据加入时间戳（自增 ID），使用最新的值解决冲突（即LWW，会丢数据）；或者允许用户自定义冲突解决代码，当发现冲突时自动调用这段代码；</li><li> 手动解决冲突：数据库记录下所有冲突，当该值被阅读时，返回所有值，提示用户手动解决冲突，CouchDB 使用该方案；</li></ol><p>多 leader 之间同步拓扑：</p><ol><li> 环形拓扑：每个 leader 只同步给另外一个 leader，这里要注意单节点挂掉的问题；</li><li> 星形拓扑：使用一个 root 节点，其他所有节点与该节点进行同步，root 节点可能挂掉；</li><li> all to all，每个节点和其他所有节点拓扑，这时要注意时序问题；</li></ol><p>总的来说，目前多主模式在实际运行中的冲突问题还没有完美的自动化解决方案，需要根据业务场景确定策略。</p><h3 id="leaderless-模式"><a href="#leaderless-模式" class="headerlink" title="leaderless 模式"></a>leaderless 模式</h3><p>这种模式没有主从，客户端的读写同时发送给所有的结点。如果有节点 down 掉，写请求会忽略挂掉的结点；当结点恢复后，会出现数据不一致的问题，客户端从多份节点数据中选取时，选取 version number 较大的数据，作为准确的数据返回。</p><p>上面这种宕机情况，数据修复方案：</p><ol><li> 客户端修复，客户端发现某个节点的数据版本落后于其他节点，那么就将最新版本的数据写入其他节点；这个的问题就是有些数据可能不怎么会被读到，数据长时间存在不一致的问题；</li><li> 多节点之间自动同步，异步，无特定拓扑顺序，所以可能滞后很多；</li></ol><p>多节点同时读取还有读取/写入数量，以及可信度的问题。一般而言，一共有 n 个结点，至少写入 w 个节点保证写成功，至少读取 r 个节点保证读成功，则必须有<code>w+r&gt;n</code>才能保证系统的可靠性。一般情况下，n 是一个奇数，<code>w=r=(n+1)/2</code>. 当然可以根据实际需要调整 w 和 r，以协调自己所需的性能和可靠性。</p><p>显然 leaderless 模式会遇到和 multi-leader 类似的问题：时序问题、冲突问题，解决方案也类似。</p><h4 id="版本向量"><a href="#版本向量" class="headerlink" title="版本向量"></a>版本向量</h4><p>一种多客户端写入时解决冲突的方案，即对客户端的每个请求创建的数据都生成一个版本号。在返回客户端时，除了原始数据外也将数据的版本号返回客户端，客户端请求的时候带着本地的最新版本号，这样就可以根据数据的版本进行自动的数据合并。</p><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>数据分片与副本集不同，是将数据进行垂直切分，也就是所谓的 sharding 技术，经常与副本技术配合使用。对于 KV 型数据库，常见的分区策略包括：</p><ol><li> 按 key 值范围，缺点是分区可能不均匀；</li><li> 按 key 值的 hash 值范围，解决不均匀问题。此时要注意 hash 值必须唯一，如 md5。这会引入一个新问题：无法范围查询 key 值，因为他们不再毗邻。Cassandra 的解决方案是用联合主键，如果第一位确认，后面的还能保证都在一个 partition 上，如(user_id, timestamp)；</li><li> 即使使用了 hash，有时候也会遇到单点过热问题，如社交网络上某个名人的行为总会引起大的数据波动，这个只能在应用层解决了；</li></ol><h3 id="次级索引"><a href="#次级索引" class="headerlink" title="次级索引"></a>次级索引</h3><p>对于 RDBMS，除了主键，一般还有其他索引，如果访问需要通过多个索引字段进行，分片的方式就需要斟酌了。次级索引包括：</p><ol><li>分区本地索引；此时范围查询的请求只能发给所有分片，然后再归并查询结果(scatter/gather);</li><li>全局索引；即对全局数据进行规约后的索引，但是全局索引也要分片，只是分片的方案需要根据业务来取舍；</li></ol><h3 id="再平衡"><a href="#再平衡" class="headerlink" title="再平衡"></a>再平衡</h3><p>在运行一段时间后，数据在各个分片中可能不太均衡，或者需要增加/减少节点，需要将数据在节点之中进行数据搬运。这被称为<strong>再平衡</strong>。</p><ol><li>一个简单的方案是为每个节点预先分配多个分区，当新的节点加入时将其他节点的部分分区数据迁移到该节点即可；删除节点执行反向操作；这个方案的问题是，预分配的分区数量可能难以确定；</li><li>使用动态分区。数据库会根据数据量的大小动态增加或者缩减分区个数；当然初始数据量很小的时候，可能只需要一个分区，此时可以预分区；</li><li>每个节点的分区数保持不变；当加入新节点时，增加对应数量的分区。这样可以更好的平衡各个节点；</li></ol><p>使用一致性哈希算法，可以有效减少再平衡时需要移动的数据数量。</p><p>再平衡后的服务发现问题：服务器需要知道从哪个节点取数据。一般来说有3个解决方案：</p><ol><li>服务器自己知道：将分区依据写成配置。手动再平衡完毕后修改配置；</li><li>使用代理的路由层，代理知道如何寻址；注意路由层本身也应该是个分布式的组件（例如zookeeper）；</li><li>随便发给任意一个节点，节点自己转发；</li></ol><p>除了方案1的静态配置，其他两个方案需要动态发现正确的路由。这涉及到分布式环境的共识问题，</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>关系型数据库一般都有 ACID 特性，其中 A 指的是原子性，即一件事要么发生，要么不发生，即使这件事里面包含多个动作；I 指的是隔离性，不同事务之间不相互影响，不会出现脏读等问题；D 指的是持久化能力；而 C 指的是一致性，这个其实无法由数据库来保证，在分布式系统里，最终一致性需要很多条件才能保证。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一般数据库都能保证单对象写入的原子性，但是只有少部分数据库能保证多对象写入的原子性（即支持事务）。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>那么根据不同的隔离级别，有以下几种弱隔离性实现：脏读-&gt;不可重复读-&gt;可重复读（幻读）-&gt;串行化.</p><p>数据库一般默认使用 MVCC 技术实现隔离。不可重复读一般情况下没啥影响，但是如果数据库同时在进行备份，可能中间状态就丢了，大部分db的默认隔离级别是这个。</p><p>使用 MVCC 将隔离级别上升为可重复读，或者说叫快照隔离（mysql默认该级别）。此时当事务开始时，会获得一个事务全局递增的唯一事务编号，而更新将会被拆分成删除+创建。这样，一个更新操作实际上产生了两个版本的数据。当一个事务开始时，做如下判定：</p><ol><li> 首先确定当前正在进行但还未提交的事务，使用这些事务开始前的数据版本；</li><li> 已经 rollback 的事务，其数据修改被直接废弃；</li><li> 事务 ID 号大于当前事务的提交，不管事务有没有提交，忽略其提交结果；</li><li> 除了上诉情况以外，其他的写入可以被当前事务感知到；</li></ol><p>这种实现对索引的使用：多个版本同个字段使用索引，使用 B 树时，update 不是直接修改 page，而是产生一个新 page，也就是<code>copy-on-write</code>。</p><h4 id="写丢失"><a href="#写丢失" class="headerlink" title="写丢失"></a>写丢失</h4><p>两个事务同时写，一个的写入可能会丢失。解决方案：</p><ol><li>原子写入，包括使用CAS。但是用ORM的时候有时候会很难写出k=k+1这种语句，因为k会被直接解释为变量当前的值；</li><li>使用悲观锁，即<code>select ... for update</code>，不过在数据不存在时，不能用这个方案；而是要使用类似数据库的upsert语义方言。如mysql的<code>ON DUPLICATE UPDATE</code>，oracle的<code>merge</code>；</li><li>部分 db（不含 mysql）实现了 lost update detection，可以自动侦测到该问题；</li></ol><h4 id="幻读问题"><a href="#幻读问题" class="headerlink" title="幻读问题"></a>幻读问题</h4><p>可重复读会导致幻读，如果想要解决这个问题，只能使用串行化，这种隔离的实现方案包括：</p><ol><li> 单线程执行所有事务，这样就自动串行化了。如 Redis、VoltDB（使用存储过程，将读写都写在一起，优化方案）；</li><li> 2PL，即两阶段锁。类似读写锁，如果事务对对象没有写入，就允许共享同一个对象。但是一旦开始写入，则使用排他锁进行独占；这比单独的写锁性能更好（这是显然的）；</li></ol><h4 id="序列化算法"><a href="#序列化算法" class="headerlink" title="序列化算法"></a>序列化算法</h4><ol><li>共享锁、排他锁、读写锁；</li><li>谓词锁。即对某个条件产生锁，即使该条件下尚不存在数据。显然谓词锁可能会大幅度降低数据库的性能（创建太多），他的替代品是：</li><li>间隙锁。即对搜索条件使用的某个字段的索引进行加锁；但是如果无法命中索引的话，会退化成表锁，大幅度影响性能；</li></ol><p>将最后两个隔离方案结合起来，就是所谓的<code>serializable snapshot isolation</code>，即 SSI，这是一个新算法（2008 年提出），在 PostgreSQL 9.1 以后使用，较有潜力。</p><h2 id="分布式系统的问题"><a href="#分布式系统的问题" class="headerlink" title="分布式系统的问题"></a>分布式系统的问题</h2><h3 id="局部失败"><a href="#局部失败" class="headerlink" title="局部失败"></a>局部失败</h3><p>分布式系统某个节点挂掉引起的一系列问题。</p><ol><li> 如果是单主集群，需要重新选举；</li><li> 需要考虑节点恢复后如何重新纳入集群；</li><li> 需要考虑如何判定节点挂掉，一般是用网络超时，但是这个值比较难以假定；</li><li> 考虑单节点阻塞导致的丢包问题；</li></ol><h3 id="时序问题"><a href="#时序问题" class="headerlink" title="时序问题"></a>时序问题</h3><p>分布式系统不同节点之间的时钟同步。</p><ol><li> 依赖时序策略的影响，如 LWW（可以使用逻辑时钟代替墙上时钟）；</li><li> NTP 同步的精确度，NTP 本身的延迟，NTP 服务本身的不可靠性；</li><li> Google spanner 的时钟策略，返回一个[least, most]的时钟范围，保证准确的时间落在该范围之内；</li></ol><h3 id="系统阻塞"><a href="#系统阻塞" class="headerlink" title="系统阻塞"></a>系统阻塞</h3><ol><li> GC 引起的 stop the world</li><li> 单线程阻塞</li></ol><p>其他原因造成的系统结点卡顿，以至于其他结点访问超时，误以为该节点挂了。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><h3 id="线性一致性-Linearizability"><a href="#线性一致性-Linearizability" class="headerlink" title="线性一致性(Linearizability)"></a>线性一致性(Linearizability)</h3><p>所谓线性一致性，指的是对于一个分布式系统的多个副本集，读出的结果永远都是一致的（就好像从唯一一个副本集中读出的一样）。该一致性模型是我们能实现的最强一致性模型，所以又被称为 strong consistency.这种模型假设操作具有一个全局有效时钟的时间戳，但是这个时钟仅具有有限的精确度。要求时间戳在前的进程先执行，换句话说，所有的操作都不是并发的，而是有严格的顺序的（全序）。</p><p>单 leader 的副本集群，理论上可以做到线性一致，但是在节点故障的时候可能出现脑裂等问题，此时就会违反线性一致性；而多 leader 节点一定不会是线性一致的，无 leader 集群则不一定，取决于配置（只有 read repair 策略下或许可行，但是这个效率很低，故一般认为不保证。）。另外 LWW 策略必然是非线性的（依赖时钟）。</p><p>在某些场景下，只允许线性一致性，比如 leader 选举等。显然该一致性的性能是最差的。</p><h3 id="因果一致性-causal-consistency"><a href="#因果一致性-causal-consistency" class="headerlink" title="因果一致性(causal consistency)"></a>因果一致性(causal consistency)</h3><p>当一个读操作后面跟着一个写操作时，这两个事件就具有潜在的因果关系，同样，读操作也与为读操作提供数据的写操作因果相关。没有因果关系的操作被称为并发的。</p><p>所有进程必须以相同的顺序看到具有潜在因果关系的写操作，不同机器上的进程可以以不同的顺序被看到并发的写操作。</p><p>实现因果一致性要求跟踪哪些进程看到了哪些写操作。这就意味着必须构建和维护一张记录哪些操作依赖于哪些操作的依赖关系图。一种实现方法是版本（向量）时间戳。</p><p>几乎所有的分布式系统都支持因果一致性。前面讨论的事务追踪数据过期抛出失败，也就是保证了因果一致性。</p><p>使用 Lamport 时间戳可以保证因果一致性，其实现原理如下：</p><ol><li> 不同的结点各有自己的编号 n；</li><li> 每个结点使用自己的计数器 c；</li><li> 使用(c, n)表示 lamport 时间戳；</li><li> 客户端/node 跟踪 c 值，当 node 发现客户端请求的 c 值大于自身 c 值时，立刻将自身 c 值设为请求的 c 值（对客户端亦然）；</li><li> 定义当 n 相等时 c 值较小的逻辑时间较小；否则 n 值较小的逻辑时间较小；</li></ol><p>显然 lamport 时间戳定义了一个全序的操作序列。问题在于这个顺序必须在动作执行完成后（即 node 返回后）才能确定下来，这对于某些场合不够用（比如唯一约束）。</p><h3 id="弱一致性-weak-consistency"><a href="#弱一致性-weak-consistency" class="headerlink" title="弱一致性(weak consistency)"></a>弱一致性(weak consistency)</h3><p>引入同步变量 S，其仅有一个关联操作 synchronize(S)，该操作同步数据存储的所有本地拷贝。</p><p>使用同步变量来部分地定义一致性就得到称为弱一致性模型，其具有三个属性：</p><ul><li>对数据存储所关联的同步变量的访问是顺序一致的；</li><li>每个拷贝完成所有先前执行的写操作之前，不允许对同步变量进行任何操作；</li><li>所有先前对同步变量执行的操作都执行完毕之前，不允许对数据项进行任何读或写操作。</li></ul><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>在网络分区的情况下，一致性和高可用性只能取其一，即所谓 CAP 理论。CAP 理论在最开始时(2000 年)对分布式系统的设计起到了很重要的指导作用，但是现在要考虑的情况要复杂的多，因此一般不再提起该理论。</p><h3 id="全序广播"><a href="#全序广播" class="headerlink" title="全序广播"></a>全序广播</h3><p>通过单 Leader 多 Follower 机制，在 Leader 节点上对所有操作进行排序，从而决定了整个操作顺序，并将操作顺序进行广播。</p><p>全序广播要求满足如下两个属性总是被满足：</p><ul><li>可靠的交付,没有消息丢失：</li><li>如果消息被传递到一个节点，它将被传递给所有节点。完全有序传递，消息以相同的顺序传递给每个节点。</li></ul><p>全序广播是异步的：消息保证以固定的顺序可靠地传递，但不能保证何时传递消息（因此存在节点可能落后于其他节点）。而线性化一致性能够保证：每次读操作能够读到最新值的写入。我们可以依托于全序广播，在存储上实现线性化一致性。全序广播需要一个序列生成器，然而这又是一个共识问题。</p><h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><p>所谓共识，指的就是最终一致性。在理论上，如果节点可能崩溃，则共识不可能达成（FLP）。不过在现实中，节点崩溃是可以探测的，所以共识还是可以达成的。</p><h3 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h3><p>当客户端准备提交事务时，协调者（事务管理器）开始阶段 1：所有参与者进行预提交，根据响应，分为两种情况：</p><ol><li> 所有节点准备完毕（使用 transaction id，完成相关写入）。进入阶段 2，开始真正的 commit；</li><li> 任一节点未正确响应，进入 abort;</li></ol><p>显然，各节点即使准备完毕，也可能因为异常导致并未正确提交，所以该节点在未做出正确答复之前，协调者会持续询问。</p><p>但是如果协调者也挂了，2PC就会卡住，必须等待协调者恢复，此时的状态称为存疑事务。</p><h3 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h3><p>改进的二阶段提交，加入了询问机制。该协议假设网络延迟有界，这不符合正常的场景，所以一般还是用2PC.</p><h3 id="异构系统的分布式事务方案：XA事务"><a href="#异构系统的分布式事务方案：XA事务" class="headerlink" title="异构系统的分布式事务方案：XA事务"></a>异构系统的分布式事务方案：XA事务</h3><p>这是一种协议，由数据库自己实现。具体来说就是应用程序自己充当协调者发起异构系统之间的二阶段提交。</p><h3 id="paxos-算法"><a href="#paxos-算法" class="headerlink" title="paxos 算法"></a>paxos 算法</h3><p>paxos 算法是分布式系统实现最终共识的当前唯一正确算法，raft 等算法只是其变种。他解决的是最终一致性（共识）问题，这个前面提的一致性不是一个概念。其流程如下：</p><pre><code>阶段一：(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。阶段二：(a) 如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。</code></pre><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>这一章介绍了一些常用的处理工具，包括unix上常见的sed、awk等小工具和map-reduce. 后续还介绍了流式数据处理需要注意的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis知识点总结</title>
      <link href="2018/01/28/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>2018/01/28/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>redis是现在web开发中用的最广泛的组件之一了，用了很多年，是时候总结一下用法和经验了。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>两个方案：DUMP和LOG。前者就是直接生成快照（SAVE），或者主进程fork一个进程（BGSAVE，内存使用要加倍）然后将内存里面的数据全部存入文件；后一个方案类似LSM-TREE的思路，将操作生成日志，并定期重写。</p><p>SAVE会导致其他命令被阻塞，BGSAVE同样也会（数据量过大时，复制内存本身也很消耗时间），而且系统如果down掉，save之后的数据就会丢失。</p><p>AOF的方案有两个问题：1是生成日志体积可能过大，2是恢复数据的速度比较慢。好在这两个都可以通过重写日志来改进。一般情况下，这两个方案是同时使用的。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>redis并不支持传统意义上的事务，想要原子提交，最简单的办法是：使用lua脚本。注意lua脚本逻辑如果太过复杂，可能会使redis阻塞较长时间。</p><p>另一种方案是用<code>WATCH</code>配合<code>MULTI</code>和<code>EXEC</code>这两个命令，watch会生成一个乐观锁，当监控的变量改变时，后面的pipeline就会中断执行并在程序中抛出异常。事务在收到<code>EXEC</code>的时候才开始执行，前面的命令只是入列，而<code>WATCH</code>恰好持续到<code>EXEC</code>为止。注意如果pipeline中有命令出错，redis事务并不会终止，而是会接着把所有命令跑完，而且redis事务本身也不支持回滚，有需要的话你只能手动回滚。</p><h2 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h2><p>简单的是一主一从，用SYNC（新版是PSYNC）同步到从库。</p><p>稍微复杂的是一主多从的哨兵模式，主down了以后会在从库中选出新的主。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>本质仍然是sharding. redis集群节点之间相互通信，知道需要处理的命令在哪个分片，如果客户端查询到错误的节点，该节点会返回一个MOVED错误，redirect客户端到正确的节点。当然，如果使用redis驱动的话，对客户端是透明的。</p><p>由于每个节点负责多个分区（在这里称为slot），再平衡过程很简单，就是将其他节点的分区转移到新节点即可（移除节点也类似）。</p><p>集群和副本集配合使用，节点的副本即所谓“从节点”。</p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>字符串 -&gt; 作者自己实现的简单动态字符串（SDS）；<br>zset -&gt; skiplist（类似红黑树，但是更简单）<br>list -&gt; 就是链表<br>set/hset -&gt; hash表</p><p>优化：如果set都是数值，且数量较少，会使用intset节省内存；如果array和hset都是小整数或者短字符串，会使用ziplist节省内存。</p><p>GC：自己实现的引用计数。</p><h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>redis将所有key的过期时间保存在一个公用的过期字典里，用来计算ttl.</p><p>过期删除使用惰性策略+定期删除。</p><p>save的时候会忽略掉已经过期的key，aof只有在显式删除key后才会追加DEL命令。不过aof重写日志的时候也会判断键是不是过期，类似save.</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试复习纪要.md</title>
      <link href="2018/01/25/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
      <url>2018/01/25/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>到 30 岁了，突然发现自己还是对编程理解的很浅，在此梳理一下技术栈，并准备新年的面试。</p><p>作为一个服务器开发工程师，涉及的技术相当之多，部分角度的深入理解需要花费大量时间，因此到最后一般是精通某个/几个方向，并对其他方向也有涉猎。</p><h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><ol><li><p>基本数学知识。包括：数据结构、算法；</p></li><li><p>web 相关技术。对于一般以业务为主的公司，这个就是吃饭的本事。细分如下：</p><ul><li>通信相关基础知识，如Http，TCP，UDP，Socket编程等；</li><li>一门编程语言，一个或多个 web 框架。如 PHP + Laraval, Python + Flask, Ruby On Rails, Java + Spring 等；</li><li>理解框架底层原理，如select，epoll或者Java的NIO等设计机制；理解CSP和Actor并发模型；理解大并发下常见的优化策略；</li><li>RDMS，不管是 oracle、mysql 或者 postgresql，除了基本的使用增删改查以外，还要了解常见的优化措施。随着 NewSQL 的兴起，大量分布式云数据库开始出现，如 TiDB, RedShift 和 HyriaDB 等.</li><li>NoSQL，如 Redis，MongoDB 或者 cassandra；</li><li>此外还有内存数据库，其使用和 rdms 基本一致，如 Apache ignite；</li><li>以上数据库针对不同场景和数据量级，做不同的技术选型；</li><li>Linux 的常见使用，运维方向的一些基础知识（Python 和 shell 是必备技能）；</li><li>常见应用层协议：http, https, websocket，rpc</li></ul></li><li><p>分布式相关技术。随着业务的扩展，后端架构的复杂度会指数级上升，单机的性能无法满足业务需求，必须引入分布式系统。</p><ul><li>基本理论。分布式系统非常复杂，必须熟读相关理论，如 CAP，Paxos 等，知道常见的问题和解决方案；</li><li>常见组件，如 docker, etcd等，各自的使用场景和原理；</li><li>常见框架，如 Spring Cloud 以及最新的 Service Mesh 的实现;</li></ul></li><li><p>测试/运维相关技术。如果在小公司，一个后端开发一般同时担任部分运维和测试的职责。</p><ul><li>版本控制相关，严格来说正确使用 git/svn 是所有开发的基本能力；</li><li>自动构建，快速部署。Docker 相关技术；</li><li>线上监控，告警系统；</li><li>自动化测试系统；</li></ul></li><li><p>大数据相关技术。所谓大数据，其实本质上就是 OLAP，由于数据量过大，rdms 已经无法承载对应的数据量和性能需求。</p><ul><li>数据收集：如 flame 等；</li><li>数据存储，如 HBASE，hive 等；</li><li>数据分析：如 spark、Hadoop 等；</li></ul></li><li><p>扯淡的人工智能。 对于大部分公司而言，人工智能是不应被涉足的领域。</p></li></ol><h2 id="深入领域"><a href="#深入领域" class="headerlink" title="深入领域"></a>深入领域</h2><ol><li>整体架构</li></ol><h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>目前web架构，单体应用的并发模型，perfork是典型的多进程思路，一个master进程用于接受并分配请求，fork出的worker进程用于处理实际的请求；而Java的BIO是典型的多线程思路；Go对每个连接启用一个goroutine，是典型的多协程思路。</p><p>perfork的worker进程可以用epoll等同时处理多个请求，这是I/O多路复用。Java的NIO也是类似的思路，本质是用事件机制达到更好的cpu利用率，同时加大负载能力。Nginx，uwsgi都是perfork架构的，由于python的GIL问题，uwsgi的worker一般只有一个线程。当然python还有tornado这种框架，也是用event loop的方式实现i/o多路复用。或者说，协程的方式。</p><p>对于异步编程，业界最流行的是async/await其实就是协程模型，协程本质是用户态下的线程，用户可以自己手动切换上下文进行让渡(await即可）；相比之下，goroutine的调度更加简单，因为他是有栈协程，一旦发生IO阻塞，调度器会自行切换协程，用户在编写代码的时候无需关心这一点（当然也可以自己手动切换，用channel阻塞即可）。在和已有第三方组件的对接上，有栈协程可以吊打promise，因为它就是正常的写阻塞代码就行，而async/await会污染所有相关代码，比较麻烦。</p><p>对于Java，默认的BIO就是传统的多线程模型，比如web服务器就是简单的一个请求一个线程，发生IO事件的时候线程也要阻塞等待，浪费cpu；NIO就是收到事件通知（数据就绪）才开始IO（阻塞），也就是io多路复用；AIO就更牛逼了，系统直接告诉你读完了，调你的回调就行。可惜AIO需要操作系统支持，目前只有Windows上的IOCP可以满足这个条件，所以一般不讨论。</p><p>此外，linux2.6以前i/o多路复用使用select，之后使用epoll. 2.6以前accept存在惊群问题，之后内核只会唤醒等待队列上任一个进程。但是epoll也存在惊群问题，多个worker在事件抵达的时候会被同时唤醒。直到linux3.9加入SO_REUSEPORT特性，允许多个进程监听同一端口，将listen从master进程移入worker进程，这个问题才得到解决。</p><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>经典的MVC结构。旧时代里，asp/jsp/php以及集大成者的ror都是mvc结构，前后端不分离，直接由服务器渲染出页面。ror之所以流行，是因为其约定大于配置的设计大幅度简化了开发流程，SpringBoot相对于SpringMVC其实只是引入了这一思想进行简化。</p><p>自从前端工程化以来，前后端基本分离，后端仅仅提供API接口，这时候的单体应用更加简单。随着服务规模的越发庞大，单体后端承担的职能越来越多，需要对服务进行拆分以减少体积和维护难度。</p><h3 id="SOA和微服务"><a href="#SOA和微服务" class="headerlink" title="SOA和微服务"></a>SOA和微服务</h3><p>微服务其实只是对SOA做了更细粒度的优化。拆分服务引来的问题包括：服务间通信和分布式事务。服务间通信可以通过一个集中的渠道，即所谓的通信总线（API网关）；也可以直接相互通信。使用HTTP的话，直接用DNS和Nginx就可以做API网关了；使用rpc的话，比如grpc也提供了生成API网关的方法。</p><p>微服务还引入了服务熔断、配置分发、服务发现等组件，这些也是需要关注的。</p><h3 id="Spring-Cloud和Service-Mesh"><a href="#Spring-Cloud和Service-Mesh" class="headerlink" title="Spring Cloud和Service Mesh"></a>Spring Cloud和Service Mesh</h3><p>这是两种不同的微服务思路，前者是一个框架，由各种组件构成，应用代码里明确知道这些组件的存在并需要进行处理；后者是外挂式的组件，代码对组件是无感知的，比如连接集群和连接单点都是通过proxy，代码不关心自己连的是什么。一个简单的例子，mysql分库分片可以用proxy来完成，也可以在代码里写死。显然service mesh更符合低耦合的思路，也是微服务真正的未来。</p><ol><li>编程语言</li></ol><p>虽然理论上来说，通用设计语言可以完成的事情都是一致的，不过各语言的特性和历史的沉淀导致了如今的情况是这样的：</p><pre><code>* 前端领域js独占鳌头，es6以后js语言基本完善了；当然强类型的TS也有它的优势；* 后端领域Java占了半壁江山，这不是因为Java多么牛逼，完全是历史的沉淀导致。Java至今没有协程支持（project loom遥遥无期），编写繁琐，很多人讨厌。Go是冉冉上升的另一个明星，简单的语法、快速的开发速度、强有力的并发模型；当然缺点是不支持泛型和繁琐的错误处理。Go2会解决这些问题，希望早点来到。除了这两个以外，其他的语言在服务端领域基本上都会被淘汰，比如Python其实更适合做快速原型，所以更适合非工程人士，当然拿来写个脚本也是极好的；* 大数据领域基本还是Java/Scala的天下，当然基本也支持python了。个人感觉Scala过于复杂了，还是尽量灭了吧；* 高性能领域仍然是C/C++的天下，Rust也开始逐渐普及。不过Rust还是有很多坑，且门槛太高，短时间内个人不再看好；* 客户端领域语言就比较复杂了。Windows还是C#的天下，Android则是Java和Kotlin，苹果的是swift和oc；新兴框架中，flutter的dart也是很重要的；</code></pre><p>总结来说，当前后端开发应该掌握的语言包括：Bash/C/C++/Java/Python和Go，可以学习的语言包括Rust. php/nodejs/ruby的存在完全是历史意义上的，基本没有存在价值。在通信协议上，HTTP1/2/3都会逐渐流行，websocket的效率则更高。grpc是over http2的，这个设计很蛋疼，很多时候不如自己rpc over websocket实用。</p><ol><li>常用框架源码</li></ol><ul><li>python的常用框架：django/flask/tornado/greenlet/celery/sqlalchemy</li><li>java的常用框架：spring/springMVC/springBoot/springCloud/Netty</li><li>go的常用框架：gin/fasthttp</li></ul><ol><li>常用组件源码</li></ol><ul><li>db级别的估计只能看看sqlite了</li><li>mq可以研究一下zeromq、kafka和rabbitmq</li><li>各类分布式相关组件</li></ul><ol start="2"><li>数据库优化</li></ol><ul><li>mysql通过执行计划、慢查询日志进行优化，各类索引添加等</li><li>redis使用优化，事务粒度，数据结构，pipeline等</li><li>es优化，JVM参数，分词，shard设置等</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc4 Rest Api最佳实践</title>
      <link href="2017/07/16/SpringMvc4-Rest-Api%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>2017/07/16/SpringMvc4-Rest-Api%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>因为项目的需求更改，部分API与JSP之间的交互方式由直接渲染改成ajax，所以需要调研SpringMVC在Rest上最佳实践。下面是汇总的内容，参考了网上的一些文章。</p><h2 id="所谓IOC"><a href="#所谓IOC" class="headerlink" title="所谓IOC"></a>所谓IOC</h2><p>Spring最常提起的是AOP和IOC两大作用，他们主要解决了……Emmm，Java语言设计的问题。由于Java是Pure OO语言，很多时候写起来非常繁琐。Spring IOC一个大工厂，在配置文件或者代码里把类注册成Bean（可以指定构造函数的参数和bean的id等），然后框架再把这些Bean注入到<code>@Autowired</code>(按类型注入)，<code>@Resource</code>(按名称)等注解的变量（也可以使用XML配置的方式注入）。</p><p>默认情况下，注册的都是一个单例，spring每次创建新对象时都使用同一个对象。也可以在xml中配置为<code>prototype</code>，这时候就是每次new一个新的对象了。另外spring mvc另外加了两个生命周期：session和request，分别表示为单次请求和session有效期内的对象。使用<code>@Scope</code>修改生命周期（作用域）。</p><p>可以使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注册两个回调方法，在spring实例化Bean（并装配）后回调对象对应的方法。</p><p>一般使用<code>@Component</code>注册bean，<code>@Service</code>, <code>@Controller</code>和<code>@Repository</code>都是其别名。</p><p>此外，还可以使用配置类(<code>@Configuration</code>)代替xml注册bean(<code>@Bean</code>)，在其注解的方法内进行恰当的初始化，并返回一个对象注册为Bean. <code>@Configuration</code>具有<code>@Component</code>的作用，在类里面也可以直接注入。但是如果想要引用其他配置类的Bean，需要使用<code>@import</code>.</p><h2 id="所谓AOP"><a href="#所谓AOP" class="headerlink" title="所谓AOP"></a>所谓AOP</h2><p>可以简单理解为python中的装饰器…由于Java语法不支持装饰器，想要完成类似装饰器的用法，只能通过反射。比如，先声明一个类，完成主要的工作，称为target. 再通过一个类实现<code>org.springframework.aop.MethodBeforeAdvice</code>，其参数中捕获target的参数完成前置工作。最后通过spring的<code>ProxyFactory</code>生成代理工厂，设置target并添加advice，最后用代理工厂生成实例。</p><p>需要注意的是，Java本身的动态代理是基于接口的。对于没有实现任何接口的类，只能通过CGLIB通过继承进行代理，但是后者显然不支持final类。spring在生成对象时会优先选择JDK代理，不行再尝试CGLIB代理。</p><p>当然，除了在代码中使用，也可以用xml配置（实际上Java很多代码都可以通过xml实现，这也是非常惹人生厌的地方）。</p><p>最后，还可以用一种特殊的声明方式：<code>AspectJ</code>。这种方式的好处是，对方法的调用者而言，这种增强是透明的。也就是说，他可以直接用<code>getBean(target)</code>来获取bean实例，然后在调用方法的时候，实际上调用的是代理增强后的方法。也就是说，更加解耦。</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>顾名思义，就是传统的MVC。model层就是一般的POJO(DO)，DAO层一般用mybatis，service层用<code>@Service</code>注册，view层用<code>@RestController</code>注册rest api，用<code>@RequestMapping</code>绑定路由。使用<code>@PathVaribale</code>取url中的参数，用<code>@RequestHeader</code>取header中的数据，用<code>@CookieValue</code>取cookie中的数据，用<code>@RequestBody</code>将json转为object，用<code>@ResponseBody</code>将返回值转为json.</p><p>参数有效性检测一般用<code>JSR-303</code>，使用<code>@NotNull</code>、<code>@Max</code>, <code>@Min</code>, <code>@Length</code>等注解，使用<code>@Valid</code>配合上面的<code>@RequestBody</code>一次性完成检测和转换。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringMVC </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>报表打印(pdf)技术选型</title>
      <link href="2017/07/07/%E6%8A%A5%E8%A1%A8%E6%89%93%E5%8D%B0-pdf-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
      <url>2017/07/07/%E6%8A%A5%E8%A1%A8%E6%89%93%E5%8D%B0-pdf-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>做的外包项目有这个需求：输出PDF格式的单据，稍微调研了一下实现方式，做个汇总。</p><p>首先吐槽一下…做外包还是尽量用成熟技术，下次再做管理平台的需求，还是flask-admin配上JQuery上吧。这次用vue+elementUI，写的倒是挺爽，关键时候找不到组件还要自己造轮子，效率堪忧_(:зゝ∠)_</p><h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>Python这边用ReportLab比较多，稍微研究了一下发现过于复杂。利用xml定义了一套新的语法，叫RML，如果要写的话，先要学习一遍这个东西，成本太高。而且像这种学完基本不怎么用的东西，很快就忘了…不建议使用。</p><p>使用<code>pdfkit</code>，这玩意儿底层调用了<code>wkhtmltopdf</code>，看名字也知道使用html转pdf.</p><p><code>Sphinx</code>本质上是调用$\TeX$来渲染成PDF，依赖项比较复杂，但是控制粒度非常好（毕竟是标准）。</p><h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><ol><li>使用HTML做普通排版，然后调用<code>print.js</code>. 结果：效果很差，样式丢失严重。</li><li>使用<code>jsPDF</code>，不支持中文。</li><li>使用<code>pdfmake</code>，嵌入中文字体后，生成要求的内容，然后就可以直接调用接口，很爽…生成内容直接用JS内置的数据结构就可以完成。使用起来最简单，但是：嵌入字体后资源文件太大（至少2M+），除非使用TTF裁剪，不然浏览影响很大；其次：浏览器兼容性不好，用起来很受限。我本来尝试了一番，最后还是放弃了。不过不得不说的是，如果使用nodejs作为服务器的话，选这个方案很好。</li></ol><h2 id="pdfkit"><a href="#pdfkit" class="headerlink" title="pdfkit"></a>pdfkit</h2><p>最终选型使用pdfkit方案。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>主要依赖<code>wkhtmltopdf</code>这个二进制文件。注意，如果使用的是<code>ubuntu16.04</code>，请不要直接使用ubuntu源里面的该文件，源里面是without qt patched的，需要自己下载安装，<a href="!https://stackoverflow.com/questions/37765698/unable-to-install-wkhtmltopdf-with-patched-qt-in-ubuntu-16-04">具体步骤</a>是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libxrender1 fontconfig xvfb</span><br><span class="line">wget https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.4/wkhtmltox-0.12.4_linux-generic-amd64.tar.xz -P /tmp/</span><br><span class="line"><span class="built_in">cd</span> /opt/</span><br><span class="line">sudo tar xf /tmp/wkhtmltox-0.12.4_linux-generic-amd64.tar.xz</span><br><span class="line">sudo ln -s /opt/wkhtmltox/bin/wkhtmltopdf /usr/<span class="built_in">local</span>/bin/wkhtmltopdf</span><br></pre></td></tr></table></figure><p>然后使用<code>pip install pdfkit</code>安装Python这边的依赖即可。</p><p>如果是Linux服务器，记得安装中文字体，使用文泉驿正黑即可(wqy).</p><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p>几个要点：</p><ol><li>报表的HTML文件最好不要依赖外部css，全部直接内嵌在文件中比较方便；</li><li>HTML需要声明为utf8编码；</li><li>不要对文件使用中文名称；</li><li>渲染的时候有些参数需要设置，如下：</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pdfkit.from_string(page, outfile, options=&#123;</span><br><span class="line">    <span class="string">&#x27;page-size&#x27;</span>: <span class="string">&#x27;A4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;margin-top&#x27;</span>: <span class="string">&#x27;0.75in&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;margin-right&#x27;</span>: <span class="string">&#x27;0.75in&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;margin-left&#x27;</span>: <span class="string">&#x27;0.75in&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;margin-bottom&#x27;</span>: <span class="string">&#x27;0.75in&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;encoding&#x27;</span>: <span class="string">&quot;UTF-8&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;no-outline&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="comment"># &#x27;zoom&#x27;: 1.5,  # when run on mac</span></span><br><span class="line">    <span class="comment"># &#x27;dpi&#x27;: 250</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中<code>0.12.4</code>版本mac上运行的时候，需要设置最后两个参数才能保证字体大小看起来比较正常.</p><p>pdfkit渲染速度超快，非常👍</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle学习笔记</title>
      <link href="2017/07/03/oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2017/07/03/oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>工作以后只用过MySQL，互联网公司也基本都是MySQL了。现在来到了金融公司，不得不进行Oracle的逆入门（毕竟一般人都是Oracle到MySQL）。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Mac下可以使用docker安装，可以参考<a href="http://blog.csdn.net/xp541130126/article/details/70138904">这篇博客</a>.</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>OLTP</code>：在线事务处理系统，强调数据库的内存效率，强调内存各种指标的命中率，强调绑定变量，强调并发操作。用户并发数都很多，但他们只对数据库做很小的操作，数据库侧重于对用户操作的快速响应。<br><code>OLAP</code>：在线分析系统，强调数据分析，强调SQL 执行时长，强调磁盘I/O，强调分区等。主要用户数据分析，对于性能要求没那么高。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>oracle的索引分为B-tree, Bitmap，Hash等，其中位图索引不能被声明为唯一索引，适合候选值很少，且不频繁改动的列。对于高并发系统，不要使用位图索引。</p><p>函数索引：如果查询的时候总是使用某个函数，使用函数索引较多。例如，对于搜索大小写不敏感的字段，查询的时候总会使用<code>Upper</code>函数将其转为大写，但是存放的时候还是用户的原始数据，就可以建立一个函数索引。</p><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>类似MySQL中的shard，不同的是Oracle自带了这个功能。现在基于MySQL的TiDB，以及各类开源的Proxy功能也可以实现透明分区。注意：含有LONG、LONGRAW数据类型的表不能进行分区。</p><p>分区方法：<br>    1. 范围分区：以某个字段的range为标准进行分区，适合以日期分割的历史数据，如交易记录<br>    1. 哈希分区：以某个字段的hash为标准进行分区，分区<br>    1. 列表分区：以某个字段的值为标准进行分区，适合列为有限枚举值的情况<br>    1. 组合分区：以Range分区作为根分区方法，其他分区作为子分区</p><p>Oracle可以自动根据时间建立分区表。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>整体和MySQL类似。使用<code>LOCK TABLE tablename</code>的格式加表锁。</p><p>使用<code>SELECT..FOR UPDATE</code>方式加行级锁。</p><p>当<code>COMMIT</code>或者<code>ROLLBACK</code>后，释放锁。但是<code>ROLLBACK</code>不能释放行级锁。其他的锁主要是供系统使用，是DBA需要掌握的内容，包括如何解决死锁等。</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>MySQL的体系结构非常简单：<code>database</code> ——&gt; <code>table</code>，可以随意创建用户，然后我们通过<code>grant</code>命令赋予用户对库、表的访问权利。</p><p>Oracle的体系稍微麻烦一些，<code>database</code>（数据库实例，又称为SID）还存在，但是下一级不是<code>table</code>，而是<code>tablespace</code>（表空间，一个实例可以有N个表空间。表空间创建时可以指定大小），再下一层是具体的数据文件。如果想要建表，必须创建用户(<code>user</code>)，并为用户指定表空间。这个是物理存储角度下oracle的结构。</p><p>在逻辑概念上，SID下面一层是用户，存储过程、函数、表、序列等等，则是隶属于这个用户的对象(<code>object</code>)。用户创建任意object后，会默认生成一个方案(<code>schema</code>，与用户对应)，在逻辑上，这个用户创建的所有object属于这个schema，即使这些object属于不同的<code>tablespace</code>.</p><p>在权限管理上，user默认有自己schema的所有权限，如果用户想要访问其他schema的object，必须赋权。</p><p>一般流程：创建<code>database</code> -&gt; 创建<code>tablespace</code> -&gt; 创建<code>user</code>（指定默认的<code>tablespace</code>） -&gt; 用户建表。</p><p>有关表的元数据被存放在数据字典中。</p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>默认情况下，oracle会自动创建若干个用户，如<code>sys</code>, <code>system</code>和<code>scott(Tiger)</code>，并提示输入默认密码. 使用<code>sqlplus</code>登入后，使用命令<code>select username,account_status from dba_users;</code>获取所有账户状态，有需要的话可以使用<code>password</code>命令修改密码。</p><p>创建用户：类似MySQL，使用<code>create user root identified by &#39;123456&#39;;</code>，然后使用<code>alter user root account unlock</code>解锁用户。</p><p>权限：分为系统权限（如建表、建库等）和具体的数据权限（增删改查等）。用户可以将自己<code>schema</code>下的object授权给其他用户，或者使用管理员账户进行授权。语句格式大致为<code>grant select on emp to root with grant option</code>.</p><p>收回权限：<code>revoke select on emp from root</code>.</p><p>删除用户： <code>drop user root cascade</code>，删除用户会导致用户名下所有的数据都被删除，谨慎使用。</p><p>可以使用<code>profile</code>进行安全策略的限制（输错密码次数、密码过期时间、密码强度限制等等）。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们先通过<code>sys</code>等系统dba账户登入，创建项目需要的管理员账户，然后赋予<code>connect</code>, <code>resource</code>和<code>dba</code>的权利。然后使用这个账户登入，创建项目需要的表。</p><p>注意：oracle命令默认是<strong>区分</strong>大小写的，但是如果不加双引号的话，所有的字段、命令都会被转化为大写。一般情况下，使用单引号来引用字符串，如果字符串里面有单引号，需要使用两个单引号转义。如果用了系统关键字（或者空格等符号），则使用双引号包围字符串。</p><p>使用上和MySQL有很多细节的不同，主要包括：</p><ol><li>自增。需要先<code>create sequence myseq increment by 1 start with 1000</code>创建一个自增序列，然后在插入的时候使用<code>myseq.nextval</code>来取得自增的值（有点类似mongo）；</li><li>外部脚本。使用<code>@ xxx.sql</code>导入；</li><li>表达式。使用<code>select 3 * 2 from dual</code>;</li><li>系统时间。使用<code>select sysdate from dual</code>，具体格式可以使用<code>select to_char(sysdate,&#39;yyyy-mm-dd&#39;) from dual;</code>;</li><li>修改表名。 <code>rename xx to yy</code>;</li><li>分页。Oracle的分页做的很挫…最好使用id分页，如果要用数据库自身的分页，需要使用嵌套子查询。oracle对每一列有<code>rownum</code>和<code>rowid</code>两个虚列，前者是结果集的序列（从1开始），后者是物理上每一行的id。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> A.<span class="operator">*</span>, ROWNUM RN</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> TABLE_NAME <span class="keyword">ORDER</span> <span class="keyword">BY</span> x) A</span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> <span class="number">40</span></span><br><span class="line">) T</span><br><span class="line"><span class="keyword">WHERE</span> RN <span class="operator">&gt;=</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p>这里最里面那一层是真正的SQL语句，进行全表搜索。然后<code>ROWNUM&lt;=40</code>表示只要前四十行，最外层表示在这前40行里面只要第二页（假设每页20个）的.<br>需要注意：</p><ol><li><code>rownum</code>是自动生成的，所以内层的<code>rownum</code>只能用<code>&lt;=</code>，而绝对不能用<code>&gt;=10</code>这种，因为生成的列永远从1开始；</li><li>如果有<code>order by</code>字段，必须有三层查询，最内层做排序，次外层选择前N条，最外层做偏移量</li></ol><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p>oracle建表有很多可选参数，其中：</p><pre><code>pctfree：用于指定BLOCK中必需保留的最小空间的比例。pctused：为一个百分比数值，当BLOCK中已经使用的空间降低到该数值以下时，该BLOCK才是可用的，达到或是超过这个数值的BLOCK是不可用的。一般在控制具有独立segment结构的对象时，使用这两个参数来控制BLOCK的存储管理。initrans：指定可以并发操作该表的事务的数目。</code></pre><p>如果你预计只有很少的更新操作会增加行的大小，则可将PCTFREE设置为较低的值（如5或者10），使得ORACLE填满每个块的更多的空间。但是，如果你预计更新操作将会经常增加行的大小，则将PCTFREE设置为较高的值（如20或30），使得ORACLE为已有行的更新操作保留更多的块空间；否则，将出现行链。</p><p>如果你预计很少有删除操作，则可设置PCTUSED为较高的值（如60），当偶然的删除操作发生时，使数据块弹出可用清单。但是，如果你预计将PCTUSED 设置为较低的值（如40），使ORACLE不常产生块在表的可用空间中移进或移出的开销。</p><h2 id="PL-SQL"><a href="#PL-SQL" class="headerlink" title="PL/SQL"></a>PL/SQL</h2><p>PL/SQL是针对Oracle特有的SQL语句，不可移植。</p><p>基本单位：块(block).</p><p>语句：声明(declare)，执行(begin…end)，异常处理(exception..end)</p><p>运算符：注意<code>||</code>是字符串连接，其他和MySQL差不多</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>命名：<code>DECLARE test VARCHAR(20)</code>，命名规范：</p><pre><code>至多有30个字符不能是保留字必须以字母开头不允许和数据库中表的列名相同不可包括$,_和数字以外的字符</code></pre><p>变量定义（类似go语言）： <code>v_number NUMBER(2) NOT NULL := 20</code>，常量使用<code>CONSTANT</code>. 可以在声明时指定其他变量的类型作为其类型（类似泛型），格式是<code>var%TYPE</code></p><p>基本数据类型就是JDBC中的那些，常用的是Number和varchar2, boolean, date这几个。数组类型使用<code>VARRAY(size) OF element_type [NOT NULL]</code>的形式，使用<code>(n)</code>进行下标访问</p><p>复合数据类型:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TYPE type_name <span class="keyword">IS</span> RECORD(</span><br><span class="line">    fieldname fieldtype,</span><br><span class="line">    fieldname fieldtype</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>显然这玩意儿类似C语言中的<code>struct</code>. 也可以直接用<code>table%RAWTYPE</code>声明一个同表结构的记录。甚至可以直接声明表类型，类似一个数据，格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">declare</span></span><br><span class="line">            type ename_table_type <span class="keyword">is</span> <span class="keyword">table</span> <span class="keyword">of</span> emp.ename<span class="operator">%</span>type</span><br><span class="line">            index <span class="keyword">by</span> binary_integer;</span><br><span class="line">ename_table ename_table_type;</span><br></pre></td></tr></table></figure><p>可以使用<code>ename_table(-1)</code>进行下标访问，使用<code>.FIRST</code>和<code>.LAST</code>访问第一行和最后一行。</p><p>除了普通变量外，还有替换变量。主要用于人机交互，<code>&amp;</code>前缀表示提示用户输入，且仅此次有效，<code>&amp;&amp;</code>前缀则表示永久有效，仅需要输入一次。</p><p>变量的可见范围，在<code>DECLARE</code>中声明的变量，在后面的<code>BEGIN</code>块中可见。</p><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>游标是查询结果集的指针。<br>显式使用语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CURSOR</span> cursor_name[(<span class="keyword">parameter</span>[, <span class="keyword">parameter</span>]…)]</span><br><span class="line">       [<span class="keyword">RETURN</span> datatype]</span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line">    select_statement;</span><br></pre></td></tr></table></figure><p>游标里面显然不能用<code>SELECT..INTO..</code>，而是要手动遍历。使用<code>OPEN cursor_name</code>打开游标，执行语句。<br>使用<code>FETCH cursor_name INTO xxx</code>取出游标对应的行，<code>FETCH</code>以后，游标会自动指向下一行。游标不能回退，使用完毕后要记得<code>CLOSE</code>掉。</p><p>可以通过参数类型<code>sys_refcursor</code>传递游标。接受的函数/存储过程必须使用<code>OPEN xxx FOR SELECT</code>打开游标进行赋值。</p><p>游标属性包括：</p><pre><code>Cursor_name%FOUND     布尔型属性，当最近一次提取游标操作FETCH成功则为 TRUE,否则为FALSE；Cursor_name%NOTFOUND   布尔型属性，与%FOUND相反；Cursor_name%ISOPEN     布尔型属性，当游标已打开时返回 TRUE；Cursor_name%ROWCOUNT   数字型属性，返回已从游标中读取的记录数。</code></pre><p>可以直接使用<code>FOR var IN CURSOR LOOP</code>进行循环取值。</p><p>除了显式使用以外，普通的update、insert和delete语句也会自动生成隐式游标，可以用<code>SQL</code>查询上面的属性。</p><p>使用<code>SELECT FOR UPDATE [NOWAIT]</code>加悲观锁，如果使用 FOR UPDATE 声明游标，则可在DELETE和UPDATE 语句中使用<code>WHERE CURRENT OF cursor_name</code>子句，修改或删除游标结果集合当前行对应的数据库表中的数据行。</p><p>除了静态游标外，还可以使用游标变量，形式是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TYPE ref_type_name <span class="keyword">IS</span> <span class="keyword">REF</span> <span class="keyword">CURSOR</span></span><br><span class="line"> [ <span class="keyword">RETURN</span> return_type];</span><br></pre></td></tr></table></figure><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>条件语句：<code>IF..THEN..ELSIF..ELSE..ENDIF</code>，或者<code>CASE..WHEN..THEN..ELSE..END</code></p><p>循环语句：<code>LOOP..EXIT WHEN..END LOOP</code>, 或者<code>FOR..IN..LOOP..END LOOP</code>, 或者<code>WHILE..LOOP..END LOOP</code></p><p>范围循环使用<code>..</code>连接上下限.</p><p>使用<code>GOTO</code>跳转到label, label使用<code>&lt;&lt;&gt;&gt;</code>标示起来</p><h3 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h3><p>有点类似C/C++，先声明包头，然后创建包体。包名自动被注册到<code>schema</code>下，可以直接调用。</p><p>包是pl/sql实现抽象的主要途径。创建包的语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] PACKAGE package_name</span><br><span class="line">  &#123;IS | AS&#125;</span><br><span class="line">  [公有游标定义[公有游标定义]…]</span><br><span class="line">  [公有函数定义[公有函数定义]…]</span><br><span class="line">  [公有过程定义[公有过程定义]…]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  执行部分(初始化部分)</span><br><span class="line"><span class="keyword">END</span> package_name;</span><br></pre></td></tr></table></figure><p>上面类似C/C++中的头文件，导出了可供外部调用的函数和过程、游标。</p><p>包体则对应具体的实现，其语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE PACKAGE BODY pkg_name</span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line">[私有内容定义]</span><br><span class="line">[公有内容定义]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>这样，就可以在其他函数/存储过程里面通过<code>package_name.function_name</code>来调用包内的函数/过程了。</p><h3 id="函数-function-amp-存储过程-Proceduce"><a href="#函数-function-amp-存储过程-Proceduce" class="headerlink" title="函数(function) &amp; 存储过程(Proceduce)"></a>函数(function) &amp; 存储过程(Proceduce)</h3><p>调用函数可以用命名传递方式，即<code>func_name(1, param2 =&gt; 1)</code>，同时声明的函数参数可以用<code>DEFAULT</code>关键字指定默认值。</p><p>类似函数，除了无返回值，定义语法：</p><pre><code> CREATE ［OR REPLACE］PROCEDURE procedure_name [(argument_name [IN | OUT | IN OUT] argument_type [DEFAULT value])] AS | IS BEGIN     procedure_body; END [procedure_name];</code></pre><p>其中:</p><pre><code>IN：表示是一个输入参数，可以指定缺省值。如省略参数类型，则缺省为in类型OUT：表示是一个输出参数IN OUT：既可以作为一个输入参数，也可以作为一个输出参数来输出结果</code></pre><p>调用语法：</p><pre><code>EXECUTE ｜CALL procedure_name [(argument_list)]</code></pre><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>使用<code>dbms_job.submit</code>可以异步调用存储过程</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>预定义了以下异常：</p><pre><code>NO_DATA_FOUND          SELECT ... INTO ... 时，没有找到数据DUL_VAL_ON_INDEX       试图在一个有惟一性约束的列上存储重复值CURSOR_ALREADY_OPEN    试图打开一个已经打开的游标TOO_MANY_ROWS          SELECT ... INTO ... 时，查询的结果是多值ZERO_DIVIDE            零被整除</code></pre><p>当然也可以自己声明<code>EXCEPTION</code>, 在程序中<code>RAISE</code>出来。处理语法是<code>BEGIN..EXCEPTION..WHEN..THEN..WHEN OTHERS THEN...END</code></p><p>使用<code>SQLCODE</code>和<code>SQLERRM</code>分别取得错误码和错误信息，还可以使用<code>RAISE_APPLICATION_ERROR(error_number,error_message,[keep_errors] );</code>将异常传递到客户端</p>]]></content>
      
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven和gradle一些选项</title>
      <link href="2017/06/26/maven%E5%92%8Cgradle%E4%B8%80%E4%BA%9B%E9%80%89%E9%A1%B9/"/>
      <url>2017/06/26/maven%E5%92%8Cgradle%E4%B8%80%E4%BA%9B%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>Java的包依赖系统简单粗暴，就是直接下载jar包，经历了<code>Ant</code> -&gt; <code>Maven</code> -&gt; <code>Gradle</code>这几个阶段，目前的项目里面还是Maven比较多，后续我会试着迁到Gradle上。</p><p>如果用一句话来表明区别的话：Gradle的配置文件是一种DSL，而Maven则使用XML，表达能力不可同日而语。</p><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>Maven在多个模块依赖同一个模块时，需要手动处理版本冲突问题（将公共依赖手动排除），而Gradle会尝试自动解决该问题（使用公共依赖的最新版本）。</p><h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h2><p>类似<code>npm</code>中的概念：这个包是啥时候被需要。显然有些包只是编译的时候需求，运行的时候不再被需要，因为Maven中的<code>scope</code>分为以下几种：</p><ul><li>compile. 默认范围，会被打包。</li><li>provided. 这个概念比较模糊，意思是这东西由外部容器提供，不需要自己打包进去。</li><li>runtime. 只有运行和测试系统的时候需要，编译的时候不需要。一个典型的例子就是<code>jdbc</code>的接口API在编译时必须要可用，但是具体实现可以只在运行时插入。</li><li>test. 只被测试依赖。Maven有标准的测试流程。</li><li>system. 系统范围，jar包被放在本地，无须从仓库中寻找。当然一般不推荐使用。</li></ul><h2 id="Idea的使用"><a href="#Idea的使用" class="headerlink" title="Idea的使用"></a>Idea的使用</h2><p>Idea中可以在<code>Project Structure</code>里面直接修改配置，会自动生成/修改对应的Pom文件，主要在<code>modules/dependencies</code>里面改。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash on Ubuntu on Windows下载过慢问题的简单解决</title>
      <link href="2017/06/14/Bash-on-Ubuntu-on-Windows%E4%B8%8B%E8%BD%BD%E8%BF%87%E6%85%A2%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3/"/>
      <url>2017/06/14/Bash-on-Ubuntu-on-Windows%E4%B8%8B%E8%BD%BD%E8%BF%87%E6%85%A2%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>经验证，最有效的方法是修改系统DNS为<code>4.2.2.1</code>，其他什么不用做…</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jeesite代码解析</title>
      <link href="2017/06/13/jeesite%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2017/06/13/jeesite%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>现在某个项目需要用到Java Web来写控制台，考虑到外包人员的能力，这边只能用传统的JSP技术来写了… 技术选项上用了jeesite这个成熟框架。该框架使用了最传统的SpringMVC + MyBatis，然后装了一堆框架，我会根据需求删掉其中大部分内容但是保留其基础框架。</p><h2 id="基础知识补充"><a href="#基础知识补充" class="headerlink" title="基础知识补充"></a>基础知识补充</h2><p>常见Java注解：</p><p>四个元注解包括：</p><ul><li><code>Target</code>: 标示注解使用的位置；</li><li><code>Retention</code>: 标示在什么级别保留注解信息；</li><li><code>Documented</code>: 标示要讲注解记录在JavaDoc中；</li><li><code>Inherited</code>: 允许子类继承父类的注解；</li></ul><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>Java Web有一套成熟的抽象体系，自上到下分别是<code>Controller</code>(接入层) -&gt; <code>Service</code>(服务层) -&gt; <code>Entity</code>(数据实体层) -&gt; <code>DAO</code>(数据操作层)。</p><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>这里<code>DAO</code>底层是一个泛型接口<code>CrudDao&lt;T&gt;</code>，这里定义了一些常见的接口（增删改查）。</p><p>对于每个具体的表，定义了接口，并使用<code>MyBatisDao</code>注解，通过查看代码可以知道，这是一个自定义注解，且是一个<code>Component</code>元注解。在<code>spring-context.xml</code>中有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.thinkgem.jeesite&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里表示扫描除了<code>Controller</code>层以外的其他组件。<code>MyBatis</code>的配置为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.thinkgem.jeesite&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesSuperType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.thinkgem.jeesite.common.persistence.BaseEntity&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:/mappings/**/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:/mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>dataSource</code>是数据源，这里配置为MySQL的连接池，用的是<code>Druid</code>这个阿里的开源库（这里是单库）。<code>typeAliasesPackage</code>是映射的起始路径包，<code>typeAliasesSuperType</code>是实体类的父类，<code>mapper</code>的注释在<code>mappings</code>下面，组件自身的配置在<code>mybatis-config.xml</code>里。</p><p>在<code>resources/mappings</code>下面，定义了对应路径映射的model，这里的数据可能是代码生成器生成的（手动写的话工作量有点大啊…），以及各种<code>DAO</code>中定义接口的具体实现。这里的语法本质上是拼装sql…</p><p>这里有个问题，idea对MyBatis的支持不太好，需要自己找插件（但是收费），也有一些免费但是不太好用的。</p><h4 id="MyBatis的SQL语法"><a href="#MyBatis的SQL语法" class="headerlink" title="MyBatis的SQL语法"></a>MyBatis的SQL语法</h4><p>官方教程<a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html">在此</a></p><p>用例子说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//`User` is Entity</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">CurdDao</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">sql</span> id<span class="operator">=</span>&quot;userColumns&quot;<span class="operator">&gt;</span>  # <span class="keyword">sql</span>片段</span><br><span class="line">    a.id,</span><br><span class="line">    a.company_id <span class="keyword">AS</span> &quot;company.id&quot;,   # compony是`<span class="keyword">User</span>`的一个成员</span><br><span class="line">    a.office_id <span class="keyword">AS</span> &quot;office.id&quot;,</span><br><span class="line">    a.login_name,</span><br><span class="line">    a.password,</span><br><span class="line">    a.create_by <span class="keyword">AS</span> &quot;createBy.id&quot;,</span><br><span class="line">    a.create_date,</span><br><span class="line">    a.update_by <span class="keyword">AS</span> &quot;updateBy.id&quot;,</span><br><span class="line">    a.update_date,</span><br><span class="line">    a.del_flag,</span><br><span class="line">    c.name <span class="keyword">AS</span> &quot;company.name&quot;,</span><br><span class="line">    c.parent_id <span class="keyword">AS</span> &quot;company.parent.id&quot;,</span><br><span class="line">    c.parent_ids <span class="keyword">AS</span> &quot;company.parentIds&quot;,</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">sql</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">sql</span> id<span class="operator">=</span>&quot;userJoins&quot;<span class="operator">&gt;</span>  # <span class="keyword">sql</span>片段</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> sys_office c <span class="keyword">ON</span> c.id <span class="operator">=</span> a.company_id</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">sql</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;get&quot; resultType<span class="operator">=</span>&quot;User&quot; parameterType<span class="operator">=</span>&quot;string&quot;<span class="operator">&gt;</span>  # id对应Dao中方法的名字，resultType是</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;userColumns&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> sys_user a</span><br><span class="line"><span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;userJoins&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">WHERE a.id = #&#123;id&#125;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>熟悉了很快就能上手，一般情况下，自动映射可以处理绝大多数问题，只有特别复杂的结果集需要自定义<code>resultMap</code>.</p><h3 id="ehcache"><a href="#ehcache" class="headerlink" title="ehcache"></a>ehcache</h3><p>Java中常用的cache，支持单机也支持分布式，但是分布式配置较为复杂，一般还是使用Redis居多。</p><p>这里ehcache的使用看得我一脸懵逼，好像直接缓存了POJO类，然后取出来后直接强制转换回来就可以了。理论上这不对啊，缓存肯定要序列化的…然后仔细研究了一下Java的序列化（类似Python的<code>pickle</code>）。</p><p>结果发现只要标记了<code>Serializable</code>的类都可以被序列化，但是如果类被修改了，就要注意是不是修改<code>serialVersionUID</code>了。必须要修改（一般是递增）该ID的情况有（来自Java官方网站）：</p><ul><li>删除了成员</li><li>修改了类的继承层次</li><li>将一个非静态成员改成静态，或者将一个非忽略成员改成忽略(transient)</li><li>修了了原始类型成员的类型声明</li><li>修改了<code>writeObject</code>或者<code>readObject</code>方法</li><li>将类从<code>Serializable</code>改为<code>Externalizable</code>，或者移除了标记</li><li>将类改为枚举类型</li></ul><p>但是以下情况无须修改：</p><ul><li>增加成员：新增成员会使用默认值</li><li>增加类：也是使用默认值</li><li>移除类</li><li>增加<code>writeObject/readObject</code>方法</li><li>移除<code>writeObject/readObject</code>方法</li><li>增加<code>java.io.Serializable</code></li><li>修改成员的修饰符</li><li>将成员由静态改为非静态，或者忽略改成非忽略</li></ul><p>其实这些并不是很好记忆…所以更好的使用经验是，不要试图序列化整个类存在缓存中，而是只缓存一些必须的变量，然后用这些变量构造对象，变量使用Java标准库内置的数据结构，这些数据结构默认都是可序列化的。</p><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>这一层本质上是db上对应表的model，但是和Python不一样，这里和表不是一一对应的，而是一个整合的数据集。</p><p>换句话说，每个<code>Entity</code>可能对应很多个表，这里的抽象思路和Python不一样。Entity是一个POJO，而不是继承某个类而得来。当然我还是更喜欢Python的抽象思路，Model原子性和Table保持一致，可以自由组合。</p><p>项目抽象了<code>BaseEntity</code>，在此基础上又总结了集中常见的数据模型。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>使用Spring的事务管理，最后只要在方法上使用<code>@Transactional</code>注解就可以使用一个事务式的方法（只能在<code>public</code>方法上使用），这个注解只会在被外部调用时触发。</p><p>关于事务方法和非事务方法之间的相互调用，参考<a href="https://stackoverflow.com/questions/6222600/transactional-method-calling-another-method-without-transactional-anotation">stackoverflow</a></p><p><code>@Transactional</code> 默认只对 unchecked exception 异常进行回滚操作，checked、unchecked 异常使用不当造成事务无效，抛出的异常应该是<code>RuntimeException</code>的子类。</p><h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><p>Service层处理实际的业务逻辑，这里抽象了基类<code>BaseService</code>里面定义了方法用来鉴权；<br>CurdService层是简单增删改查的服务，这是一个泛型类，泛型参数是<code>Dao</code>和<code>Entity</code>；<br>对于树形数据结构，还特别定义了<code>TreeService</code>对应了<code>TreeDao</code>和<code>TreeEntity</code>；</p><h2 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h2><ol><li>直接运行项目，会自动打开浏览器，跳转到登录页。这个应该是在哪里配置的，暂时不明；</li><li>首页会匹配到<code>modules/sys/web/LoginController</code>里面的<code>index</code>方法；</li><li>该类继承自<code>BaseController</code>，这里定义了<code>logger</code>, <code>adminPath</code>, <code>frontPath</code>和<code>urlSuffix</code>，这些变量是从bean里面注入的. 同时定义了一些通用的方法；</li><li>所以index方法中的<code>RequestMapping</code>, <code>$&#123;adminPath&#125;</code>会被渲染为<code>a</code>，另外这个注释来自SpringMVC；</li><li><code>RequiresPermissions</code>是使用<code>Apache shiro</code>进行鉴权，详见鉴权流程；</li><li>如果用户没有登陆，会跳转到<code>a/login</code>，后者最终跳转到<code>modules/sys/sysLogin</code>；</li><li>如果用户已经登陆，会跳转到<code>modules/sys/sysIndex</code>，即网站的首页；</li><li>如果是mobile登陆，这里不再使用服务端渲染，还是返回了一个Json串；</li></ol><p>其他的模块也类似，入口都在模块下的<code>web</code>包里面。<code>Controller</code>层调用<code>Service</code>层（一般是Autowired注入的），<code>Controller</code>有个共同基类<code>BaseController</code>，这是一个POJO，里面定义了一些公用的方法，如参数鉴定、view渲染和异常处理。</p><p>参数鉴定用的是<code>JSR303</code>里面规定的的一些注解，这些约束被写在<code>Entity</code>中。</p><h2 id="Controller与JSP的交互"><a href="#Controller与JSP的交互" class="headerlink" title="Controller与JSP的交互"></a>Controller与JSP的交互</h2><p><code>Controller</code>与<code>JSP</code>这一层的联系通过大量注释和隐含条件完成。</p><p>由于JSP是很集成化的东西，所以前端表格直接和后端Entity是对应的，前端用JQuery直接修改DOM元素做渲染，用户输入——JQuery修改界面——用户提交——后端从表格中取出模型形成数据——处理完毕返回新数据构成的页面。</p><p>后端使用<code>ModelAttribute</code>注入模型，前端可以直接引用模型里面的元素。前端使用的后端模型中的元素作为querystring或者post中的元素，后端也可以声明为对应方法的参数。</p><h2 id="鉴权流程"><a href="#鉴权流程" class="headerlink" title="鉴权流程"></a>鉴权流程</h2><p>使用了组件<code>Apache Shiro</code>，这个东西定义了通用的鉴权模型，参考<a href="http://howiefh.github.io/2015/05/12/shiro-note/">这篇blog</a>。</p><p>几个概念：</p><ol><li><code>Authentication</code>，一般指登陆，验证用户名和密码；</li><li><code>Authorization</code>，授权，验证权限；</li><li><code>Subject</code>，被管理的主体，一般指的是用户；</li><li><code>SecurityManager</code>，实际鉴权者，<code>Subject</code>被绑定到<code>SecurityManager</code>；</li><li><code>Realm</code>，领域，类似于DAO，最终落地的鉴权者。<code>Realm</code>是Plugable的，开发者主要负责实现这一块；</li><li><code>Authenticator</code>，认证器。包含一些常见的、默认的鉴权实现（如密码、SSO等）；</li><li><code>Authrizer</code>，授权器。包含一些常见的权限、角色设计（一个用户多个角色，权限是以<code>:</code>分割的字符串）；</li><li><code>SessionManager</code>，可配置的Session管理器，可以通过简单的配置放在Redis中；</li><li><code>CacheManager</code>，系统缓存管理器，也可以简单的配置到Redis中；</li><li><code>Principal</code>，身份，一般是用户名、邮箱；</li><li><code>Credential</code>，凭证，一般是密码；</li></ol><p>使用流程如下：</p><ol><li>定义配置文件，本项目中与spring结合，为<code>spring-context-shiro.xml</code>；</li><li>大部分都是标准配置，注释掉的部分可以用redis作为sessionManager和CacheManager。在<code>SecurityManager</code>里面配置了<code>realm</code>，即为自己实现的<code>SystemAuthorizingRealm</code>；</li><li>该类继承自<code>AuthorizingRealm</code>。<code>doGetAuthenticationInfo</code>是登陆验证，验证账号密码；<code>doGetAuthorizationInfo</code>是权限验证，这里也是用了自带的<code>SimpleAuthorizationInfo</code>；</li><li>权限这里，根据用户角色，获取其前端菜单列表，每个菜单元素对应着一个权限字符串（如<code>sys:role:view</code>对应查看角色列表，<code>sys:role:create</code>对应创建新角色等）；</li><li>由于用户角色、权限等信息需要在所有页面使用，所以这里注册了一个单例<code>SystemService</code>，来随时获取这些信息；</li><li>在需要验证权限的地方，调用<code>hasRole</code>或者<code>isPermitted</code>等函数来验证权利（或者使用注解）.JSP里面也有相关的语法。</li></ol><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><p>这里采用了一个设计，所有常量被存放在数据库中，而不是在代码中使用枚举。<code>sys_dict</code>表中根据<code>type</code>存放了所有枚举值，所以枚举的<code>value</code>类型被统一为<code>String</code>。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>分页。这里分页有明显的性能问题，直接查找了所有数据，然后在内存中分页（以及排序），在数据集非常大的时候这是不可取的。应该在<code>BaseEntity</code>里面存入<code>limit</code>, <code>offset</code>和<code>orderBy</code>，然后在sql里面根据这些参数来写sql；</li><li>id. ID应该用自增主键，主要是出于性能考虑。MySQL的uuid主键性能很差，这是由innoDB底层实现决定的。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
            <tag> jeesite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="2017/06/13/hello-world/"/>
      <url>2017/06/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>最后再折腾一次，把所有的blog迁移到GitHub Pages，以后再也不折腾了ORZ</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java web基础学习</title>
      <link href="2017/06/12/java%20web%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>2017/06/12/java%20web%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>做java项目有两个月了，一直忙着修复业务上的东西，java的web基础这块没怎么看。最近在coding时涉及底层较多，必须抽时间看看底层的一些东西了。</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h3><p>java的web底层主要是指servlet和filter，前者替代了普通的CGI（for C/C++，perl），相当于python中的wsgi。这一块主要的类：<br><img src="http://img.my.csdn.net/uploads/201301/04/1357284746_5560.png" alt="servlet class UML"></p><p>这是servlet相关的类，这是一个请求——应答模型，不涉及具体协议。和http相关的主要是下面这些：<br><img src="http://img.my.csdn.net/uploads/201301/05/1357367807_2250.png" alt="servlet http class UML"><br>和<code>Servlet</code>关系很大的是web.xml文件，所有的servlet必须在web.xml中声明、配置初始化参数，做url映射。url映射采用最大前缀匹配，如果两个完全一样，用靠前声明的那个匹配。类似django中的<code>settings.py</code>.</p><p>ServletFilter是Servlet的一种extension，用于在Servlet被调用之前检查Request对象，并修改Request Header和Request内容；以及在Servlet被调用之后检查Response对象，修改Response Header和Response的内容（一种中间件）。Filter也需要配置url mapping，其调用顺序是其在web.xml中声明的顺序，习惯上filter被声明在所有servlet之前。</p><p>Servlet异常处理，可以配置<code>&lt;error-page&gt;</code>将status-code导向不同的html页面，或者干脆导向一个自定义类，然后在该错误处理类中使用<code>Integer status_code=(Integer)req.getAttribute(&quot;javax.servlet.error.status_code&quot;);</code>得到错误码，然后根据错误码做处理；而java程序中的异常可以通过try…catch捕获，然后forword一个专门的处理类中。</p><p>session id应该只对当前servlet有效，虽然确实有方法使其跨servlet共享，但是不推荐使用。</p><h3 id="代码书写"><a href="#代码书写" class="headerlink" title="代码书写"></a>代码书写</h3><p>首先实现一个servlet（继承<code>HttpServlet</code>），实现<code>init</code>和<code>service</code>方法，在后者中实现web服务的逻辑处理。然后在<code>web.xml</code>中注册该servlet的类，将之与url相关联。</p><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>外层web服务器（Tomcat等）在收到http请求后，根据url路径找到对应的servlet，实例化（如果不存在）。</p><p>实例化的servlet对象处理请求，并返回响应（或者转发给其他servlet）.</p><p>请求全部处理完毕后，Tomcat会根据需求销毁servlet（正常运行的服务不会销毁）。Java是多线程模型，并发的请求会使用新的线程来处理。</p><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>类似其他语言中的模板，不过模板一般是获得结果，然后进行渲染。JSP本质是一种特殊的Servlet，所以在接收到请求后，JSP文件会被编译为Java的字节码。</p><p>语法：</p><ol><li><code>&lt;%...%&gt;</code>：Java代码片段，用于定义0~N条Java语句，方法中能够写什么，这里面就能放什么；</li><li><code>&lt;%=  %&gt;</code>：Java 表达式，用于输出一条表达式或变量的结果。<code>response.getWriter().print()</code> 方法中能够写什么，这里面就能够写什么；</li><li><code>&lt;%! … %&gt;</code> ：声明，用来创建类的成员变量和成员方法，Java类中能够写什么，这里面就能够写什么，要注意的是，里面的内容不在<code>_jspService()</code> 方法之内，直接被JSP转化后的类体包含。</li></ol><p>在<code>&lt;%  %&gt;</code> 和 <code>&lt;%= %&gt;</code> 脚本中定义的Java 代码都会放在JSP 的 <code>_jspService()</code> 方法中（实际上就是Servlet中的<code>service</code> 方法），而<code>&lt;%! %&gt;</code> 脚本中定义的却会放到生成类的成员位置的。</p><h2 id="Spring3"><a href="#Spring3" class="headerlink" title="Spring3"></a>Spring3</h2><p>spring存在的意义是因为Java不够灵活。</p><ol><li>Spring通过xml来增强Java的灵活性，减少因配置更改导致的重新编译需求；</li><li>Spring支持面向切面编程（也就是Python中的装饰器），方便进行拦截；</li><li>同样，通过AOP，可以管理数据库连接，以及事务回滚等等；</li><li>此外，Spring还提供了一系列工具包，如果JDBC连接；SpringMVC的web框架；</li><li>良好的可扩展性，可以方便的与其他JavaEE框架结合使用；</li></ol><p>简单来说，Spring通过XML定义了一套新的语言，该语言能被无缝整合到Java程序中。</p><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>所谓的依赖反转。</p><p>按着HTTP的请求应答模型，正常情况下，Tomcat等web服务器就请求直接塞给servlet，获得应答返回给客户端。但是Spring为了增强灵活性，在这里加了一层，也即是所谓的“容器”。</p><p>这个容器（BeanFactory）本质上就是对象的托管工厂，根据请求容器创建对象（Bean），并进行一系列的注入等操作，并进行对象的生命周期管理。对于web而言显然Servlet被包含在这些Bean中。</p><p>初始化的流程是可配置化的，默认在一系列xml配置文件中。</p><h3 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h3><p>Spring是按着接口进行类的管理的，一般情况下，需要有一个接口类（假设叫<code>HelloApi</code>）。</p><p>一个实现了个该接口的普通类（假设就叫<code>HelloImpl</code>）。</p><p>在spring对应的xml中配置bean，大致如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.javass.spring.chapter2.helloworld.HelloImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>id</code>是组件的名字，最后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Test</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">//1、读取配置文件实例化一个IoC容器</span></span><br><span class="line">             ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;helloworld.xml&quot;</span>);</span><br><span class="line">             <span class="comment">//2、从容器中获取Bean，注意此处完全“面向接口编程，而不是面向实现”</span></span><br><span class="line">              HelloApi helloApi = context.getBean(<span class="string">&quot;hello&quot;</span>, HelloApi.class);</span><br><span class="line">              <span class="comment">//3、执行业务逻辑</span></span><br><span class="line">              helloApi.sayHello();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用容器读取<code>xml</code>配置文件，然后通过名字查找Bean，利用反射创建对应的实例（生成的是接口的实例）。</p><p>上文中的<code>ApplicationContext</code>是<code>BeanFactory</code>的子类，Spring针对不同的场景内置了大量不同的Bean工厂，以适应不同的场景。</p><p>如果构造器有参数，可以在xml的<code>bean</code>的结点中放入<code>constructor</code>结点，进行参数注入。</p><p>除了普通类以外，Bean还可以作用于静态/普通工厂类。只是xml中的配置文件项略有不同而已。</p><p>在初始化（生成对象）后，还可以通过<code>property</code>结点注入属性（setter）.</p><p>如果想要使用<code>Bean</code>技术，必须遵从其命名规范，不然找不到对应的方法/对象。如下：</p><ul><li>该类必须是一个普通Java类（POJO），不受Java规范外其他规范约束；</li><li>该类必须要有公共的无参构造器，如public HelloImpl4() {}；</li><li>属性为private访问级别，不建议public，如private String message;</li><li>属性必要时通过一组setter（修改器）和getter（访问器）方法来访问；</li><li>setter方法，以“set” 开头，后跟首字母大写的属性名，如<code>setMesssage</code>,简单属性一般只有一个方法参数，方法返回值通常为<code>void</code>;</li><li>getter方法，一般属性以“get”开头，对于boolean类型一般以“is”开头，后跟首字母大写的属性名，如<code>getMesssage</code>，<code>isOk</code>；</li><li>还有一些其他特殊情况，比如属性有连续两个大写字母开头，如“URL”,则setter/getter方法为：<code>setURL</code>和<code>getURL</code>，其他一些特殊情况请参看“Java Bean”命名规范。</li></ul><p>得益于xml的强大，可以注入的数据类型，除了基本类型外， 还有<code>list</code>、<code>set</code>和<code>map</code>等集合类，甚至可以引用其他Bean.</p><h3 id="bean-xml语法"><a href="#bean-xml语法" class="headerlink" title="bean xml语法"></a>bean xml语法</h3><ol><li>首先使用<code>&lt;bean&gt;</code>构建一个bean，指定<code>id</code>（全局唯一）和<code>class</code>。如果该bean对应的类需要使用静态工厂方法，使用<code>factory-method=&quot;xxxx&quot;</code>属性；如果需要实例工厂方法，则必须在前面先声明工厂类的bean，然后在这里指定<code>factory-bean</code>；bean的scope分为两类：<code>prototype</code>和<code>singleton</code>。显然单例的bean全局只有一个，原型的则每次产生新的。</li><li>使用<code>&lt;constructor-arg&gt;</code>调用构造器进行初始化，可以使用<code>index</code>属性指定构造器参数次序，或者直接用<code>type</code>按参数类型进行匹配（就像正常调用重载方法时那样），或者用<code>name</code>指定参数的名字。使用<code>value</code>注入需要的值。</li><li>使用<code>&lt;property&gt;</code>调用对应的<code>setter</code>来注入各种属性。如果注入的是常量，直接用<code>value</code>赋值就行；如果注入的是其他bean的<strong>名字</strong>，使用<code>idref bean=&#39;xxx&#39;</code>；如果注入的是其他bean对应类的实例，需要使用<code>ref bean=&#39;xxx&#39;</code>;还可以注入<code>list</code>,<code>set</code>, <code>array</code>和<code>map</code>，甚至<code>prop</code>(<code>java.util.Properties</code>) ；如果想要注入<code>null</code>，必须使用<code>&lt;null/&gt;</code>标签，直接写当然是字符串。</li><li>使用<code>lazy-init</code>可以对bean进行延迟初始化；</li><li>使用<code>depends-on</code>指定依赖的bean来影响初始化/销毁的顺序；</li><li>自动装配：为了减少配置文件的长度，spring支持自动装配。简单来说可以根据参数的名称自动找到对应bean的名称；</li><li>此外，spring还支持method注入。这个主要是为了解决单例bean调用原型bean导致的一系列问题；</li></ol><h3 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h3><p>spring为外部资源抽象了一系列的接口</p><h3 id="Spring表达式"><a href="#Spring表达式" class="headerlink" title="Spring表达式"></a>Spring表达式</h3><p>为Java语言提供了<code>eval</code>功能，类型动态语言的功能<br>在bean中可以使用SpEL，格式为<code>#&#123;&#125;</code>，表达式放在大括号中<br>可以在Java语言中使用<code>@Value(#&#123;&#125;)</code>注释进行注入</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>Spring是面向接口编程的，这是装饰器模式的基础。</p><p>所谓装饰器模式，指的是对于一个<code>HelloApi</code>接口，定义一个装饰器也实现<code>HelloApi</code>接口，其构造器也是需要一个<code>HelloApi</code>对象。这样，我们将需要装饰的对象传入装饰器对象，通过调用装饰器的接口方法来实现装饰。</p><p>Spring通过注解/xml的方式完成装饰器的注入，就是所谓的AOP. 使用流程：</p><ol><li>写一个切面类；</li><li>定义连接点（具体什么场景下在哪里被调用），切入点表达式形如<code>execution(* com.spring.service.*.*(..))</code>，匹配语法：<code>*</code>表示一级上的任意字符，<code>..</code>表示任意级的任意字符，<code>+</code>指定类型的子类型；这里的语法很复杂，可以参见<a href="http://blog.csdn.net/wangpeng047/article/details/8556800">这里</a>；</li><li>定义通知的回调方法</li><li>通知顺序：前置通知→环绕通知连接点之前→连接点执行→环绕通知连接点之后→返回通知→后通知；如果发生异常：异常通知→后通知</li></ol><h3 id="JDBC支持"><a href="#JDBC支持" class="headerlink" title="JDBC支持"></a>JDBC支持</h3><p>Spring扩展了原生的jdbc支持，但是一般情况下我们在生产环境会和ORM结合使用</p><h3 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h3><p>一般使用注释来简化配置文件，常见注释包括：</p><ol><li>Required：必须注入的属性，修饰setter；</li><li>Autowired： 自动装配，可以后面跟上<code>(required=true)</code>，自动装配有点坑爹，谨慎使用</li></ol><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>Spring MVC是一套常见的MVC web框架，主要涉及了几个层次……</p><h2 id="Apache-Shiro"><a href="#Apache-Shiro" class="headerlink" title="Apache Shiro"></a>Apache Shiro</h2><p>一个权限认证系统</p><h2 id="SiteMeth"><a href="#SiteMeth" class="headerlink" title="SiteMeth"></a>SiteMeth</h2><p>一个服务端渲染的页面装饰框架</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua5.1要点笔记</title>
      <link href="2017/06/12/lua5.1%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
      <url>2017/06/12/lua5.1%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>sudo apt-get install lua5.1</code></p><p>lua的各个版本之间不兼容问题很严重，5.1-5.2-5.3之间都有一些不兼容的问题，5.1是最经典的版本，适用范围广泛。luajit与lua的关系相当于pypy与cpython的关系，luajit采用lua5.1语法，作者已经另起炉灶了，永远不和lua5.2兼容。Heka的lua扩展也是使用5.1版本的lua。</p><p>lua是一门嵌入式语言，也就是程序的入口点必定在别处，这是和python等脚本语言的最大区别。lua的性能很好，虽然比不上v8的js。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li>作为一门动态语言，可以从lua身上看出许多动态语言的影子。lua与js，python都有一定的相似性，可以说是综合了二者之所长。但是有个坑，就是unicode问题，lua5.3解决了这个问题。不过对于heka，一般情况下我们不太需要处理utf8，毕竟日志数据track一般都是编号和数据。</li><li>与python不同而与js类似，lua是动态类型语言。字符串会在适当时候自动转成数字， 当然也可以使用string.format自己进行转换；</li><li>所有的变量默认是全局的（与js一致），需要使用local修饰符来创建局部变量；全局变量被存放在一个table中，被称为环境，可以通过<code>getfenv</code>和<code>setfenv</code>来对环境进行操作；</li><li>只有一种数据结构：table. 赋值语句比较奇怪:<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x=<span class="number">3</span>, [<span class="number">2</span>]=<span class="number">2</span>&#125;</span><br><span class="line">a[<span class="number">1</span>] == <span class="number">2</span></span><br><span class="line">a[<span class="string">&quot;x&quot;</span>] == <span class="number">3</span></span><br></pre></td></tr></table></figure>注意table里面值不能是nil，否则会有各种奇怪的问题，比如<code>#</code>返回的是<code>nil</code>值之前的长度；所以可以用<code>a[x] == nil</code>或者<code>if a[x]</code>来判断exists；将<code>a[x]=nil</code>则相当于删除了<code>x</code>元素。但是不能这样删除数组里面的元素，因为会导致<code>#</code>操作符的结果错误，需要使用<code>table.remove(x)</code>;</li><li>连接操作符：<code>..</code>; 取长度操作符（相当于<code>len</code>)<code>#</code>，但是<code>#</code>返回的是字节数，所以更像是<code>sizeof</code></li><li>函数与js中的很像，支持闭包。<code>：</code>可以用来定义方法，本质上是一种语法糖；</li><li><code>metatable</code>类似与python的内置方法，各种重载操作符。</li><li>lua支持<code>coroutine</code>.</li></ol><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><ol><li>由于lua中table不支持<code>nil</code>，这与json中的<code>null</code>产生了矛盾，需要使用<code>cjson.null</code>来表示</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> heka </tag>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习</title>
      <link href="2017/06/12/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>2017/06/12/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>update(2019/03/31): 移除了一些过时信息。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>安装 GoLang，直接用官网的安装指南就行；</li><li><s>设置环境变量<code>GOPATH</code>，这个是用默认包的存放位置，用<code>go get</code>安装的包会存放在这个位置。在<code>~/.zshrc</code>或<code>~/.bashrc</code>里面加入<code>export GOPATH=~/.go</code>，然后在<code>PATH</code>里面加入<code>GOPATH/bin</code>即可</s>；go1.10之后，已经不用手动设置<code>GOPATH</code>；</li><li>如果是项目的依赖，最好不要放入全局系统。使用1.11后加入的<code>go mod</code>；</li><li>设置代理。<code>go get</code>命令下载必定被墙，使用<code>git config --global http.proxy &quot;xxxx:oooo&quot;</code>设置代理方可使用，也可以使用<code>http_proxy=xxxx:oooo go get</code>这个格式，或者在 bashrc 里面加个<code>alias</code>；在项目里的<code>go.mod</code>中使用<code>replace</code>也可以；</li><li>IDE：推荐vscode+go，或者 gogland，后者付费；</li><li>官方教程，建议下载到本地运行，速度更快；</li><li>交互式命令行：<code>gore</code>(<code>go get -u github.com/motemen/gore</code>)；</li><li>可以使用<code>https://play.golang.org/</code>跑一些短小的程序测试；</li></ol><h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ol><li>打头的<code>package xxx</code>，类似 java，<code>import</code>可以用括号打包；</li><li>类型在变量名后，这种奇特的声明方式虽然有篇 blog 来解释，但总而言之是扯淡的；</li><li>连续多个变量同类型可省略前面的只保留最后一个；</li><li>类似 python 的多值返回（但是 python 本质是一个 tuple)，如果给返回值命名了，就不必在函数体中声明这些变量；</li><li><code>var name int</code>是典型的声明变量格式，自动推导类型的语法是<code>name := 0</code>（但是这个语法只能在函数体里面用，外面必须用<code>var</code>声明）。可以在一行给多个变量赋值（类似 python 的解包）；</li><li>基本类型，和 c++类似，包括<code>bool</code>, <code>int</code>, <code>uint</code>, <code>byte</code>(<code>uint8</code>),<code>rune</code>(<code>int32</code>), <code>float32</code>, <code>float64</code>, <code>uintptr</code>, <code>complex64</code>, <code>complex128</code>, <code>string</code>，注意么有<code>double</code>，类似其他 GC 语言，所有类型会被自动化初始化；</li><li>Go 没有隐式类型转换，所有类型之间必须显式转换。注意<code>int</code>和<code>string</code>之间不能互转，可以用<code>strconv</code>中的<code>Itoa</code>和<code>Atoi</code>来完成（非常烦躁的设定）；</li><li>常量使用<code>const</code>关键字声明，常量只能是基础类型，且不能用<code>:=</code>声明。常量的实际类型由上下文决定，数值常量本身是高精度的；</li><li> 和 C 语言一样，单引号表示字符(byte)，双引号表示字符串。<code>string</code>可以转换成一个<code>rune</code>数组，或者<code>byte</code>数组，取决于你对字符串的解释（字节流还是文本）。</li></ol><hr><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><ol><li>循环只有<code>for</code>语句，且不需要括号（其他语句也都不需要），基本格式还是类似 c 的<code>for i := 0; i &lt; 10; ++i</code>，这种，后面必须跟大括号，且大括号必须和<code>for</code>在同一行…</li><li>如果省略前后前后的分号，<code>for</code>就成了<code>while</code>；如果全部省略，裸的<code>for</code>代表死循环；</li><li>if 类似，不要括号，花括号必须；而且 if 也可以在分号前声明一个变量，作用域仅限于花括号以及后面跟着的<code>else</code>里面；</li><li><code>switch</code>语句，好吧，和上面也类似。有个有趣的地方是，默认自动终止，除非使用<code>fallthrough</code>，和 C 中的默认自动向下，除非手动<code>break</code>相反；<code>switch</code>也可以直接用空语句，条件比较复杂时使用可以让代码看起来更加整洁；</li><li><code>defer</code>语句，这是 Go 的特色语句了。<code>defer</code>是在函数返回后再执行，其本质是压栈，所以弹出顺序与<code>defer</code>的顺序相反；</li></ol><hr><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ol><li>虽然 Go 是一门 GC 语言，但是仍然拥有指针。<code>*T</code>表示指向类型<code>T</code>的指针，取地址仍然使用<code>&amp;</code>。不过与 C 不一样的是，不允许指针运算；</li><li>和 C 一样，拥有<code>struct</code>，而且蛋疼的是，也只能拥有字段（和 C 一样，POD）。结构体通过指针访问字段也是使用<code>.</code>符号（没有了<code>-&gt;</code>符号）；</li><li>使用<code>&#123;&#125;</code>进行结构体初始化，如</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a = Point&#123;X: <span class="number">10</span>&#125;</span><br><span class="line">    b = Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    c = Point&#123;&#125;</span><br><span class="line">    p = &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">)</span><br><span class="line">fmt.Println(p.X)</span><br></pre></td></tr></table></figure><p>虽然感觉有点奇怪，不过和 C++11 后的初始化列表其实挺像的。</p><hr><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ol><li>声明方式： <code>var a [10]int</code>，这语法也是醉了。和 C 一样，数组不能动态扩张；</li><li>使用<code>slice</code>代替数组，声明方式： <code>a = make([]int, 0, 5)</code>，第二个参数表示长度(len)，第三个参数表示容量(cap)。类似 python 中的<code>list</code>，可以切片；注意，如果仅仅声明<code>var []a</code>那么<code>a==nil</code>是成立的；</li><li><code>make</code>关键字只能用来生成系统内置的一些对象，如 slice, map, chan；由于go不支持泛型，只有内置的这几个结构可以用泛型（很奇葩）。</li><li>go 的切片有一些匪夷所思的问题，因为切片得到的并不是新的对象，而是原来对象的指针；</li><li>可以通过<code>append</code>往 slice 中添加元素，类似 C++中的<code>vector</code>可以自动扩展长度。注意append会返回slice的指针，这个值和原来的不一定一致；</li><li><code>range</code>关键字（注意这货不是函数。。）用来对<code>slice</code>进行循环，格式是<code>for i, v := range a</code>;</li></ol><hr><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><ol><li><code>map</code>现在也是新兴语言的标配了，<code>map</code>和<code>slice</code>一样，必须通过<code>make</code>创建，语法是<code>m := make(map[string]int)</code>,<code>[]</code>中的是键的类型，后面跟着的是值的类型。初始化语法神马的和 struct 类似；</li><li>删除元素使用<code>delete</code>关键字；检测存在使用双赋值：<code>a, ok = m[&#39;test&#39;]</code>，如果存在则 ok 为<code>true</code>，否则为<code>false</code>；</li></ol><hr><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ol><li>函数被提到第一公民的位置，和 javascript 里面的语法很像，当然，除了强类型声明很麻烦以外；</li><li>函数的闭包与 js 类似，内嵌函数引用的是各自的闭包（其实有点像 C 中的<code>static</code>局部变量）；</li></ol><hr><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>虽然 Go 里面没有类，但是可以声明 struct 关联的方法，虽然语法非常别扭…例如（接着上面的<code>Point</code>）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p1 *Point)</span> <span class="title">distance</span><span class="params">(p2 *Point)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法接受者位置在<code>func</code>关键字和函数名之间，呃，其实和 C++的外置方法声明还是有点像的…</p><ol start="2"><li>值得注意的是，不仅仅是 struct，可以通过这种声明向本包内任意非内置类型注入方法，甚至可以通过<code>type</code>声明别称后向别称的内置类型进行注入；</li><li>方法接受者可以是指针，也可以不是，当然只有指针才能改变元素的实际值；</li></ol><hr><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><ol><li><code>struct</code>从语法上来讲和 C 基本是一样的；</li><li>可以在字段后面添加字符串，表示<code>tag</code>，在反射的时候用；</li><li>可以在结构体内塞入另一个结构体（或其指针），组合优先于继承；</li></ol><hr><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ol><li>虽然没有类，但是由接口。关键字<code>interface</code>声明一种接口：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flyable <span class="keyword">interface</span>&#123;</span><br><span class="line">    Fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>Flyable</code>声明了一个接口，拥有<code>Fly</code>方法. 这样后面假设我给<code>pig</code>加上<code>fly</code>方法，那么变量<code>var item Flyable</code>就可以被赋值为<code>item = &amp;pig&#123;&#125;</code><br>这里值得注意的是，这里的接口实现本质是隐式的（非侵入式的），或者可以说是<code>duckable</code>的，pythoner 对此应该深有理解：）</p><ol start="2"><li><code>Stringers</code>是一个常见的接口，类似 python 中的<code>__str__</code>或者 java 中的<code>toString</code>，它只需要实现<code>String</code>方法；</li><li>Go 里面没有异常，仍然使用错误。<code>error</code>是一个接口，只有一个方法<code>Error() string</code>，通常函数会返回一个<code>error</code>，放在第二个位置，如果其不为<code>nil</code>则说明出了错误；</li><li>其他常见接口包括<code>io.Reader</code>，表示从数据流结尾读取；<code>http.Handler</code>表示处理 HTTP 请求的服务器；<code>image.Image</code>表明一个图像的接口；</li><li>接口可以通过接口来组合</li></ol><hr><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ol><li><code>goroutine</code>是 Go 运行时的轻量级线程（协程），在方法名前加<code>go</code>就在另一个线程中同步执行了；</li><li><code>channel</code>是有类型的管道，可以使用<code>&lt;-</code>操作符对其发送或接受值，使用<code>make(chan int， 100)</code>创建一个<code>int</code>的<code>channel</code>，第二个参数表示缓冲区长度，也可以不带，表示完全无缓冲；</li><li><code>&lt;-chan</code>和<code>chan&lt;-</code>分别表示只读和只写的 chan，后面跟着管道中的数据类型，如<code>a &lt;-chan *int</code>表示只读的整数指针通道；</li><li><code>close</code>一个<code>channel</code>表示不再发送数据（只有发送者可以关闭），向已经<code>close</code>的<code>channel</code>发送数据会引起<code>panic</code>。使用<code>range</code>则表示从<code>channel</code>中源源不断的接受数据直到被关闭；</li><li><code>select</code>语句使得一个 goroutine 在多个通讯操作上等待，阻塞直到某个分支可行，例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var a, b chan int</span></span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> x &lt;- a:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> &lt;- b:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有分支都不可行时，执行<code>default</code>语句；</p><ol start="5"><li><code>sync.Mutex</code>提供了互斥锁，包括<code>Lock</code>和<code>Unlock</code>两个方法，可以使用<code>defer</code>语句保证锁一定会被释放；</li><li>Go 与 Erlang 的并发模型分别是 CPS 和 Actor，但是 Go 的 channel 里面可以传递指针，这和 Erlang 的变量不可更改有着根本性质的区别。</li></ol><hr><p>至此，基础部分结束。</p><hr><h2 id="进阶部分"><a href="#进阶部分" class="headerlink" title="进阶部分"></a>进阶部分</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li><s>前面导出了<code>GOPATH</code>环境变量，这个路径就是实际的工作空间。从结论来看，Go 提倡将所有 Go 语言项目放入同一个工作路径，这是很不好的；</li><li>如果使用过<code>go get</code>命令，那么<code>GOPATH</code>下会自动创建<code>bin</code>, <code>pkg</code>和<code>src</code>三个文件夹，源码存放在<code>src</code>之下，<code>import</code>本地包时，就是从这一层开始的。<code>go get</code>无法控制依赖的版本（垃圾）；</s></li><li><code>go install</code>会生成输出文件（可执行或者库），<code>go build</code>则仅编译；</li></ol><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><ol><li>Go 自带了一个工具<code>go fmt</code>用来对代码进行格式化；</li><li>注释的格式和 C++一致。使用<code>godoc</code>生成文档，类似 python 的 docstring，但是约定更加简单：对类型、变量、常量、函数或者包的注释，在其定义前编写普通的注释即可，不要插入空行。Godoc 将会把这些注释识别为对其后的内容的文档。</li><li>与顶级定义不相邻的注释，会被 godoc 的输出忽略，但有一个意外。以“BUG(who)”开头的顶级注释会被识别为已知的 bug，会被包含在包文档的“Bugs”部分。</li><li><code>getter</code>没有必要用<code>Get</code>开头，直接大写首字母就行，<code>setter</code>还可以留着<code>Set</code>；</li><li>Go 习惯使用驼峰式写法，而不是下划线；</li><li>Go 其实是需要分号的，但是分号是自动插入的。这造成了一些非常奇怪的约定。例如左大括号必须放在一行末尾…</li><li><code>new</code>用来分配内存，并且填 0，返回指向对象的指针，程序可以利用这些指针进行手动初始化；<code>make</code>则只能用来创建内置类型(slice, map 和 channel)，返回的是对象本身，而不是指针；</li><li><code>array</code>是一种对象，和它的大小相关；array 名并不是指针（和 C 不同）；</li><li><code>print</code>语系和 C 中基本一致, <code>%v</code>可以拿到值，<code>%T</code>可以拿到类型；</li><li><code>interface &#123;&#125;</code>相当于 C 中的<code>void *</code>可以被转化为任意类型，一种常见的反射方式是使用<code>v.(type)</code>，这被称作<code>type assertion</code>. 比如<code>str, ok = v.(string)</code>，返回的就是 string 类型；另外可以在<code>switch</code>语句里面用<code>x.(type)</code>，然后再<code>case</code>里面判断类型；</li><li><code>import</code>后必须使用，否则会报错（傻逼设定。。），可以用<code>import _ &quot;fmt&quot;</code>的方法导入但不使用，或者用<code>_</code>赋值；另外就是可以直接导入包内全部方法，使用<code>import * &quot;fmt&quot;</code>；</li><li>可以通过往<code>struct</code>里面塞匿名字段（另一个 struct，或其指针）来达到继承的目的，虽然看起来很奇怪就是了。注意的是，这本质上只是一种语法糖。外围的同名元素会覆盖继承（内嵌）的；同样，也可以往<code>interface</code>里面塞一个别的<code>interface</code>达到继承接口的目的；</li><li><code>panic</code>和<code>recover</code>是最后手段；</li></ol><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ol><li>使用<code>reflect</code>包来进行反射；</li><li>golang 里面每个值都有<code>Type</code>和<code>Value</code>，这是因为所有值都是<code>interface&#123;&#125;</code>的实现者，而后者实际上是一个空类型，所以需要<code>Type</code>和<code>Value</code>用于反射。这也就对应着<code>reflect.Type</code>和<code>reflect.Value</code>，也对应着<code>%T</code>和<code>%v</code>，也对应着<code>reflect.TypeOf()</code>和<code>reflect.ValueOf</code>；</li><li><code>reflect.Type</code>和<code>reflect.Value</code>并不是并列的（并不能顾名思义）；而是一种包含关系，<code>reflect.Value</code>是一个&lt;Type, Value&gt;的二元组，<code>reflect.ValueOf(x).Type</code>与<code>reflect.TypeOf(x)</code>是一致的，返回的是静态类型；<code>reflect.ValueOf(x).Kind</code>可以返回一个常量定义的类型（如<code>reflect.Float64</code>)，这是一个底层类型。</li><li>可以从<code>reflect.ValueOf(x).Interface()</code>还原接口值，后续跟随类型断言等；输出<code>reflect.Value</code>的正确方法是将其先转为<code>interface&#123;&#125;</code>；</li><li><code>reflect.ValueOf(x).SetXXX</code>的前提是 x 是可修改的(<code>CanSet</code>)，借助指针来修改的方法是：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">1.1</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()</span><br><span class="line">v.CanSet() == <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><ol><li>在循环中创建goroutine需要注意变量的传递。如:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实际上可能输出了10个9，这是由于<code>go</code>创建的协程不会马上运行，当启动的时候i已经迭代到9了。正确的做法是不要直接使用闭包外的变量，而要进行传值。即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;(i)</span><br></pre></td></tr></table></figure><ol start="2"><li>nil与interface</li></ol><p>如果一个函数如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IAdder <span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span>)</span><span class="title">int</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Ex <span class="keyword">struct</span>&#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Ex)</span> <span class="title">Add</span> <span class="params">(x <span class="keyword">int</span>)</span><span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.X + x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">int</span>)</span><span class="title">Ex</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y Ex</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">10</span>&#123;</span><br><span class="line">        y = <span class="literal">nil</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y = &amp;Ex&#123;x&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> IAdder ia</span><br><span class="line">    ia = test(<span class="number">100</span>)</span><br><span class="line">    fmt.Printf(ia == <span class="literal">nil</span>)  <span class="comment">//这里输出是false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的原因是<code>interface</code>本质上是一个值，他有两个部分Type和Value，只有两者都是nil的时候，这个值才是nil。所以interface不能直接与nil做比较。一个方法是直接在<code>test</code>中返回<code>IAdder</code>，还有个方法是先拿到值，判断nil后再复制给接口。或者，在test中加入<code>error</code>返回值，通过那个做判断也行。每当拿interface和nil值作比较的时候，心里都要警惕。</p><ol start="3"><li>深浅拷贝</li></ol><p>这个其实是和C语言中一样的，如果我们令<code>A := B</code>，B是一个指针，那么A只是做了浅拷贝，但是如果B是一个struct，那么A就做了深拷贝（但是B中的指针仍然还是指针）。</p><p>另外需要注意的是，go中内置的slice, map和chan本质上都是指针。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heka插件开发</title>
      <link href="2017/06/12/Heka%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>2017/06/12/Heka%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>学习Go主要是为了开发heka的插件，heka和logstash不一样，插件多半还是靠自己开发。而logstash大部分情况下只需要使用自带的插件，简单的自定义处理只需用自带的<code>ruby</code>插件，复杂的才需要自己写插件来处理。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Heka是一个基于插件的日志处理系统，其基本结构如下（图片来自网络）：<br><img src="http://skoo.me/assets/images/heka-overview-diagram.png" alt="Heka结构图"></p><p>显然这是一个流式处理系统，从输入流到输出流之间经过一系列的处理。其流程被抽象成几个类似与logstash的步骤，包括分割；解码；过滤；编码；输出。</p><h3 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h3><ol><li>使用<code>go get github.com/mozilla-services/heka</code>(自备梯子)下载heka项目；</li><li>到<code>$GOPATH/github.com/mozilla-services/heka</code>下，先用<code>git checkout v0.10.0</code>切换到最新的<code>0.10.0</code>稳定版，然后再<code>source build.sh</code>进行编译，系统依赖参见<a href="https://hekad.readthedocs.org/en/v0.10.0/installing.html">官方文档</a>。编译过程中会去线上下载一些go的依赖，所以仍然注意要备好梯子…</li><li>第一次编译时间较长，尤其是网速不给力的时候，你可以去喝杯咖啡…编译完成后可以使用<code>ctest</code>来测试一下。令人尴尬的是使用go1.5测试失败…貌似有些bug；</li><li>官方给出了一个插件的example，就在<code>heka/examples</code>文件夹下。使用方法：在<code>heka/</code>下新建<code>externals/host_filter</code>文件夹，然后将<code>examples/host_filter.go</code>复制到该文件夹下，最后在<code>heka/cmake/plugin_loader.cmake</code>中添加<code>add_external_plugin(git http://xxx/host_filter :local)</code>，最后重新编译项目，就会得到包含插件<code>host_filter</code>的二进制文件<code>hekad</code>；</li></ol><blockquote><p>使用Go1.5编译v0.10.0自带的example <code>host_filter.go</code>会提示<code>enough arguments in call to pack.Recycle</code>。查看提示的79行代码，发现<code>pack.Recycle()</code>少了个参数，传入<code>nil</code>重新编译即可。重新编译前在<code>build</code>文件夹中运行<code>make clean-heka</code>进行一次清理。</p></blockquote><h3 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h3><p>手头的项目需求如下：</p><ol><li>输出json形式的按行分割的log；</li><li>json中有<code>type</code>字段，根据type的不同生成不同的<code>map</code>，但最后被送到同一个output插件中；</li><li>output到mongo中，每个数据需要存在两个表中，分别是按日统计的累加表和总的累加表，以便统计按日数据和总体趋势数据；</li></ol><p>根据上述描述，应该使用<code>LogstreamerInput</code>引入输入，spliter使用默认的<code>token_spliter</code>按行进行分割即可，decoder使用<code>json decoder</code>，参考配置：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[LogstreamerInput]</span></span><br><span class="line"><span class="attr">log_directory</span> = <span class="string">&quot;/var/log/lucky&quot;</span></span><br><span class="line"><span class="attr">file_match</span> = <span class="string">&#x27;track\.json&#x27;</span></span><br><span class="line"><span class="attr">decoder</span> = <span class="string">&quot;JsonDecoder&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[JsonDecoder]</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;SandboxDecoder&quot;</span></span><br><span class="line"><span class="attr">filename</span> = <span class="string">&quot;lua_decoders/json.lua&quot;</span></span><br><span class="line">    <span class="section">[JsonDecoder.config]</span></span><br><span class="line">    <span class="attr">Type</span> = <span class="string">&quot;type&quot;</span></span><br><span class="line">    <span class="attr">payload_keep</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">Timestamp</span> = <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line">    <span class="attr">timestamp_format</span> = <span class="string">&quot;%Y-%m-%dT%H:%M:%S.%f&quot;</span></span><br></pre></td></tr></table></figure><p>我现在需要编写一个自定义的filter和一个output插件。filter的格式可以参考<code>host_filter</code>里面的例子， output则可以参考plugin里面的<code>elasticserach.go</code>。</p><p>实际在编写过程中发现，如果log的格式是json，使用go做解析非常费劲。Json比较适合动态语言，对于静态的Go，只能通过<code>map[string]interface&#123;&#125;</code>这种做映射和强制转换。而<code>Message.Fields</code>是一个<code>*[]Field</code>，这意味着Json被映射成了一个数组，由于这里是业务日志分析，有很多数据结构不同的日志输出，如果使用默认的这种数组遍历的filter方式，写起来非常麻烦。所以我把payload仍然保留，然后使用<code>encoding/json</code>将payload解析成一个<code>map[string]interface&#123;&#125;</code>，这样虽然仍然很麻烦，但是工作量已经减轻不少。</p><p>mongo和redis在go中已经有成熟的库，直接引用即可。个人的工作量就是自定义解析过程，其实不难，就是动态语言写久了再写静态语言感觉有点繁琐。官方有<a href="https://hekad.readthedocs.org/en/v0.10.0/developing/plugin.html">插件开发指导</a>，仔细阅读一遍，然后再参考里面已有的plugin，就可以动手写了。注意现在（刚发布）example的<code>host_filter</code>和0.10.0有些标准不和，可能随后才会更新。</p><h3 id="lua开发"><a href="#lua开发" class="headerlink" title="lua开发"></a>lua开发</h3><p>使用lua解析json显然更加得心应手。最后我自己写了一个decoder，将数据解析为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;UserId&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;Set&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">&quot;Inc&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在Go文件中仅仅需要把对应的数据直接更新到mongo中，而无需一层层的分析数据。大大减轻了工作量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> heka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java CMS GC调优步骤</title>
      <link href="2017/06/12/jvm%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/"/>
      <url>2017/06/12/jvm%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>0.增加GC相关选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc</span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line">-XX:NumberOfGCLogFiles&#x3D;5</span><br><span class="line">-XX:GCLogFileSize&#x3D;512K</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line">-Xloggc:&#x2F;var&#x2F;app&#x2F;log&#x2F;Push-server&#x2F;gc.log</span><br></pre></td></tr></table></figure><ol><li>如果不能确定所需内存，使用自动jvm自动调优；</li><li>大致确定所需内存后，使用-Xmx -Xms设置堆大小；</li><li>观察GC log确定FullGC后剩余堆大小（即为活跃数据大小）；</li><li>整个堆大小宜为老年代活跃数据大小的3-4倍；</li><li>永久带大小应该比永久带活跃数据大1.2~1.5倍；</li><li>新生代空间应该为老年代空间活跃数据的1~1.5倍；</li><li>通过top命令观察栈占用空间、直接内存占用空间，决定所需机器内存大小；</li><li>新生代大小决定了Minor GC的周期和时长，缩短新生代大小可以减少停顿时长，但是增加了GC频率；在调整新生代大小时，尽量保持老年代大小不变；</li><li>老年代大小不应该小于活跃数据的1.5倍；新生代空间至少为java堆大小的10%；增加堆大小时，注意不要超过可用物理内存数；</li><li>从throughput收集器迁移到CMS时，需要将老年代空间增加20%~30%；</li><li>新生代分为Eden和Survivor两部分，Survivor可以通过<code>-XX:SurvivorRatio=xx</code>来控制，对应的大小为<code>-Xmn&lt;value&gt;/(ratio+2)</code>；</li><li>通过<code>-XX:MaxTenuringThreshold=&lt;n&gt;</code>来指定晋升阈值（年龄），n为0~15之间；</li><li>期望Survivor空间为剩余总存活对象大小的2倍(age=1；</li><li>注意调节Survivor大小时，保持Eden大小不变；</li><li>如果Survivor空间足够大，且对象大部分并未到达老年代，那么就可以将晋升年纪指定的足够大（15）。在Eden与Survivor之间复制和CMS老年代空间压缩之间，我们宁愿选择前者；</li><li>CMS必须能以对象从新生代提升到老年代的同等速度对老年代中的对象进行收集，否则，就会失速；</li><li>如果观察到’concurrent mode failures’，意味着失速已经发生，必须减少<code>-XX:CMSInitiatingOccupancyFraction=&lt;percent&gt;</code>的值；</li><li>使用上述选项的同时，最好同时使用<code>-XX:+UseCMSInitiatingOccupancyOnly</code>，强制使用该比例,该比例的大小应该大于老年代占用空间和活跃数据大小之比，一般而言<code>老年代大小*该比例&gt;1.5*老年代活跃数据大小</code>；</li><li>使用<code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsCloasses</code>可以使用CMS进行显式垃圾回收（<code>System.gc()</code>)；通过<code>-XX:+DisableExplicitGC</code>关闭显示垃圾回收（慎用）；</li><li>使用<code>-XX:+CMSClassUnloadingEnabled</code>打开永久带垃圾回收，使用<code>-XX:+CMSPermGenSweepingEnabled</code>打开CMS对永久带的扫描；使用<code>-XX:CMSInitiatingPermOccupancyFraction=&lt;perscent&gt;</code>激活回收比例阈值；</li><li>使用<code>-XX:ParallelGCThreads=&lt;n&gt;</code>控制扫描线程数；使用<code>-XX:+CMSScavengeBeforeRemark</code>强制重新标记前进行一次MinorGC；如果由大量的引用对象或可终结对象要处理，使用<code>-XX:+ParallelRefProcEnabled</code>；</li><li>CMS包括Minor GC所带来的开销应该小于10%；</li><li>如果缺少长时间调优的条件，安全起见，可以使用G1，1.8以后G1已经稳定，仅设置如下参数即可：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-d64</span><br><span class="line">-Xmx5g</span><br><span class="line">-Xms5g</span><br><span class="line">-XX:PermSize&#x3D;100m</span><br><span class="line">-XX:MaxPermSize&#x3D;100m</span><br><span class="line">-XX:MaxDirectMemorySize&#x3D;1g</span><br><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:MaxGCPauseMillis&#x3D;80</span><br></pre></td></tr></table></figure>G1不必明确设置新生代大小，其自动调优也十分可靠，对于停顿时间往往在长时间运行后可以达到预期效果；对吞吐量优先的应用，可能不是那么明显。</li></ol><p>实际上除了Java以外，其他语言很少考虑虚拟机优化问题，这也不应该是普通程序员需要关心的问题，只能说明Java本身不够成熟。从Java9开始，大部分程序员已经无需关心JVM优化的问题。如果面试遇到了，基本属于面试官自己造火箭的原因。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> gc </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web前端开发进阶</title>
      <link href="2017/06/12/web%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"/>
      <url>2017/06/12/web%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>目前的项目还是用backbone写控制台，说实话，快写吐了…前段时间看了一下ES6，ES7的变化，发现javascript正在变得越来越好，加上V8的给力性能，在web开发这块，js取代python指日可待。当然python丰富的第三方库决定了它在运维/科学计算/爬虫等方面的可靠性，仍然是值得推荐的第一入门语言（当然，学院派最好从lisp入手）。</p><p>要我说，现在创业公司就应该从js全栈起步，后台前端都用js，小活用meteor这种神器快速搭建，确定方向后再前后端分离认真设计。后端用react，再到naive，桌面段由node-webkit，大全栈一统天下。性能跟不上的模块再重构就可以直接用go/C++之类的，或者用jvm系的东西。时至今日，java的速度已经不慢（至少比一堆脚本语言快），组件多，好招人，适合迅速起步。</p><p>10个人的创业团队，5个js全栈（back/front/react-naive/node-webkit），3个jvm系(android/spark/storm等)，1个object-C系（apple），1个python系（运维），感觉就够了。js必将一统天下，这也是大势所趋。虽然说没有银弹，但是有一门能解决大部分场景问题的语言，还是非常了不起的。</p><p>我之前一直讨厌用js的原因无非是因为这门语言实在太糟蹋了，到了ES6，js越来越python，也可以愉悦的使用了。</p><p><strong>推荐使用nesh作为交互程序进行测试，或者使用nodejs kernel for ipython</strong></p><p>学习步骤：ES6-&gt;React/vue-&gt;redux/vuex-&gt;meteor，目的是熟练使用meteor搭建一些小网站满足需求。<br>然后是react native -&gt; app开发，目的是了解一下客户端技术。</p><h2 id="ES6要点"><a href="#ES6要点" class="headerlink" title="ES6要点"></a>ES6要点</h2><blockquote><p>参考 阮一峰的书，测试推荐使用<code>nesh -b</code></p></blockquote><ol><li>使用<code>let</code>声明变量，而不是<code>var</code>，主要引入原因是<code>var</code>有性能问题，且作用域自动提升；使用<code>let</code>声明的变量，其表现行为与其他语言中的变量一致（如c++）；</li><li>使用<code>const</code>声明常量；</li><li>使用<code>...</code>进行解构。这个是FP中常用的语法，<code>python</code>中也有(<code>*</code>和<code>**</code>)；不同的是，js的解构允许默认值，如果解构失败，变量就是undefined，如果有默认值，这里就会使用默认值；默认值是惰性求值的；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b=<span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]      <span class="comment">//这个解构只能放在最后，不如haskell中那么高级</span></span><br></pre></td></tr></table></figure><ol start="4"><li>对象也可以解构，当然对象本身是无序的，所以解构的变量名必须和key名字一致，否则必须重新映射：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: baz&#125; = &#123;<span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>这个功能经常用在传递函数参数上，调用方传入一个Object，接受函数可以用(<code>&#123;param1, param2&#125;</code>)直接解包，将key对应的value赋给变量；<br>5. 字符串也可以解构成字符，因为字符串本来就是字符数组（只是不可变）<br>6. Unicode支持增强，允许使用<code>\u&#123;20BB7&#125;</code>来进行UTF-16表示；使用新的<code>String.fromCharCode</code>来转换Unicode；使用新的<code>at</code>方法来取出字符；<br>7. 提供了类似python的<code>includes</code>, <code>startsWith</code>,<code>endsWith</code>方法；提供<code>repeat</code>方法快速生成字符串；提供<code>padStart</code>,<code>padEnd</code>方法填充字符串；<br>8. 终于，有官方支持的字符串模板了（泪流满面）。格式类似shell：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span></span><br></pre></td></tr></table></figure><p><code>$&#123;&#125;</code>内部可以进行各种运算，包括直接调用函数，这个看起来有点像bash中的引用变量；<br>9. 标签模板，允许使用函数后紧跟模板，相当于把模板中的常量和变量当做参数传入该函数；使用<code>String.raw</code>后跟模板，输出的就是别的语言中的原生字符串；<br>10. 正则表达式也有所增强，使用的时候再看吧；<br>11. <code>Number.isFinite</code>和<code>Number.isNaN</code>用来检测特殊值，和内置的区别是非数字直接返回false；<br>12. 同样，将内置的<code>parseInt</code>, <code>parseFloat</code>也变成了Number的方法；<br>13. <code>isInteger</code>用来检测是否整数，但是由于js只有浮点数，所以<code>15.0</code>就是<code>15</code>；<br>14. 用<code>Number.EPSILON</code>表示一个极小的误差范围；<br>15. 引入常量表示精度上下限；<br>16. 新增了17个Math方法；<br>17. 使用<code>**</code>表示指数运算，同python；<br>18. <code>Array.from</code>将类数组或可迭代对象转为数组；<code>Array.of</code>将一组值转换为数组；使用<code>includes</code>查找是否在数组中；<br>19. ES6会明确把数组中的空洞转为<code>undefined</code>；<br>20. ES7将引入列表推导，pythoner的最爱之一；<br>21. 函数允许默认参数；引入lambda表达式<code>=&gt;</code>，lambda表达式的this就是外界的this；ES7引入作用域绑定符号<code>::</code>用来绑定lambda的作用域；<br>22. 尾递归优化；<br>23. 可以使用<code>Object.assign</code>进行深拷贝；<br>24. Symbol用来生成独一无二的标识，可以用来当key；<br>25. Proxy可以用来给对象做代理，做一些限制；<br>26. 引入二进制数组；<br>27. 引入Set和Map，注意不能使用<code>[]</code>进行操作；<br>28. 引入<code>for..of..</code>循环，代替原来一些循环方式；注意的是在object中<code>for..of..</code>返回的是value，key仍然用<code>for..in..</code>，但是<code>Map</code>则返回的是<code>[k, v]</code>的一个数组；<br>29. 引入<code>yield</code>作为生成器；<br>30. 引入<code>Promise</code>解决异步编程问题；<br>31. 引入<code>Async</code>，作为生成器的语法糖。使用async将过程转为异步，使用<code>await</code>表示同步阻塞；这个东西是ES6最精华的部分；<br>32. 引入<code>Class</code>语法糖，更加OO. 构造函数是<code>constructor</code>，成员函数无需<code>function</code>关键字；使用<code>extends</code>进行继承；使用<code>super</code>关键字表示父类；可以扩充原生对象；方法前加星号表示生成器函数；<code>static</code>关键字表示静态函数；静态属性只能写在外面，ES7可能可以写在里面；<br>33. 装饰器。<br>34. 导入命令，格式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; stat, exists &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">&#x27;./test&#x27;</span>; <span class="comment">//overide namespace</span></span><br><span class="line"><span class="keyword">import</span> &#123; long <span class="keyword">as</span> l &#125; <span class="keyword">from</span> <span class="string">&#x27;xx&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> xxx;</span><br><span class="line"><span class="keyword">import</span> x <span class="keyword">from</span> xxx; <span class="comment">// import default</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> firstName = <span class="string">&quot;xxx&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="vue要点"><a href="#vue要点" class="headerlink" title="vue要点"></a>vue要点</h2><p>见vue学习笔记</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> javascript </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>erlang速记</title>
      <link href="2017/06/12/erlang%E9%80%9F%E8%AE%B0/"/>
      <url>2017/06/12/erlang%E9%80%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>对于学习过Haskell的人来说，学习Erlang并没有太大的难度。</p><h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><ol><li>首字母小写或者用单引号括起来的表示原子；首字母大写表示变量；原子等于原子本身。</li><li>tuple用{}表示，列表用[]表示；</li><li>用<code>=</code>作模式匹配，用<code>|</code>做头尾区分，用双引号表示字符串（本质是一串数字，可以用<code>$</code>取得字符对应的数字）;</li><li><code>.</code>表示模式终结，<code>,</code>用来分割参数，函数；<code>;</code>用来分割子句；</li><li>函数的参数个数，称为函数的目；<code>func</code>关键字用来定义匿名函数；</li></ol><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">func</span><span class="params">(X, Y)</span> -&gt;</span> math:sqrt(X*X + Y*Y) <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>可以把返回值放到括号里面。<br>6. 标准库<code>lists</code>里面含有很多常见的函数，如<code>map</code>, <code>reduce</code>， <code>filter</code>等；<br>7. 没有<code>for</code>循环，和haskell一样，使用尾递归；<br>8. 使用<code>import</code>, <code>export</code>, <code>module</code>来导入/导出/声明模块；<br>9. 列表解析，格式是<code>[X *2 || X &lt;- L].</code></p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">qsort</span><span class="params">([])</span> -&gt;</span> [];</span><br><span class="line"><span class="function"><span class="title">qsort</span><span class="params">([H|T])</span> -&gt;</span></span><br><span class="line">    qsort([X || X &lt;- T, X &lt; H]) ++</span><br><span class="line">    [H] ++</span><br><span class="line">    qsort([X || X &lt;- T, X &gt;= H]).</span><br></pre></td></tr></table></figure><ol start="10"><li><p>断言，关键字<code>when</code>。使用<code>,</code>表示<code>andalso</code>语义， 使用<code>orelse</code>而不是<code>or</code>因为后者不是短路求值；</p></li><li><p>使用<code>record</code>表示字典，声明方式：</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-record</span><span class="params">(todo, &#123;stats=reminder, who=joe, text&#125;)</span></span><br></pre></td></tr></table></figure><p>需要将其存放在<code>.hrl</code>后缀的文件中，然后使用<code>rr</code>读取。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=#todo&#123;&#125;.</span><br><span class="line">Y=#todo&#123;status=urgent, text=<span class="string">&quot;Fix errata in book&quot;</span>&#125;.</span><br><span class="line">Z=Y#todo&#123;status=done&#125;.</span><br><span class="line">#todo&#123;who=W, text=Txt&#125; = Z <span class="comment">%模式匹配</span></span><br></pre></td></tr></table></figure><p>可以使用<code>is_record</code>做模式匹配；</p></li><li><p><code>case xxx of Pattern1 [when Guard1] -&gt; xxx end</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">odds_and_evens_acc</span><span class="params">(L)</span> -&gt;</span></span><br><span class="line">    odds_and_evens_acc(L, [], []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">odds_and_evens_acc</span><span class="params">([H|T], Odds, Evens)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">case</span> (H <span class="keyword">rem</span> <span class="number">2</span>) <span class="keyword">of</span></span><br><span class="line">        <span class="number">1</span> -&gt; odds_and_evens_acc(T, [H|Odds], Evens);</span><br><span class="line">        <span class="number">0</span> -&gt; odds_and_evens_acc(T, Odds, [H|Evens])</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">odds_and_evens_acc</span><span class="params">([], Odds, Evens)</span> -&gt;</span></span><br><span class="line">    &#123;Odds, Evens&#125;.</span><br></pre></td></tr></table></figure></li><li><p>异常的捕捉采用<code>try...catch..after...end</code>格式，非常类似java；</p></li><li><p>数字格式包括<code>2#01011</code>其中<code>#</code>前面是进制，浮点数可以用科学计数法，即<code>-2.3e+6</code>等；</p></li><li><p>每个进程都有一个私有数据存储，称为进程字典，可以用<code>put</code>,<code>get</code>, <code>get_keys</code>, <code>erase</code>等函数进行操作；但是如果使用进程字典，代码就不再是没有副作用的，因此要避免使用；</p></li><li><p>引用是全局唯一的Erlang值，使用<code>erlang:make_ref()</code>来创建引用；</p></li><li><p>奇怪的操作符： <code>==</code>, <code>/=</code>, <code>=:=</code>全等，<code>=/=</code>不全等；数值比较会有隐式转换；<code>==</code>仅限于浮点数和整数的比较，大部分情况下，应该使用<code>=:=</code>；</p></li><li><p>奇怪的排序：<code>number</code>&lt;<code>atom</code>&lt;<code>reference</code>&lt;<code>fun</code>&lt;<code>port</code>&lt;<code>pid</code>&lt;<code>tuple</code>&lt;<code>list</code>&lt;<code>binary</code>；</p></li><li><p>下划线变量：仅用来声明不准备使用的变量（占位符）；或者用来调试；</p></li><li><p>对于大的程序，还是要使用makefile的，然而直到今天我还是不会写makefile，不过我决定抽个时间学习以下cmake的使用；使用<code>code:get_path()</code>查看搜索路径，<code>code:add_patha</code>, <code>code:add_pathz</code>用来增加新目录；</p></li><li><p>可以在<code>~/.erlang</code>下增加一些命令，当启动<code>erl</code>shell时，会先执行这里的初始化语句；当前目录下的<code>.erlang</code>会覆盖home下的执行优先级。可以使用<code>init:get_argument(home)</code>确定home的路径（for windows）；</p></li><li><p>erlang需要在运行前编译，或者用<code>escript</code>命令执行而无需编译（解释器）。escript的语法与erlang本身略有不同。当然我想不到在什么情况下要写erlang脚本。。。因为erlang并不是一门好的脚本语言。python才是现在的最优选择：）</p></li></ol><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><ol><li>和go一样，很简单的创建进程：<code>Pid=spawn(Fun)</code>；</li><li>发送消息： <code>Pid ! Message</code>，异步发送。返回值是消息本身，这意味着使用<code>Pid1 ! Pid2 ! M</code>会将M发送到所有的Pid中；</li><li><code>receive ... end</code>， 接收一个发送到当前进程的消息；格式是：<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">receive</span></span><br><span class="line">    Pattern1 [When Guard1] -&gt;</span><br><span class="line">        Expression1;</span><br><span class="line">    Pattern2 [When Guard2] -&gt;</span><br><span class="line">        Expression2;</span><br><span class="line"><span class="keyword">after</span> Time -&gt;   <span class="comment">%超时</span></span><br><span class="line">    Expressions</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>消息发送到进程的邮箱中，receive说白了是检查邮箱，如果消息不能匹配任何模式，则会被放到保存队列里；如果有一条消息能成功匹配，则放入保存队列里的旧消息会按着到达的先后顺序重新取出放入邮箱；如果有<code>after</code>设置，计时器到达后也会触发上述规则；</li><li>除了Pid机制外，可以采用注册进程的方式公开进程。<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">register</span><span class="params">(Name, Pid)</span> %将P<span class="title">id</span>注册为N<span class="title">ame</span></span></span><br><span class="line"><span class="function"><span class="title">unregister</span><span class="params">(Name)</span></span></span><br><span class="line"><span class="function"><span class="title">whereis</span><span class="params">(Name)</span> -&gt;</span> Pid | undefined <span class="comment">%检测是否注册成功</span></span><br><span class="line">registered() <span class="comment">%已注册进程list</span></span><br></pre></td></tr></table></figure></li><li>如果想要热更新代码，最好使用MFA（即带着模块名）的调用方式创建进程；</li><li>使用<code>link(Pid)</code>在两个进程之间建立联系。二者之中任意一个挂掉，另一个都会收到系统通知；</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Erlang并不难，但是OTP很难。Erlang设计很用心，目标很明确，对于分布式大型系统的构建提供了很多基础支撑。缺点是生态系统略显封闭，社区不活跃，各种第三方库支持不全。相比之下，个人更看好Go的发展，虽然后者并不是为构建大规模系统而生，但是CPS模型的并发写起来也很舒服，加上简单的语法，快速的编译过程，完善的生态链，杰出的性能，是一个很不错的工具。</p><p>目前来看，Skynet+Lua就是仿制了Erlang的思想。</p>]]></content>
      
      
      
        <tags>
            
            <tag> erlang </tag>
            
            <tag> FP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java Proxy模式</title>
      <link href="2017/06/12/java%20Proxy%E6%A8%A1%E5%BC%8F/"/>
      <url>2017/06/12/java%20Proxy%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>java也可以使用反射生成动态代理，从而完成面向切面编程，这是spring框架的基础。<br>由于java的第一元素只有object，所以函数处于第二阶梯，这导致在其他语言中很容易(函数是第一类的语言中）实现的动态代理，在java中就必须以对象的形式实现。</p><p>在Python中使用<code>getattr(object, method)</code>可以轻易完成反射；最简单的可以这么做：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._real = Real()</span><br><span class="line">        <span class="keyword">for</span> method <span class="keyword">in</span> inspect.getmembers(_real, predicate=inspect.ismethod):</span><br><span class="line">            <span class="built_in">setattr</span>(self, method[<span class="number">0</span>], self._call_real(m[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_call_real</span>(<span class="params">self, method</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_real_proxy</span>(<span class="params">*args, **kargs</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(self._real, method)(*args, **kargs)</span><br><span class="line">        <span class="keyword">return</span> _real_proxy</span><br></pre></td></tr></table></figure><p>java生成动态代理的主要使用了<code>java.lang.reflect.Proxy</code>类的<code>newProxyInstance()</code>方法，其原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                        InvacationHandler h)throws IllegalArgumentException;</span><br></pre></td></tr></table></figure><p>参数：<br>loader - 定义代理类的类加载器<br>interfaces - 代理类要实现的接口列表<br>h - 指派方法调用的调用处理程序<br>返回：<br>一个带有代理类的指定调用处理程序的代理实例，它由指定的类加载器定义，并实现指定的接口<br>抛出：<br>IllegalArgumentException - 如果违反传递到 getProxyClass 的参数上的任何限制<br>NullPointerException - 如果 interfaces 数组参数或其任何元素为 null，或如果调用处理程序 h 为 null</p><p>动态代理类：在运行时生成的class，在其生成过程中，你必须提供一组接口给它，然后该class就声称实现了这些接口。可以把该class的实例当做这些接口中的任何一个来用。其实，这个Dynamic Proxy就是一个Proxy，他不会替你做任何实质性的工作。在生成它的实例时，必须提供一个Handler，由它接管实际的工作。<br>在使用动态代理类时，必须实现InvocationHandler接口。</p><p><code>InvaocationHandler</code>接口必须实现的方法是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object proxy,</span><br><span class="line">              Method method,</span><br><span class="line">              Object[] args)</span><br><span class="line">              throws Throwable</span><br></pre></td></tr></table></figure><p>此处控制流翻转，该方法被回调，传入用户尝试调用的方法和参数，以及代理本身的实例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> design_pattern </tag>
            
            <tag> proxy </tag>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cometd 学习文档</title>
      <link href="2017/06/12/Cometd%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>2017/06/12/Cometd%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ol><li><p>cometd client 分为remote client和local client，remote client即是传统的cometd客户端，分为java和javascript两个版本；当remote client与server建立bayeux协议连接后，server session才被创建；而local client则是server侧的client，当server想要创建一个不与remote client直接连接的session时，必须先创建一个local client；</p></li><li><p>local client的作用在于，如果server并非简单的无条件转发信息到其他remote client，而是想要做一些server端的处理（比如仅仅发往特定的客户端），就需要一个local client。service通道都对应一个local client；</p></li><li><p>通道类型分为meta channel, broadcast channel和service channel，meta channel是禁止订阅的，用来处理协议的基本功能，包括/meta/handshake, /meta/connect, /meta/disconnect, /meta/subscribe, /meta/unsubscribe, /meta/publish, /meta/unsucessful；而broadcast channel类似与聊天室，服务器无条件转发来自broadcast channel的信息到所有的subscribers；service channel则类似于私聊，服务器有条件转发到指定的订阅了该服务的某一个或多个remote client；</p></li><li><p>server端是一个<code>BayeuxServer</code>对象，相关联的对象包括：</p><ul><li>transport，包括http和websocket，或其他自己实现的接口，这里用来实现bayeux的底层通信方式；</li><li>channels，通道</li><li>extensions，扩展用来与bayeux协议交互，是一种listener，可以用于在消息接收后、发送前等时刻对消息进行自定义处理</li><li>authorization，认证机制，一般通过<code>SecurityPolicy</code>来实现；也可以通过<code>Authorizer</code>进行更细粒度（如针对某个channel）的处理；</li><li>消息处理，可以通过回调（监听）对客户端发来的消息进行处理；</li></ul></li><li><p>Listener.</p><ul><li>客户端对某个channel的listener，用来处理服务器发送（或转发）的message(通过<code>ClientSession.getChannel(String).addListener(ClientSessionChannel.MessageListener)</code>来添加)；此外也可以通过添加extension对消息做最初或最后的处理；</li><li>Server端的Listener类似，但更加丰富，包括：<ul><li>extension, 对server的或对session的</li><li>channel create|destroy listener</li><li>subscribe|unsubscribe channel</li><li>session被remove</li><li>与server的message queue交互(<code>MaxQueueListener</code>, <code>DeQueueListener</code>等)</li><li>MessageListener</li></ul></li></ul></li><li><p>消息流动的过程：</p><ol><li>客户端通过client-side的channel发送消息，这些消息首先通过clientsession extension，做最后的过滤；然后通过底层的transport发往server。transport会将message转换为JSON格式，server transport接受到这些消息后，再将JSON字符串转为普通消息；</li><li>消息在server侧首先通过server extension，做最初的处理，此时如果被拒绝，返回给client的错误标示该消息已被删除；</li><li>消息随即被送往serversession extension，如果被拒绝，操作同上；</li><li>消息被送往security policy和authorizers接受审核，如果被拒绝，返回给客户端说明未通过认证；</li><li>消息被送往channel listener，服务器可以在channel listener里面对消息做任意修改；该步骤后，消息被冻结；</li><li>如果是nonbroadcast channel，会随即回复一条消息给发送者，表明服务器已收到消息并且该消息不是广播消息（貌似是将消息原样返回）；</li><li>如果是broadcast message，消息会通过serversession extension，然后插入server的message queue，准备发出；</li><li>如果是lazy message，消息需要等待一段时间，否则消息被立即发送出去；如果消息被发往remote client，会单独开一个线程进行异步发送，后续步骤包括转换为JSON格式，通过底层的transport等，类似客户端发送消息之前的方式；如果是local client，就直接发送过去；</li><li>不管是不是广播消息，消息被插入消息队列后，服务器会返回一条信息给发送者，标明发送结束；</li><li>客户端接收到消息，底层的tranport将消息转回普通格式，然后依次经过client session extension, channel listener和channel subscriber；</li><li>server每收到一条bayeux消息，会分配一个单独的线程进行消息处理，所有的listener都在这个单独的线程中被依序唤醒。client与server之间的连接是有限的，如果同一个连接在短时间内收到大量消息，而消息的处理过程过慢，就会导致后续消息被堵塞而无法得到及时处理。因此服务器在处理消息过程中如果有<strong>耗时处理</strong>，务必要<strong>单开线程</strong>；</li></ol></li><li><p>消息类型：</p><ul><li>客户端发往server的，主要是meta消息；</li><li>客户端发往指定客户端的，需要通过service通道，然后通过clientId deliver过去</li><li>服务器发往客户端的，需要服务器本地起一个local client session，与服务器握手，然后在该通道publish一个消息，这个local client充当了消息的sender</li><li>即使client没有subscribe一个channel，也可以在这个channel上publish message</li></ul></li><li><p>cometd server无法保证消息被正确送往client，除非client和server都打开message acknowledgment extension，这样二者在handshake时会在ext段增加特殊属性，协商完毕后，客户端会对每一条接受到的消息做出应答；这种机制提供了一种<strong>不可靠的</strong>失败重传功能；</p></li><li><p>seti是oort集群时用来发送消息的一种工具，如果a想向b发送信息，但是二者连在不同的comet节点上，这时候就需要转发消息、操作clientId等。seti可以将client与其他标识进行关联，这种关联可以是一对一的，也可以是一对多的。比如说，一个userid有多个deviceid，我们可以将userid与该用户的所有device的clientId都关联起来，也可以将其deviceid和对应的clientid对应起来，这样就可以直接转发了。</p></li><li><p>每个oort节点仅有1个seti对象，当userid第一次与seti关联时，会向所有节点广播此消息，这样其他节点都知道如果需要向某个userid发消息，需要把消息转发给这个seti；用户断开连接或者超时被移除session，这种关联会自动取消。当一个seti中，userid关联的所有session都断开连接时，userid会解除与seti的关联，然后广播此消息。我们可以监听这两种广播消息。</p></li><li><p>通过seti发送消息很简单，我们只需要指定userid，seti会自动找到其所连接的comet节点，进行发送；</p></li><li><p>comet节点之间的数据共享。<code>OortObject</code>用于解决此问题，这是一个分布式的架构，所有节点拥有此对象，此对象存放所有节点的共享数据，每个节点只能修改属于自己的那一部分，其他的是只读的，每次修改会广播给其他节点，其他节点可以监听这种广播，并做一些自定义修改。</p></li><li><p>服务转发功能，如果集群各个节点提供的服务不一致，可能需要此功能用于转发服务。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> cometd </tag>
            
            <tag> java </tag>
            
            <tag> push </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cometd使用haproxy做负载均衡的配置指南</title>
      <link href="2017/06/12/cometd%E4%BD%BF%E7%94%A8haproxy%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
      <url>2017/06/12/cometd%E4%BD%BF%E7%94%A8haproxy%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>Ubuntu14.04直接用apt安装就是最新的稳定版，其他旧版本Ubuntu需要使用ppa获得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:vbernat&#x2F;haproxy-1.5</span><br></pre></td></tr></table></figure><p>然后update，install即可。<br>(PS: 如果连<code>add-apt-repository</code>都不能用，先执行<code>sudo apt-get install python-software-properties</code>）</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>理论上直接用<code>sudo service haproxy start|stop|restart|status|reload</code>就可以，不过ubuntu直接安装后这个命令是没法用的…需要编辑<code>/etc/init.d/haproxy</code>，然后把<code>ENABLED=0</code>改成<code>ENABLED=1</code>，然后删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ -e &#x2F;etc&#x2F;default&#x2F;haproxy ]; then</span><br><span class="line">. &#x2F;etc&#x2F;default&#x2F;haproxy</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这几行。当然，也可以直接使用<code>sudo haproxy -f /etc/haproxy/haproxy.conf </code>来启动，加上<code>-d</code>参数可以在前台运行调试。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>如果同时使用两种transport(websocket和http)，需要注意long-polling的session保持问题。如果只使用websocket，需要注意的只有timeout的设置问题。</p><p>典型配置如下<a href="http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/">^1</a>，默认路径为<code>/etc/haproxy/haproxy.conf</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">  log 127.0.0.1 local0  #see &#x2F;etc&#x2F;rsyslog.d&#x2F;haproxy.conf</span><br><span class="line">  chroot &#x2F;var&#x2F;lib&#x2F;haproxy</span><br><span class="line">  pidfile &#x2F;var&#x2F;run&#x2F;haproxy.pid</span><br><span class="line">  uid 99</span><br><span class="line">  gid 99</span><br><span class="line">  daemon        #run as service</span><br><span class="line">  nbproc 1      #only one instance allowed</span><br><span class="line">  maxconn 120000</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">  mode http</span><br><span class="line">  log global</span><br><span class="line">  option httplog        #log http info</span><br><span class="line">  option  http-server-close     #Don&#39;t keepalive between haproxy and server</span><br><span class="line">  option  redispatch    #if health check failed, dispath new server</span><br><span class="line">  option  forwardfor    #for server get Ip of client</span><br><span class="line">  retries 3             #connect to server fail max times before redispatch</span><br><span class="line">  timeout connect 10s   #timeout tcp connection between haproxy and backend servers</span><br><span class="line">  timeout client 50s    #timeout client inactivity</span><br><span class="line">  timeout server 50s    #timeout for server to process the request</span><br><span class="line">  timeout queue 30s     #timeout for request in queue when server reach max connection</span><br><span class="line">  timeout http-keep-alive 2s</span><br><span class="line">  timeout http-request 15s</span><br><span class="line">  default-server inter 5s rise 2 fall 3</span><br><span class="line">  stats uri &#x2F;stats</span><br><span class="line">  stats refresh 10s</span><br><span class="line">  stats auth baina:P@55word</span><br><span class="line"></span><br><span class="line">frontend ft_web</span><br><span class="line">  bind *:80</span><br><span class="line">  timeout client 10m</span><br><span class="line">  timeout client-fin 5s</span><br><span class="line">  maxconn 120000</span><br><span class="line">  option  http-pretend-keepalive        #without this, handshake can&#39;t be established</span><br><span class="line">  default_backend cometd</span><br><span class="line"></span><br><span class="line">backend cometd</span><br><span class="line">  timeout server 10m</span><br><span class="line">  timeout tunnel 10m</span><br><span class="line">  balance roundrobin</span><br><span class="line">#  balance source</span><br><span class="line">  option httpchk GET &#x2F;cometd HTTP&#x2F;1.1\r\nHost:\ \r\nConnection:\ upgrade\r\nUpgrade:\ websocket</span><br><span class="line">  http-check expect status 101</span><br><span class="line">  cookie SERVERID insert</span><br><span class="line"></span><br><span class="line">  appsession SERVERID len 25 timeout 15m        #for Long-polling keep session</span><br><span class="line"></span><br><span class="line">server bayuex-srv1 10.232.2.118:80 maxconn 40000 weight 10 cookie bayuex-srv1 check</span><br><span class="line">server bayeux-srv2 10.235.30.6:80 maxconn 40000 weight 10 cookie bayeux-srv2 check</span><br><span class="line">server bayeux-srv3 10.45.160.213:80 maxconn 40000 weight 10 cookie bayexu-srv3 check</span><br></pre></td></tr></table></figure><p>存活检测通过<code>httpchk</code>选项来完成，cometd要求必须使用http1.1，因此header中必须要有Host，这里留空。</p><p>这里通过插入cookie来满足long polling的session保持需求，这要求client每次post都必须携带server发给client的cookie。当然这个问题也可以通过<code>balance source</code> hash ip来解决，但是后者可能会导致负载均衡度不高。</p><p><strong>注意</strong>，如果使用long polling，切记加上<code>option http-pretend-keepalive</code>，不然server会把<code>Connection: close</code>发给client，握手直接被终结.</p><h2 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h2><p>上述配置中，<code>log 127.0.0.1 local0</code>这句是用来配置log的，如果使用syslog，在<code>/etc/syslog.conf</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local0.* &#x2F;var&#x2F;log&#x2F;haproxy&#x2F;haproxy.log</span><br></pre></td></tr></table></figure><p>即可指定到具体文件。</p><p>ubuntu使用rsyslog，因此对应的配置方法如下<a href="http://blog.hintcafe.com/post/33689067443/haproxy-logging-with-rsyslog-on-linux">^2</a>，默认路径<code>/etc/rsyslog.d/haproxy.conf</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ModLoad imudp</span><br><span class="line">$UDPServerRun 514</span><br><span class="line">$template Haproxy,&quot;%msg%\n&quot;</span><br><span class="line">local0.* -&#x2F;var&#x2F;log&#x2F;haproxy.log;Haproxy</span><br><span class="line">&amp; ~</span><br></pre></td></tr></table></figure><p><strong>为使配置生效，请将文件名改为49-haproxy.conf</strong><br>日志的格式<a href="http://www.rsyslog.com/doc/rsyslog_conf_templates.html">^3</a>可以通过配置<code>$template</code>参数来完成，这里写了最简单的一种输出格式。</p><p>日志滚动通过配置<code>/etc/logrotate.d/haproxy</code>来实现，默认有一个按日滚动的策略，一般够用了。<br>其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;log&#x2F;haproxy.log &#123;</span><br><span class="line">    daily       #按日滚动</span><br><span class="line">    rotate 10   #保留10个</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    postrotate</span><br><span class="line">        invoke-rc.d rsyslog rotate &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 || true</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##DDOS防范<br>haproxy可以用来做ddos防范，具体可参见：<br><a href="http://blog.sina.com.cn/s/blog_704836f40101f4qh.html">http://blog.sina.com.cn/s/blog_704836f40101f4qh.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cometd </tag>
            
            <tag> haproxy </tag>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CometD源码学习[0]</title>
      <link href="2017/06/12/CometD%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0_1/"/>
      <url>2017/06/12/CometD%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0_1/</url>
      
        <content type="html"><![CDATA[<h2 id="jetty生命周期"><a href="#jetty生命周期" class="headerlink" title="jetty生命周期"></a>jetty生命周期</h2><p>Jetty的核心组件是<code>Server</code>和<code>Connector</code>，<code>Server</code>基于<code>Handler</code>容器工作，里面包括<code>ServletHandler</code>，<code>SessionHandler</code>等处理器，<code>Server</code>本身也继承自<code>Handler</code>类。<code>Connector</code>类用于监听连接请求；此外还有<code>Container</code>用来管理<code>MBean</code>。<br>Jetty的Server扩展是通过实现<code>Handler</code>并将至注册到<code>Server</code>中来实现的。<br>整个Jetty的组件的生命周期管理是基于观察者模板设计的，每个组件都有个<code>Listener</code>，用来监听Jetty启动/停止过程中的事件。</p><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>Jetty本身提供了两类<code>HandlerWrapper</code>和<code>ScopeHandler</code>两种<code>Handler</code>，前者是一个装饰器修饰的<code>Handler</code>，用来做委托(<code>Proxy</code>模式)，后者是一个拦截器——在调用<code>Handler</code>之前或之后做某些事情。</p><h3 id="prestart"><a href="#prestart" class="headerlink" title="prestart"></a>prestart</h3><p>Jetty在启动之前会先初始化jetty的相关配置(start.ini)，然后通过自己的<code>IOC</code>(<code>XmlConfiguration</code>)将这些服务组装在一起，最后调用<code>start</code>启动这些组件。其中最重要的配置文件包括<code>jetty.xml</code>, <code>jetty-deploy.xml</code>以及<code>contexts/*.xml</code>。然后根据配置文件中的参数新建一个进程应用JVM参数（如果有<code>--exec</code>，没有的话不会再起新的进程，<code>start.ini</code>中的JVM参数就不可能重新得到应用)。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Jetty的启动入口是<code>Server</code>类或者其子类。下图是Jetty启动过程：<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-jetty/image011.jpg" alt="Jetty Start process"><br>在创建线程池后，Server开始依次调用已注册Handler组件的<code>Start</code>方法，直至整个调用链结束（调用链的末尾应该是用户自定义的service），这一步是初始化各组件（filter, servlet，包括用户的服务）的配置；然后启动<code>Container</code>中已注册的MBean（for JMX），最后启动<code>Connector</code>开始接受请求。</p><p>Jetty作为一个轻量级web容器，不仅可以接受http协议作为web服务器，还可以与其他web应用服务器集成（如Jboss或Apache），这时候Jetty工作于AJP协议。</p><h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><p>对于http协议，按着传统的划分方式，分为BIO（阻塞式）和NIO（非阻塞式），以及AIO（异步式），windows的IOCP是AIO。</p><blockquote><p>BIO是一个连接一个线程。<br>NIO是一个请求一个线程。<br>AIO是一个有效请求一个线程。</p></blockquote><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>如果jetty工作在BIO模式（选用<code>org.eclipse.jetty.server.bi.SocketConnector</code>作为<code>Connector</code>），建立连接的步骤分为：</p><ol><li>创建队列线程池，用于处理请求；</li><li>创建ServerSocket用于准备接受请求；</li><li>创建一个或多个监听线程（Accptor)，开始监听。</li><li>对于每个连接，BIO从线程池中分配一个线程进行处理；<br>时序图如下：<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-jetty/image013.jpg" alt="Connect process"></li></ol><p>Accptor对每个请求创建ConnectorEndPoint，后者对实际消息做出具体解析并应答。Jetty9 移除了BIO的Connecter（现在是异步的世界了…）<br>如果工作在AJP协议下，与 HTTP 方式唯一不同的地方的就是将 SocketConnector 类替换成了 Ajp13SocketConnector，即监听的协议不同而已。</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO是非阻塞的，类似于linux中的<code>select</code>系统接口：</p><ol><li>创建N个<code>Acceptor</code>对象，每个对应一个<code>SelectSet</code>对象，用于存放已注册的socket集合；</li><li>创建N个<code>Selector</code>线程用于轮询<code>SelectSet</code>(<code>select</code>)或监听<code>SelectSet</code>中的事件(<code>epoll</code>)，线程数同<code>Acceptor</code>的个数(<code>jetty.xml</code>中指定）；</li><li><code>Connector</code>接受(<code>accept</code>)到请求，得到<code>Socket</code>，将之设为非阻塞，然后以轮询机制分发给<code>Acceptor</code>并返回（异步)；</li><li><code>Acceptor</code>将之放入自己的<code>SelectSet</code>，并返回；</li><li><code>Selector</code>检测到新的<code>Socket</code>，开始监听该<code>Socket</code>的<code>read</code>事件（<code>select</code>）；</li><li>一旦有新事件到来，立刻新建<code>ConnectorEndPoint</code>，调用<code>schedule</code>方法并返回继续监听该<code>Socket</code>（异步）；</li><li><code>schedule</code>方法调用线程池中的线程，进行实际的逻辑处理(<code>worker</code>)，该线程会调用<code>Server</code>的<code>handle</code>方法，这里形成<code>handle</code>的调用链（这是在server启动前注册到server中的）。</li></ol><p>NIO的一般工作原理用代码描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();   <span class="comment">//实例化selector</span></span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open(); <span class="comment">//实例化socket</span></span><br><span class="line">ssc.configureBlocking( <span class="keyword">false</span> );  <span class="comment">//非阻塞</span></span><br><span class="line">SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT ); <span class="comment">//注册事件</span></span><br><span class="line">ServerSocketChannel ss = (ServerSocketChannel)key.channel();</span><br><span class="line">SocketChannel sc = ss.accept();</span><br><span class="line">sc.configureBlocking( <span class="keyword">false</span> );</span><br><span class="line">SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );</span><br><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>java7开始支持AIO，而jetty则从jetty9开始支持这一特性。AIO在linux上使用<code>epoll</code>完成，在windows上则使用IOCP（IO完成端口）完成。</p><p>一般而言，AIO对应<code>Proactor</code>模式，NIO对应<code>Reactor</code>模式，两者最大的区别在于IO是由谁来完成：AIO中，由内核完成IO，然后将结果通知给用户（信号/回调函数）；NIO中，内核只是将准备好进行IO的描述符通知给用户（信号/回调函数），然后由用户自己处理IO。</p><hr><p>需要了解的预备知识到此结束，下一篇开始正式分析CometD源码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> cometd </tag>
            
            <tag> jetty </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CometD源码学习[1]</title>
      <link href="2017/06/12/CometD%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0_2/"/>
      <url>2017/06/12/CometD%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0_2/</url>
      
        <content type="html"><![CDATA[<p>首先学习server部分，主要包括<code>cometd-java-server</code>这个package，同时涉及到<code>cometd-java-common</code>和<code>bayeux-api</code>这两个package。</p><h2 id="org-cometd-server-CometDServlet"><a href="#org-cometd-server-CometDServlet" class="headerlink" title="org.cometd.server.CometDServlet"></a>org.cometd.server.CometDServlet</h2><p>在web.xml中，服务的配置顺序一般是<code>CometDServlet</code>，<code>oort</code>，<code>seti</code>和用户自定义应用的<code>Servlet</code>，我们也按这个顺序来看。显然，这个类主要用于Long-Polling模式。<br><code>init</code>中主要就是新建（如果未导出）并启动一个bayeuxServer;<br><code>service</code>中，”OPTION”请求，用于允许CORS访问，直接返回200；否则转发给transport；<br><code>destroy</code>用于生命周期中stop过程调用，依次cancelSchedule, stop bayeuxServer, remove导出的bayeuxServer.</p><h2 id="org-cometd-server-BayeuxServer"><a href="#org-cometd-server-BayeuxServer" class="headerlink" title="org.cometd.server.BayeuxServer"></a>org.cometd.server.BayeuxServer</h2><p>这个接口规定了bayeux服务器需要实现的接口。值得关注的地方：</p><ol><li>可监听事件：<br> a. ChannelListener用于监听add/remove Channel的事件；<br> b. SessionListener用于监听add/remove Session的事件，这个比较重要。可以通过Session建立事件来给client push 欢迎消息，通过Session removed事件来确认client断开连接。<br> c. SubscriptionListener用于监听订阅事件；</li><li>extension接口:<br> extension本质是一个消息钩子，可以在rcv之初/send之末对消息做一些修改（主要是操作bayeux协议的<code>ext</code>字段），所以参数中ServerMessage都是Mutable的.这里normal message和meta message被区分开来。</li></ol><h2 id="org-cometd-server-BayeuxServerImpl"><a href="#org-cometd-server-BayeuxServerImpl" class="headerlink" title="org.cometd.server.BayeuxServerImpl"></a>org.cometd.server.BayeuxServerImpl</h2><p>顾名思义，bayeuxServer的实现类。<br><code>VALID</code>用了一个技巧，即字符本质上是一个short的ASCII码；<br><code>System.identityHashCode</code>用于获取对象的原始hashcode码；<br><code>SecureRandom</code>是一个强加密的随机数类；<br><code>listeners</code>, <code>extension</code>都被存放在线程安全的<code>CopyOnWriteArrayList</code>里面；<br>client_id与<code>ServerSessionImpl</code>、channel_name与<code>ServerChannelImpl</code>的映射也被存放在线程安全的<code>ConcurrentHashMap</code>里面；<br>Server支持的transport被存入<code>LinkedHashMap</code>里面，因为transport的顺序很重要，优先使用迭代中最前的，不可行时才使用后续者；<br><code>currentTransport</code>是一个<code>ThreadLocal</code>变量，因为每个线程（连接）当前的Transport肯定不一样。</p><p>_scheduler是一个周期性定时器，此外是一个policy、一个JSON的server，这三个变量。</p><h3 id="dostart"><a href="#dostart" class="headerlink" title="dostart"></a>dostart</h3><ol><li>首先初始化Meta Channel：创建Channel并增加相关的Listener；</li><li>初始化JSON服务器，这里有一个缺省的实现（<code>JettyJSONContextServer</code>），但是用户也可以通过option自定义一个实现类（通过反射，使用<code>isAssignableFrom</code>判断是否是<code>JSONContext.Server</code>的子类）；</li><li>初始化transport.如果没有设置，初始化为websocket接口，否则依序初始化配置文件中指定的端口并添加到容器中；如果<code>allowedTransports</code>没有设置，默认允许所有transport，否则依序初始化配置文件中允许的且存在于transport列表中的transport；上述所有数据都被添加到公用的容器中了。</li><li>启动_scheduler，执行周期性扫除(sweep)任务（每次计时任务结束后需要手动再启动定时任务），该任务会扫描所有Channel和端口以及session，扫描周期默认是997ms，可以自己设置。<br>session扫描即服务端超时机制，如果now&gt;一定时间间隔，则从服务端移除session；Channel扫描就是检测Channel的订阅数量，如果没有活动的（即已握手的session的）订阅，那么就从BayeuxServer中清除（除非设置为<code>persistent</code>）；</li><li>最后是2.9新增的<code>validateMessageFields</code>用于校验消息格式。</li></ol><h3 id="createChannelIfAbsent"><a href="#createChannelIfAbsent" class="headerlink" title="createChannelIfAbsent"></a>createChannelIfAbsent</h3><p>创建通道，传入channel名和初始化器。<br>如果Channel name尚不存在：</p><ol><li>根据channel name创建<code>ChannelId</code>，然后创建一个新的<code>ServerChannelImpl</code>，后者是一个<code>ServerChannel</code>接口的实现类。注意在<code>ServerChannelImpl</code>的构造函数中，如果非broadcast channel，会被设置为persistent的；</li><li>存放channel，会再次检测channel是不是已经存在（多线程检测），确认无误后，开始配置channel；使用传入的<code>initializers</code>和已注册的<code>listener</code>配置channel；</li><li>初始化完毕，触发ChannelListener的Channel added事件；<br>如果Channel name已存在：<br>什么都不做，简单的给将channel的存活评估值（_sweeperPasses)重置。会再次check channel（<code>putIfAbsent</code>）是不是已存在于容器中。</li></ol><h2 id="PushServlet"><a href="#PushServlet" class="headerlink" title="PushServlet"></a>PushServlet</h2><p>先跳过Oort和Seti，直接看PushServlet（我们的应用程序）。<br>由于在CometDServlet里面已经导出了<code>bayeuxServer</code>，这里可以通过<code>getServletContext()</code>直接拿到Server了.<br>现在可以创建<code>SecurityPolicy</code>和<code>PushService</code>了。</p><h2 id="AbstractService"><a href="#AbstractService" class="headerlink" title="AbstractService"></a>AbstractService</h2><p>顾名思义，这个类是<code>abstract</code>的，注意构造函数里面会先create一个<code>LocalSession</code>，然后自己和自己握手。这个LocalSession本子上是用于服务端主动publish消息的.<br><strong>初始化的时候可以指定线程池的大小，否则使用同步访问。</strong>显然，如果不使用线程池，那么在处理消息时如果有费时间的操作，必须新建线程。<br>这里用了一个技术，使用反射技术查看自己所处的类的<code>Modifier</code>是不是<code>public</code>的。</p><h3 id="addService"><a href="#addService" class="headerlink" title="addService"></a>addService</h3><p>创建Channel后，正常流程走到这里。传入channel name和callback func name，利用反射技术进行映射。<br><code>getClass</code>拿到类，然后从当前开始逐层向上遍历直到<code>AbstractService</code>，执行以下操作：<br><code>getDeclaredMethods</code>拿到方法集合，遍历方法集合，判定名称相等且有<code>public</code>描述符，那么找到候选<code>Method</code>。<br>候选<code>Method</code>的参数必须符合固定的签名类型，这里用<code>isAssignableFrom</code>配合<code>getParameterTypes()</code>来进行判断；<br><strong>注意</strong>：这里会主动调用<code>createChannelIfAbsent</code>创建服务（这里就没机会做配置了）；</p><p>创建一个<code>Invoker</code>，在并行队列里放入<code>messageName</code>和<code>Invoker</code>的映射。<br>该<code>Invoker</code>被增加为Channel的Listener.</p><h3 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h3><p>所有消息首先经过该函数进行分发。<br>首先验证消息，创建回复并关联。调用接受的extension对消息进行扩展；从消息中取出channel，对消息进行认证(<code>Authorizer</code>)；然后依据是否是Meta消息进行不同的分发，无论是接受消息还是发送消息，最终都是调用了<code>doPublish</code>方法。</p><h2 id="AbstractService-Invoker"><a href="#AbstractService-Invoker" class="headerlink" title="AbstractService.Invoker"></a>AbstractService.Invoker</h2><p><code>ServerChannel.MessageListener</code>接口的实现类。</p><h3 id="OnMessage"><a href="#OnMessage" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>消息的观察者。<br>Server可以通过<code>isSeeOwnPublish</code>相关参数的配置控制是否接收自己publish的消息，然后调用(<code>invoke</code>）回到函数。如果初始化的时候传递了最大线程数，那么这里就从线程池里面拿线程然后处理消息；<strong>否则直接在当前线程里面处理消息</strong>(<code>doInvoke</code>)；<br>如果回调函数的签名中有返回值，这个值会被立刻返回(send)给client端。</p><p>现在再次回到<code>BayeuxServerImpl</code>类中，<code>doStart</code>会给所有的<code>Meta</code> Channel增加Listener，这是预置的Meta handler；按着Bayeux协议约定的过程，client会首先handshake。</p><h2 id="BayeuxServerImpl-HandshakeHandler"><a href="#BayeuxServerImpl-HandshakeHandler" class="headerlink" title="BayeuxServerImpl.HandshakeHandler"></a>BayeuxServerImpl.HandshakeHandler</h2><p>先看父类，<code>HandlerListener</code>是<code>ServerChannel.ServerChannelListener</code>的实现类。<br><code>isSessionUnknown</code>没啥好说的；<code>toChannelList</code>有个有趣的地方，可以用<code>Collections.singletonList</code>生成单元素列表），对某些需要传一个集合，但是实际上只要传一个元素的API很有用；</p><h3 id="OnMessage-1"><a href="#OnMessage-1" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>handshake的时候session理论上还不存在，于是新建一个<code>ServerSession</code>，并且将HTTP的相关报头转移过来（UA），然后得到关联(<code>getAssociated</code>)的消息实体（消息可能是捎带回去的）。<br>这时候先判断<code>SecurityPolicy</code>有没有设置，如果设置了，就先判断<code>canHandshake</code>是不是成立，如果不成立，就要<code>reply.setSuccessful(false)</code>，并设置错误原因。</p><p>这里有个问题，reply并没有传给<code>canHandshake</code>，但是<code>message</code>被传进去了。根据<code>ServerMessageImpl</code>的实现，<code>canHandshake</code>也可以用<code>message.getAssociated</code>里面拿到reply，然后增加想要的字段（ext）。代码显示，这里并没有往advice里面添加重连间隔（<code>interval</code>)字段。<br>【这里显示了nest class如何得到outer class的实例，直接用<code>BayeuxServerImpl.this</code>.】</p><p>一切正常，<code>ServerSession</code>首先和自己握手，增加<code>ServerSession</code>（在此处<strong>通知回调</strong>，即应用程序注册的监听Session添加的方法），定义reply中的某些字段；如果<code>canHandshake</code>返回false，则返回403（handshake denied）错误；注意：如果应用程序的监听器没有设置<code>advice</code>中的<code>reconnect</code>字段，这里默认会填入<code>none</code>。</p><p><code>reconnect</code>字段分为3种，正常是<code>retry</code>；<code>handshake</code>一般是402错误，要求重新握手；<code>none</code>就是禁止自动重连了。<a href="http://docs.cometd.org/reference/bayeux_message_fields.html">^1</a></p><h2 id="BayeuxServerImpl-ConnectHandler"><a href="#BayeuxServerImpl-ConnectHandler" class="headerlink" title="BayeuxServerImpl.ConnectHandler"></a>BayeuxServerImpl.ConnectHandler</h2><p>心跳信息处理。</p><h3 id="OnMessage-2"><a href="#OnMessage-2" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>如果session未知，那就需要重新握手，返回402错误。否则对session进行续期，并返回advice，内容包括<code>timeout</code>和<code>interval</code>字段（如果没有设置，默认是不过期的）</p><h2 id="BayeuxServerImpl-SubscribeHandler"><a href="#BayeuxServerImpl-SubscribeHandler" class="headerlink" title="BayeuxServerImpl.SubscribeHandler"></a>BayeuxServerImpl.SubscribeHandler</h2><p>订阅Channel处理。</p><h3 id="OnMessage-3"><a href="#OnMessage-3" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>402同上。如果没有<code>subscription</code>字段或者字段不符合格式，403；如果Channel不存在，尝试创建Channel(policy的<code>canCreate</code>，以及内部Channel格式约束)，失败则403。</p><h2 id="BayeuxServerImpl-UnsubscribeHandler"><a href="#BayeuxServerImpl-UnsubscribeHandler" class="headerlink" title="BayeuxServerImpl.UnsubscribeHandler"></a>BayeuxServerImpl.UnsubscribeHandler</h2><p>退订处理。</p><h3 id="OnMessage-4"><a href="#OnMessage-4" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>退订只要session存在，消息格式正确，没有理由不让你退XD</p><h2 id="BayeuxServerImpl-DisconnectHandler"><a href="#BayeuxServerImpl-DisconnectHandler" class="headerlink" title="BayeuxServerImpl.DisconnectHandler"></a>BayeuxServerImpl.DisconnectHandler</h2><p>断开连接处理。</p><h3 id="OnMessage-5"><a href="#OnMessage-5" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>session存在即可断开。<br>会激活移除session的回调（timeout=false）<br>刷新session=&gt;</p><h2 id="ServerSessionImpl"><a href="#ServerSessionImpl" class="headerlink" title="ServerSessionImpl"></a>ServerSessionImpl</h2><h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>刷新session会取消上一次的lazyTask；</p><h3 id="LazyTask"><a href="#LazyTask" class="headerlink" title="LazyTask"></a>LazyTask</h3><p><code>Runnable</code>子类，其<code>scheduler</code>方法最终调用<code>BayeuxServerImpl</code>中的同名方法，作为一个计划任务执行（<code>Scheduler</code>是jetty的基础工具类）。</p><h3 id="Setxxx"><a href="#Setxxx" class="headerlink" title="Setxxx"></a>Setxxx</h3><p>可以设置的包括：<br>Interval<br>timeout</p><h3 id="ServerSessionListener"><a href="#ServerSessionListener" class="headerlink" title="ServerSessionListener"></a>ServerSessionListener</h3><p>可以监听的事件包括：<br><code>RemoveListener</code>=&gt;移除Session时通知<br><code>MessageListener</code>=&gt;有消息时通知<br><code>QueueListener</code>=&gt;消息被加入队列时通知<br><code>DeQueueListener</code>=&gt;消息出列时通知<br><code>MaxQueueListener</code>=&gt;队列满时通知</p>]]></content>
      
      
      
        <tags>
            
            <tag> cometd </tag>
            
            <tag> jetty </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake实践</title>
      <link href="2017/06/12/cmake%E5%AE%9E%E8%B7%B5/"/>
      <url>2017/06/12/cmake%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>heka使用了cmake进行构建，cmake是目前最好的大型项目构建工具（比autoconf之类的都要好），有很强的学习价值。另外JetBrain的CLion也是用cmake进行构建的。</p><p>初级学习材料是<a href="http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf">CMake Practice</a>这本书.</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(HELLO)</span><br><span class="line"><span class="keyword">SET</span>(SRC_LIST main.c)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is BINARY dir&quot;</span> <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is SOURCE dir&quot;</span> <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>上面是一个最简单的CMakeLists.txt示例，也很容易理解。使用<code>SET</code>命令设置变量，使用<code>MESSAGE</code>命令显示信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] &quot;message to display&quot;)</span><br></pre></td></tr></table></figure><p>使用空格键分割参数。</p><p><code>ADD_EXECUTABLE</code>添加生成的可执行文件，第一个参数是可执行文件的名字（与项目没什么关系）。</p><p>一般情况下，使用<code>$&#123;&#125;</code>引用变量，但是如果在<code>IF</code>中，则默认就是一个变量名，这时候就不要再解引用了。</p><p>指令是大小写无关的，参数和变量是大小写敏感的，但是一般情况下推荐使用全大写的指令。</p><p>由于参数使用空格做分隔符，因此若某些参数中间含有空格（如文件名），则需要用引号包围。另外就是文件后缀可以省略，如果确定不会重复的话（推荐保留）。</p><p>另外就是参数也可以用分号分割，注意前后保持一致就行。</p><h3 id="外部构建"><a href="#外部构建" class="headerlink" title="外部构建"></a>外部构建</h3><p>上面的例子是内部构建，生成了一大堆中间文件，cmake官方更推荐使用外部构建。</p><p>删除除了<code>CMakeLists.txt</code>和<code>main.c</code>之外的所有文件，建立一个<code>build</code>目录。然后运行<code>cmake &lt;项目路径&gt;</code>，构建的中间文件和输出的MakeFile都会出现在这个目录里，对原来的项目没有影响。唯一不同的是<code>PROJECT_BINARY_DIR</code>指向<code>build</code>目录了。</p><h3 id="进一步复杂化"><a href="#进一步复杂化" class="headerlink" title="进一步复杂化"></a>进一步复杂化</h3><p>添加<code>src</code>子文件夹，将<code>main.c</code>移入。然后在其中再新建一个<code>CMakeLists.txt</code>。外部改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROJECT(HELLO)</span><br><span class="line">ADD_SUBDIRECTORY(src bin)</span><br></pre></td></tr></table></figure><p>内部的写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD_EXECUTABLE(hello main.c)</span><br></pre></td></tr></table></figure><p>再在<code>build</code>文件夹下cmake，就可以<code>build/bin/</code>文件夹下生成科执行文件。</p><p>可以通过修改<code>EXECUTABLE_OUTPUT_PATH</code>和<code>LIBRARY_OUTPUT_PATH</code>来修改最终输出的可执行文件或者链接库的路径。一般写在<code>ADD_EXECUTABLE</code>后面。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装使用<code>cmake -DCMAKE_INSTALL_PREFIX=&lt;dir&gt;</code>来指定安装目录。在根目录的<code>CmakeLists.txt</code>里面写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSTALL(FILES COPYRIGHT README DESTINATION share&#x2F;doc&#x2F;cmake&#x2F;t2)</span><br><span class="line">INSTALL(PROGRAMS runhello.sh DESTINATION bin)</span><br><span class="line">INSTALL(DIRECTORY doc&#x2F; DESTINATION share&#x2F;doc&#x2F;cmake&#x2F;t2)</span><br></pre></td></tr></table></figure><p>这里用了<code>INSTALL</code>指令，第一个参数表示写入文件类型，<code>DESTINATION</code>后面是写入的目标位置。</p><p>INSTALL指令参数较多，使用时可以参考文档。</p><h3 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h3><p>除了目录名外，与构建可执行文件的主要区别是lib文件夹中的CMakeLists.txt中加入了命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SET(LIBHELLO_SRC hello.c)</span><br><span class="line">ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line">ADD_LIBRARY(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES OUT_NAME &quot;hello&quot;)</span><br><span class="line">SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUPUT 1)</span><br><span class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUPUT 1)</span><br><span class="line">SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</span><br><span class="line">INSTALL(TARGETS hello hello_static</span><br><span class="line">        LIBRARY DESTINATION lib</span><br><span class="line">        ARCHIVE DESTINATION lib)</span><br><span class="line">INSTALL(FILES hello.h DESTINATION include&#x2F;hello)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ADD_LIBRARY</code>第二个参数指出了库的类型，可以用<code>STATIC</code>参数构建静态库，<code>SHARD</code>构建动态库。</p><p>由于<code>ADD_LIBRARY</code>第一个参数不能重复，所以同时生成静态库需要 <code>SET_TARGET_PROPERTIES</code>. 该命令用来设置很多目标属性，包括版本信息等。这里设置了防止同名删除库，以及版本信息。</p><h3 id="使用外部共享库"><a href="#使用外部共享库" class="headerlink" title="使用外部共享库"></a>使用外部共享库</h3><p>如果依赖外部库，且该库并不存在于系统搜索路径里， 需要使用<code>INCLUDE_DIRECTORIES</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)</span><br></pre></td></tr></table></figure><p>仅仅是这样还不够，上面只是指出了头文件的位置。链接库的位置需要使用<code>LINK_DIRECTORIES</code>或<code>TARGET_LINK_DIRECTORIES</code>。假设上面我们已经把库安装到<code>/usr</code>文件下，在<code>CMakeLists.txt</code>中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)</span><br><span class="line">TARGET_LINK_LIBRARIES(main libhello.so)</span><br></pre></td></tr></table></figure><p>即可正常编译链接通过了。</p><p>也可使用<code>CMAKE_INCLUDE_PATH</code>和<code>CMAKE_LIBRARY_PATH</code>这两个特殊的环境变量为编译添加额外搜索路径。比如上面我们也可以先在bash里面<code>export CMAKE_INCLUDE_PATH=/usr/include/hello</code>，然后将上面的<code>INCLUDE_DIRECTORIES</code>变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FIND_PATH(myHeader hello.h)</span><br><span class="line">IF(myHeader)</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;myHeader&#125;)</span><br><span class="line">ENDIF(myHeader)</span><br></pre></td></tr></table></figure><h3 id="常用变量-环境变量"><a href="#常用变量-环境变量" class="headerlink" title="常用变量/环境变量"></a>常用变量/环境变量</h3><p>使用<code>SET</code>定义的是显式定义，除此之外，一些指令可以定义隐式变量。当然还有一些内置变量。</p><p>使用<code>$ENV&#123;NAME&#125;</code>来调用环境变量，设置环境变量则是<code>SET(ENV&#123;变量名&#125; 值)</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python celery组件使用</title>
      <link href="2017/06/12/python%20celery%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
      <url>2017/06/12/python%20celery%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h2><p>install:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install celery</span><br></pre></td></tr></table></figure><p>选择broker，安装，这里假设使用Redis：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install redis-server</span><br></pre></td></tr></table></figure><h2 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h2><p>首先认真阅读<a href="http://docs.celeryproject.org/en/latest/index.html">官方celery文档</a>的get start部分，如果有时间的话，最好全部看一边…</p><p>然后参考阅读别人的<a href="http://blog.csdn.net/orangleliu/article/details/37967433">best practices</a>，基本就可以干活了。</p><h3 id="几个要点"><a href="#几个要点" class="headerlink" title="几个要点"></a>几个要点</h3><ol><li>task相关的文件，最好都是用绝对导入；否则，应该在task function上面指定name；</li><li>如果需要root权限执行，需要在相关文件中加入<code>platforms.C_FORCE_ROOT=True</code>，但是最好别用root；</li><li>可以根据需要消除<code>pickle</code>的警告，设置<code>CELERY_ACCEPT_CONTENT=[&#39;pickle&#39;,]</code>；</li><li>默认不发心跳，需要加上<code>BROKER_HEARTBEAT=10</code>，来消除心跳相关警告；</li><li><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3>router是不支持通配符的，如果需要，可以自己写一个自定义Router类。下面是一个<code>celery.py</code>的例子：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery, platforms</span><br><span class="line"><span class="keyword">from</span> settings <span class="keyword">import</span> CELERY_BROKER</span><br><span class="line"><span class="keyword">from</span> kombu <span class="keyword">import</span> Queue, Exchange</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRouter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;router for tasks using wildcard&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">route_for_task</span>(<span class="params">self, task, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> task.startswith(<span class="string">&#x27;writer&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&#x27;queue&#x27;</span>: <span class="string">&#x27;async_writer&#x27;</span>, <span class="string">&#x27;routing_key&#x27;</span>: <span class="string">&#x27;async_writer&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">elif</span> task.startswith(<span class="string">&#x27;caller&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&#x27;queue&#x27;</span>: <span class="string">&#x27;async_caller&#x27;</span>, <span class="string">&#x27;routing_key&#x27;</span>: <span class="string">&#x27;async_caller&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&#x27;queue&#x27;</span>: <span class="string">&#x27;default&#x27;</span>, <span class="string">&#x27;routing_key&#x27;</span>: <span class="string">&#x27;default&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QUEUES = (</span><br><span class="line">    Queue(<span class="string">&#x27;default&#x27;</span>, Exchange(<span class="string">&#x27;default&#x27;</span>), routing_key=<span class="string">&#x27;default&#x27;</span>),</span><br><span class="line">    Queue(<span class="string">&#x27;async_writer&#x27;</span>, Exchange(<span class="string">&#x27;async_writer&#x27;</span>),</span><br><span class="line">          routing_key=<span class="string">&#x27;async_writer&#x27;</span>),</span><br><span class="line">    Queue(<span class="string">&#x27;async_caller&#x27;</span>, Exchange(<span class="string">&#x27;async_caller&#x27;</span>),</span><br><span class="line">          routing_key=<span class="string">&#x27;async_caller&#x27;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">platforms.C_FORCE_ROOT = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">&#x27;async&#x27;</span>,</span><br><span class="line">             broker=CELERY_BROKER,</span><br><span class="line">             include=[<span class="string">&#x27;async.writer&#x27;</span>, <span class="string">&#x27;async.caller&#x27;</span>, <span class="string">&#x27;async.checker&#x27;</span>, ])</span><br><span class="line"></span><br><span class="line">app.conf.update(CELERY_ACCEPT_CONTENT=[<span class="string">&#x27;pickle&#x27;</span>, ],</span><br><span class="line">                CELERY_IGNORE_RESULT=<span class="literal">True</span>,</span><br><span class="line">                CELERY_DISABLE_RATE_LIMITS=<span class="literal">True</span>,</span><br><span class="line">                CELERY_DEFAULT_EXCHANGE=<span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">                CELERY_DEFAULT_QUEUE=<span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">                CELERY_DEFAULT_ROUTING_KEY=<span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">                CELERY_DEFAULT_EXCHANGE_TYPE=<span class="string">&#x27;topic&#x27;</span>,</span><br><span class="line">                CELERY_TASK_SERIALIZER=<span class="string">&#x27;pickle&#x27;</span>,</span><br><span class="line">                CELERY_RESULT_SERIALIZER=<span class="string">&#x27;pickle&#x27;</span>,</span><br><span class="line">                BROKER_HEARTBEAT=<span class="number">10</span>,</span><br><span class="line">                CELERY_QUEUES=QUEUES,</span><br><span class="line">                CELERY_ROUTES=(MyRouter(),),</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.start()</span><br></pre></td></tr></table></figure></li></ol><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>官方给出的init.d脚本不是很好用，下面是一个自己写的参考：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># PushserverCore uWSGI Web Server init script</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          PushserverCore</span></span><br><span class="line"><span class="comment"># Required-Start:    $remote_fs $remote_fs $network $syslog</span></span><br><span class="line"><span class="comment"># Required-Stop:     $remote_fs $remote_fs $network $syslog</span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:      0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: Start PushserverCore Service for generic init daemon</span></span><br><span class="line"><span class="comment"># Description:       PushserverCore Service thrift Server backend.</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line">NAME=<span class="string">&quot;Core Thrift Server&quot;</span></span><br><span class="line">PROJECT=PushserverCore</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/var/app/enabled/<span class="variable">$PROJECT</span></span><br><span class="line">DESC=<span class="string">&quot;PushserverCore&quot;</span></span><br><span class="line">APP_DIR=/var/app/enabled/<span class="variable">$PROJECT</span>/Core</span><br><span class="line">APP_PATH=<span class="variable">$APP_DIR</span>/CoreServer.py</span><br><span class="line">CELERY_LOG_PATH=/var/app/<span class="built_in">log</span>/PushserverCore/celery.log</span><br><span class="line"></span><br><span class="line">print_succ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(tput setaf 2)</span><span class="subst">$(tput bold)</span>DONE<span class="subst">$(tput sgr0)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_fail()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(tput setaf 1)</span><span class="subst">$(tput bold)</span>FAILED<span class="subst">$(tput sgr0)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_service()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;stoping <span class="variable">$NAME</span>...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> pgrep -f <span class="variable">$APP_PATH</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        pkill -f <span class="variable">$APP_PATH</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    print_succ</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start_service()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> pgrep -f <span class="variable">$APP_PATH</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$NAME</span> service is already running.&quot;</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;starting <span class="variable">$NAME</span> service...&quot;</span></span><br><span class="line">        nohup python <span class="variable">$APP_PATH</span> &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">    sleep 3</span><br><span class="line">    <span class="keyword">if</span> pgrep -f <span class="variable">$APP_PATH</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        print_succ</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print_fail</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_worker()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;stoping celery worker...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> pgrep -f celery &gt; /dev/null 2&gt;&amp;1;<span class="keyword">then</span></span><br><span class="line">        pkill -f celery</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    print_succ</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start_worker()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> pgrep -f celery &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;celery is already running&quot;</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;starting celery worker...&quot;</span></span><br><span class="line">        celery -A async multi start writer <span class="built_in">caller</span> default  -Q:writer async_writer -Q:<span class="built_in">caller</span> async_caller -Q:default default -c 7 -l INFO --workdir=<span class="variable">$APP_DIR</span> --logfile=<span class="variable">$CELERY_LOG_PATH</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    sleep 3</span><br><span class="line">    <span class="keyword">if</span> pgrep -f celery &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        print_succ</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print_fail</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_status()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> pgrep -f <span class="variable">$APP_PATH</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$NAME</span> is running&quot;</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$NAME</span> is not running&quot;</span></span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> pgrep -f celery &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">&quot;celery worker is running&quot;</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">&quot;celery worker is not running&quot;</span></span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting <span class="variable">$DESC</span>...&quot;</span></span><br><span class="line">start_service</span><br><span class="line">        start_worker</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Stopping <span class="variable">$DESC</span>...&quot;</span></span><br><span class="line">stop_service</span><br><span class="line">stop_worker</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">restart)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Restarting <span class="variable">$DESC</span>...&quot;</span></span><br><span class="line">stop_service</span><br><span class="line">stop_worker</span><br><span class="line">        sleep 3</span><br><span class="line">start_service</span><br><span class="line">        start_worker</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Checking...&quot;</span></span><br><span class="line">        check_status</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">status)</span><br><span class="line">        check_status</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$NAME</span> &#123;start|stop|restart|status&#125;&quot;</span> &gt;&amp;2</span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>重点需要关注的是celery multi start的用法，注意start后面跟的是worker的名字（取数据的worker），也可以简单的写3，然后-Q:<em>worker_name</em> <em>queue_name</em>，最后-c是实际的worker（干活的worker）的数目，-Q是给队列指定worker。例子中的语句，意思是启动3个worker，分别命名为writer, caller和default，然后启动3个队列，名字分别是async_writer, async_caller和default，每个worker分配7个进程用来干活。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> celery </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>effective java 读书笔记</title>
      <link href="2017/06/12/EffectiveJava/"/>
      <url>2017/06/12/EffectiveJava/</url>
      
        <content type="html"><![CDATA[<h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><ol><li>用静态工厂方法代替构造器。这里的静态工厂方法不是factory mode，而是一种构造器的替代方法。本条款鼓励设计者在构建一个类时，优先考虑使用static factory method。后者有多个优势：更清晰，更简洁，在参数相同时不需要使用boolean或者enum来进行区分，可以通过register——get方法提供工厂特性（子类）。不过，这种方法和普通的静态方法没有任何语法形式的区别，且静态方法不能被继承（C++中<code>virtual</code>与<code>static</code>不能共存）；</li><li>当构造参数非常多时，使用构建器(builder)。我们通常会使用默认构造函数，然后用<code>set</code>方法一一设置属性，如果让<code>set</code>返回<code>this</code>，就可以连续使用<code>set</code>，这就是<code>builder</code>。对于具有“具名参数”语法的语言（如python，C#）这种模式就不是很必要了，对于有<code>default value</code>（如C++）语法的语言，这种模式的使用频率也要低一些。</li><li>用私有构造器或枚举强化单例属性。这里给出了一个创建单例的建议：创建一个仅包含单元素的枚举类型，由于java语言特性，枚举直接免费提供了序列化、防止多次实例化等功能，因此可以简洁的解决很多问题。</li><li>如果一个类不可实例化，应该将其构造器私有化，这种类一般只是提供静态函数（类似C++中的函数）</li><li>尽量少创建新对象，而应该多复用已有对象。这条尤其对immuable的对象很重要，例如String。每次使用<code>new</code>时，对应该仔细考虑是否需要创建一个新的对象，而不是复用以前的对象。当然，对于小对象，这个不需要考虑。正如C++中的传值和传址的差别，小对象使用传值反而更好一些，可以避免许多不必要的麻烦。<br>另外，由于<code>autoboxing</code>的存在，基本类型与装箱基本类型之间会相互转化。但是需要记住，要优先使用基本类型。</li><li>消除过期的对象引用。这条主要针对“程序员自己管理内存/池化”的情景。在C++中，我们习惯在<code>free</code> or <code>delete</code>之后，将其置0(<code>nullptr</code>)，这样可以避免后续一些莫名其妙的Bug。java是GC机制的，因此一般不需要这么做。但是，如果自己池化了对象管理机制（例如创建某些数据结构时），就要注意这些问题了。<br>本条款给出的建议中，要注意缓存（比如建了一个全局list/map）中过期的东西记得删除。可以使用<code>WeakHashMap</code>自动管理(当内存中没有其引用对象时自动清除），或者<code>LinkedHashMap</code>的<code>removeEldestEntry</code>手动管理（每次添加新元素时）。对于更加复杂的场景，必须使用<code>java.lang.ref</code><a href="http://www.ibm.com/developerworks/cn/java/j-lo-langref/">^1</a>.<br>此外，<strong>注册</strong>一个回调方法，但是没有显式取消它，会导致其不断被累积。因此在使用<code>addListener</code>创建函数对象时，请记得<code>removeListener</code>.</li><li>避免使用终结器(<code>finalizer</code>）。java使用GC来回收内存，因此终结器的用处不大，更重要的是，终结器的优先级很低，不能保证被及时执行，很容易造成性能bug。比较妥当的是提供显示的终结方法（如<code>close</code>），然后在<code>finally</code>中执行。注意终结方法不应该再抛出异常，而是应该捕获并打印日志。<br>但是用户可能忘记调用显示的终结方法，因此终结器还是可以充当最后的安全保证，当然，这其实是程序不得已使用的方法，应该在日志中使用警告。<br>另外需要注意的是，子类终结器必须显式调用父类的，这点和C++中的自动析构并不一样，请注意。可以考虑使用<code>finalize guard</code>来确保这一点。</li></ol><h2 id="object通用方法"><a href="#object通用方法" class="headerlink" title="object通用方法"></a>object通用方法</h2><ol><li><code>equals</code>方法。C++中，重载<code>==</code>操作符限定在同类之间， 其他的要通过类型转换来进行比较，因此存在非常复杂的显式/隐式类型转换。java中，<code>equals</code>方法的参数必须是<code>Object</code>类型，这意味着所有的对象之间都可以判断是否相等。<code>equals</code>方法的设计必须非常谨慎，要严格遵守自反性、对称性、一致性和传递性这几个特征。</li></ol><ul><li>自反性，意思是x=x恒成立；</li><li>对称性，意味着a=b，必须也要b=a. 但是由于参数是<code>Object</code>，很容易无意识的违反这点。一般判断步骤中，首先需要知道这个<code>Object</code>是不是属于这个类（使用<code>instanceof</code>）,严格认为不属于这个类的对象不可能相等（即使是value意义上的相等）。如果需要value意义上的相等，就写一个显式的类型转换方法。</li><li>传递性，意味着a=b, b=c则a=c成立。这条在设计类层次结构时很容易被违反。在多层类均可被实例化时，判断这些类之间的相等性往往会出现混乱。</li><li>一致性。即相等的永远都相等，不等的永远都不等。这里注意的是判断时不要依赖不可靠的资源；</li><li>非空性。这是额外的一个特性，任何对象在任何情况下都不应该与<code>null</code>相等——这是显然的。但是这一步不需要特别写出来，<code>instanceof</code>会替我们做这些的。<br>除了上面的款项以外，还有一些使用技巧：</li><li>如果比较流程复杂，可以先用<code>==</code>判断是否是同一个对象；</li><li>在比较时注意npt异常；</li><li>短路求值与比较顺序；</li><li>覆盖<code>hashcode</code>;</li></ul><ol start="2"><li><code>hashcode</code>方法。如果覆盖了<code>equals</code>，<strong>必须</strong>同时覆盖<code>hashcode</code>，这是因为相等的对象必须有相同的hash code. 这意味着我们必须为这个类提供一种hash算法，这个活并不简单，不过一般情况下可以这么做：<ol><li>选一个非0常数记为result，比如17；</li><li>对于<code>equals</code>中涉及的每一个域f(成员变量)，计算其hashcode：<ul><li>boolean -&gt; 1 or 0</li><li>byte, short, int -&gt; int(f)</li><li>long -&gt; int(f^(f&gt;&gt;32))</li><li>float -&gt; Float.floatToIntBits(f)</li><li>double -&gt; Double.doubleToLongBits(f) -&gt; 按着long计算</li><li>对象引用：null -&gt; 0，其他：递归调用hashcode方法</li><li>数组：把每个对象当作一个单独的域计算hashcode</li></ul></li><li>result=$31 * result + \Sigma_{i=1}^{\propto}f_i$<br>如果一个域的结果可以通过其他域计算出来，可以不必参与上面的计算过程。<br>如果hash计算非常复杂，可以考虑使用延迟初始化技术。定义一个<code>volatile int hashcode</code>，在对应的method里，先<code>if(hashcode==0)</code>，否则直接返回缓存的结果。</li></ol></li><li><code>toString</code>方法。同C#一样，一般推荐覆盖这个方法，这样<code>print</code>时，会方便很多。</li><li><code>clone</code>方法。很遗憾，java的<code>clone</code>不好用——很不好用，它的约定太弱。即使类implement了<code>Cloneable</code>接口，你也不能指望什么。最好的方法是别管这个东西，自己实现一个拷贝构造器，或者拷贝工厂。</li><li>考虑实现<code>Comparable</code>接口。这个接口唯一声明了<code>compareTo</code>方法，这是一个泛型方法。如果你需要排序，最好事先这个方法——正如C++中的重载<code>&lt;</code>操作符一样，这是泛型容器排序的基础。显然<code>compareTo</code>需要和<code>equals</code>在判断相等时保持一致。<br>比<code>equals</code>简单的是，<code>compareTo</code>的参数只能和自身类型一样，因为在implements泛型类时，填入的具体参数显然就是这个类自身。</li></ol><h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><ol><li><p>使类和成员的可访问性最小化。本条和语言无关，所有面向对象设计中，<strong>信息隐藏</strong>的重要性都是一致的。切记尽量少暴露实现细节，保持对外开放性最小。这可以有效减少软件工程的复杂度。<br>有个细节的技巧：数组不可能是public final的， 因为数组本身是可变的。C++中有个蛋疼的<code>const int* const p</code>的问题，指的就是指针的可变性和内容的可变性问题。<br>此外，java默认访问类型是<code>package private</code>的，这和其他语言有区别。</p></li><li><p>使用<code>getter</code>,<code>setter</code>代替公有成员变量。这条其实并不是那么严格，至少C++中经常可以看到反例。因为写起来实在太麻烦，所以C#引入了属性这种语法糖。</p></li><li><p>设计不可变类。省事起见，如果对性能没有特别大的需求尽量设计不可变类，这种类的所有方法都会返回一个<code>new</code>对象，而不是直接修改对象本身。这种类的设计遵从如下原则：</p><ol><li>不提供mutator修改对象本身；</li><li>保证类不会被继承；</li><li>所有域都是不可变的（final）；</li><li>所有域都是私有的；</li><li>确保对于任何可变组件的互斥访问；</li></ol></li><li><p>复合优先于继承。这条是面向对象的泛用条款，从略；</p></li><li><p>要么为继承而设计，要么禁止继承。这条要求在设计一个类时，要明确它是否会被继承。这里强调了一个细节：构造器不可调用可被覆盖的方法。这和C++中<strong>构造函数和析构函数不应该调用虚函数</strong>本质上是一直的，因为对象是从基类到派生类逐级构造的，如果调用虚函数，动态绑定可能不会生效，从而产生undefined的后果；</p></li><li><p>接口优先于抽象类。显然，也是泛用条款。对于C++而言，没那么明显（因为没有接口），不过全是纯虚函数的类就是接口…</p></li><li><p>接口只用于定义类型。是的，只应该有public的method，而不要塞进去一堆常量。后者最好用枚举代替。</p></li><li><p>类层次优先于标签类。标签类就是在构造函数中传入flag，在方法中<code>switch...case</code>，在C语言中，这是常见的设计。但是在面向对象中，显然更适合使用继承来合理安排类结构。</p></li><li><p>用函数对象表示策略。由于C++11有了<code>std::function&lt;&gt;</code>和<code>lambda</code>，所以函数对象这种累赘的东西一般是用不上了，但是垂垂老矣的java中，还没有这些东西(java8引入lambda了，谢天谢地），一般是写一个接口，然后用匿名函数实现它。</p></li><li><p>优先考虑静态成员类。nested class最好设计成静态的，这是为了减少对象的数量——非静态类都必须与一个外围实例关联。nested class可以摆脱友元这种东西的困扰，访问所有的成员方法|变量（某种形式的闭包）。但是静态成员类和对象本身无关，所以就只能访问静态方法和静态成员了。</p></li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在C++中，template和oo完全是两种不同的范式，因为C++并没有<code>all is object</code>这种思想，因此没人会觉得<code>vector&lt;basic_string&gt;</code>不是<code>vector&lt;string&gt;</code>的父类有啥问题。java其实也一样，<code>list&lt;string&gt;</code>和<code>list&lt;object&gt;</code>之间也不是继承的关系。泛型使java复杂化，并且失去了优雅。</p><ol><li>用泛型，不用原生态类型。java从1.5版本引入泛型，c#从1.2开始，C++则一直都有模板这种东西。没有泛型的语言一般都会引入一些很丑陋的类型转换，比如C中的<code>void *</code>。尽量使用泛型而非原生态的类型，如果需要指代任意类型而不关心具体类型，可以用<code>?</code>比如<code>set&lt;?&gt;</code>；此外，<code>instanceof</code>操作符后面必须跟着原生态类型；</li><li>消除<code>unchecked warning</code>，对于编译器的抱怨，要好好检查，如果确定没有问题，就使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>关闭这个提醒，受检警告仅存在在语言层面，并非是jvm虚拟机的特性；</li><li>优先使用List而不是Array。在C++中，array本质上是一个指针，因此效率比<code>std::vector&lt;&gt;</code>要高上不少；java中<code>Array</code>也比<code>list&lt;&gt;</code>要快一些，但是却更推荐使用后者。<br>java的泛型在运行时其元素类型是被擦除(erase<a href="http://www.infoq.com/cn/articles/cf-java-generics">^2</a>)的，这点和C++完全不同（为了历史兼容性做出的妥协）。因此<strong>数组是运行时安全但编译时不安全的，泛型则相反</strong>。最后，最好不要同时使用泛型和数组，这会让你蛋疼无比——如果真的需要泛型数组，必须同时使用强制类型转换和<code>SuppressWarnings</code>技术。</li><li>优先考虑泛型和泛型方法。</li><li>使用<code>set&lt;? extends Object&gt;</code> or <code>set&lt;? super String&gt;</code>这种技巧来完成某些动作。助记符是__PECS__,就是说，把这个对象当生产者使用时，用<code>extends</code>，反之，用<code>super</code>。<br>在返回的时候，仍然使用普通类型，而不是通配符。<br>本条对于类库编写者比较重要。</li><li>优先使用类型安全的异构容器。本条通过一些奇技淫巧完成一个容器里面同时存放多种类型(异构，通过<code>class&lt;?&gt;</code>实现)，但是又能保证类型安全(通过<code>type.cast</code>实现)这一目标。</li></ol><h2 id="枚举与注解"><a href="#枚举与注解" class="headerlink" title="枚举与注解"></a>枚举与注解</h2><p>java的枚举有点难用，不如C#那么强大，也不如C/C++那么简洁。简单来说，每一个枚举值都是该类（枚举）的一个实例，相当于一种工厂方法，因此枚举对象可以直接调用枚举类的方法。</p><ol><li>枚举的所有域都应该是私有final的（需要的时候提供公有的访问函数）；可以通过<code>values</code>方法访问所有的枚举值（依照声明顺序）。对于每一个枚举值在后面加上<code>&#123;&#125;</code>，里面是<strong>特定于常量的方法实现</strong>，可以通过在枚举类中声明一个抽象方法，在常量中再进行覆盖来实现对不同枚举值的特殊操作（<code>switch(this)</code>这种方法更适用于控制外部传入的不可控的变量的方法中）。<br>如果在枚举值后面加上初始化表达式，调用该常量时会自动使用该表达式调用构造函数（但是显然我们不能直接调用构造器），比如<code>MONDAY(&quot;mon&quot;)</code>这种.<br>PS: 这里给了一个有趣的技巧：使用<code>%n</code>保证换行符的跨平台性，有些类似python中的<code>os.linesep</code>.</li><li>如果不给枚举赋值，默认使用序列（0，1，2…），可以使用<code>ordinal</code>方法取得该序列的int值。当然，最好别依赖于这种自动生成的东西，而是明确赋值…</li><li>用<code>EnumSet</code>代替位域，主要使用<code>EnumSet.of</code>创建枚举set，用来取代依靠位运算得出的集合特性。不过，这种方法只是可读性好一些，如果需要做存储或者与提供API，还是希望使用int。</li><li>用<code>EnumMap</code>代替序数索引。可以将一个<code>enum</code>直接传入<code>EnumMap&lt;enum,Object&gt;</code>中，<code>enum</code>的所有常量值都会转化为<code>EnumMap</code>的<code>key</code>，这其实就是普通的<code>map</code>，但是做了优化。</li><li>枚举不是可扩展的，但是我们可以使用接口来变相实现这种可扩展性。简单来说，就是枚举实现接口，然后在需要的时候，使用接口来声明枚举而不是相反。</li><li>注解优先于命名模式。注解的声明需要导入<code>java.lang.annotation.*</code>，然后使用<strong>元注解</strong>来标明该注解的属性。例如<code>@Retention</code>, <code>@Target</code>，注解类的必须是<code>@interface</code>类型。如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public @interface Test&#123;</span><br><span class="line">    Class&lt;? extend Exception&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用时：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test(&#123;IndexOutOfBoundException.class, NullPointerException.class&#125;)</span><br><span class="line">public static void example()&#123;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试时:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(m.isAnnotationPresent(Test.class)&#123;</span><br><span class="line">    test++;</span><br><span class="line">    try&#123;</span><br><span class="line">        m.invoke(null);</span><br><span class="line">    &#125;catch(Throwable wrappedExc)&#123;</span><br><span class="line">        Throwable exc &#x3D; wrappedExc.getCause();</span><br><span class="line">        Class&lt;? extends Excetption&gt;[] excTypes&#x3D;</span><br><span class="line">            m.getAnnotation(Test.class).value();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>注解并不会改变代码原本的含义（和python的装饰器完全不同），但是可以使对象经过某些工具的特殊处理（用于反射）。<br>显然一般程序员是不需要自定义注解类型的，除了某些设计工具平台的人以外。</li><li>坚持使用<code>Override</code>注解。这是一种良好的变成习惯，不再赘述。</li><li>用标记接口定义类型。标记接口很罕见，最常见的是<code>Serializable</code>，它只是一个接口，并没有规定任意方法。换言之，这只是一个空接口。</li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>检查参数的有效性。即防御性编程，对于公有方法，应该在Javadoc中使用<code>@throws</code>标明在违反约定时会抛出什么异常；对于非导出方法，设计者自己知道会传入什么参数，因此应该使用<code>assert</code>来进行错误检测。</li><li>必要时使用保护性拷贝。java的对象本质上都是c++中的指针或引用，因此如果对象本身是可变的，即使参数是不可变的，也可能因为某些意外导致对象被修改。比较简单的方法是使用深拷贝（值拷贝）摆脱这种引用的关系，这在C++中是比较明显的：传值还是传址的问题，但是java中如果不留意很容易忘掉这一点。</li><li>谨慎设计方法签名。本条款说了一些设计方法的技巧和忌讳，包括：<ul><li>命名要谨慎</li><li>尽量保持接口最小，而不是提供很多快捷方式</li><li>避免过长的参数列表（4个以下）</li><li>如果上述条款不可避免，使用builder（参见前文）</li><li>参数类型优先使用接口</li><li>flag尽量使用enum而不是boolean</li></ul></li><li>慎用重载。有个原则是：永远不要导出两个具有相同<strong>参数数目</strong>的重载方法。如果方法使用可变参数，那么尽量不要重载它。如果违反上述两条规定，干脆给方法起不同的名字（如同在C语言中那样）。</li><li>慎用可变参数。和其他语言一样，可变参数为<code>printf</code>而生，但是实际上自己需要写的并不多，大部分情况下传入一个列表或者使用泛型可以解决应用问题。可变参数本身有一定的性能约束：传入可变参数隐式创建并初始化了一个数组。</li><li>返回0长度的数组或集合，而不是null。这是一条设计上的经验，在非C语言环境下，返回null往往得不偿失——需要单独写语句进行分析，而不能直接迭代。如果担心性能问题，可以使用<code>Collections.emptyList()</code>等方法返回不可变的空集，如果是数组，可以自己创建一个不可变的<code>static final</code>成员变量。</li><li>为所有的导出API写文档注释。尤其是在替别人写类库的时候，这条非常重要。必须明确标注哪些是可能会改变的，哪些是兼容的。</li></ol><h2 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h2><ol><li>使局部变量的作用域最小化。这点和C++、C#一致，C语言则是习惯把所有变量声明放在最前面（因为C只有基本数据和结构，且一般更习惯使用指针），python则不需要声明。</li><li>for-each优先于for。同所有语言一致，C++11中引入类似语法，C#和python用<code>in</code>关键字. 但是for-each是不能修改容器本身的，因此在必须要的时候还是要使用for。</li><li>了解和使用类库。应该熟悉<code>java.lang</code>和<code>java.util</code>中的内容。</li><li>不要使用<code>float</code>和<code>double</code>进行精确计算。如果需要精确的小数计算，应该使用<code>BigDecimal</code>，或者自己处理小数点，用<code>int</code>或<code>long</code>。</li><li>基本类型优先于装箱类型。由于装箱类型表示对象，因此用<code>==</code>判断两者之间的相等性总是错误的。当混合两者运算时，装箱类型就会自动拆箱。尽可能使用基本类型以避免不停的装箱、拆箱造成的性能损失。在如下场合必须使用装箱类型：<ul><li>集合的key和value；</li><li>泛型的参数；</li><li>进行反射方法调用时；</li></ul></li><li>如果其他类型更适合，不要使用字符串。例如，不要用”True”来代替<code>true</code>这种。</li><li>字符串连接问题。使用<code>StringBuilder</code>代替<code>String</code>，提高性能。</li><li>通过接口引用对象。这样更加灵活，但是必要的时候你可能需要进行类型转换。如果是基于类的框架，则使用基类更加合适。</li><li>接口优先于反射。反射的性能实际上是很差的，但是在必要的时候会非常有用。其中<code>Class a=Class.forname(&quot;xxx&quot;)</code>，然后使用<code>a.newInstance()</code>这种方法比较常见。</li><li>谨慎的使用native method. JNI允许java调用C/C++来访问特定的基于平台的sdk接口。但是，如果仅仅为了提高性能，并不提倡非要使用这种技术。</li><li>谨慎优化。写出好的程序，如果存在性能问题，则使用性能分析工具去分析它，再针对瓶颈进行优化。</li><li>遵守命名习惯。java的命名习惯和C#基本一致（而python和C++基本一致），java不喜欢下划线，而C++不喜欢驼峰。当然，一般常量还是都用全大写中间用下划线的表示方式。</li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>java的异常分为<code>checked</code>和<code>unchecked</code>两类，后者是<code>RuntimeExcception</code>或者<code>Error</code>的子类，如果程序抛出这种异常，可以不加以捕获而编译通过。<br>通常情况下，应该使用标准异常。且，只在真正的异常情况下使用异常。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ol><li><code>synchronized</code>和<code>volatile</code>关键字的使用。前者类似C#中的<code>lock</code>，后者意思同C。C语言中虽然没有线程，但是有中断和信号。</li><li>避免过度同步。如果需要并发集合，那就使用语言内置的并发集合，而不要自己使用<code>synchronized</code>关键字加锁。<code>CopyOnWriteArrayList</code>是一种写时复制的并发容器，类似<code>ConcurrentArrayList</code>。如果类库使用者可以外部同步，那么设计类的时候就不要设计成内部同步的（这是C++的设计原则之一——效率最高）。如果修改了静态域，由于外部用户无法自己加锁，因此类的内部必须加锁。尽量不要从同步区域内部调用外来方法。</li><li><code>executor</code>和<code>task</code>优先于线程。这点类似于C#，尽量不要使用抽象程度较低的线程，而是更加漂亮简洁的其他高级类。在<code>java.lang.concurrent</code>里包含了已经封装好的比较通用的线程模型，尽量使用它们而不是自己去写。</li><li>并发工具优先于<code>wait</code>和<code>notify</code>。类似上一条，优先使用高级工具。</li><li>慎用延迟初始化。本条目给出了几个好的建议：<ol><li>正常初始化优先于延迟初始化；</li><li>使用同步方法；</li><li>如果需要性能优化，静态域延迟初始化使用一个static class作为holder，这样在第一次访问这个静态类时，所需要的域才会被初始化；</li><li>如果需要性能优化，实例域延迟初始化最好使用双重检查模式。这时候域必须被声明为<code>volatile</code>的，而且习惯上使用一个局部变量来优化对域的检查。</li></ol></li><li>不要使用<code>Thread.yield</code>，直接用<code>Thread.sleep(1)</code>就好。java的线程调度器不可靠，不要使用线程优先级来调度。</li><li>不要使用java线程组，这个技术已经过时了…</li></ol><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>所谓序列化，指的是将一个对象编码成字节流，一般用来持久化。</p><ol><li>谨慎实现<code>Serializable</code>接口。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程实战读书笔记</title>
      <link href="2017/06/12/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>2017/06/12/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>并发编程实际上极其复杂，有很多绝对值得去看的建议。</p><ol><li>不要在构造器里面调用可变函数（虚函数），这是所谓的安全构造需求；</li><li>最简单的线程安全类是不可变类，不可变类有如下硬性要求：<ul><li>对象创建以后就不能修改</li><li>对象所有域都是<code>final</code>的</li><li>对象是安全构造的</li></ul></li><li>所谓可见性指的是a线程修改了变量，b线程可以知道这种修改；所谓原子性指的是a线程在修改变量时，b线程不会干扰这种修改；</li><li>所谓安全发布，必须满足以下条件之一：<ul><li>在静态初始化函数中初始化一个对象引用</li><li>将对象的引用保存到<code>volatile</code>类型或者<code>AtomicReferance</code>对象之中</li><li>将对象的应用保存到某个正确构造对象的<code>final</code>域中</li><li>将对象引用保存到一个由锁保护的域中</li></ul></li><li><code>volatile</code>变量只能保证可见性，无法保证原子性；加锁则都可以保证（但是会繁琐一些）。</li><li>不要在构造器中调用新的线程，这会导致不安全发布；正确的做法是使用静态工厂函数，构造完毕后再启动线程（或者做其他发布）；</li><li>最简单维持线程安全的方法是使用局部变量（栈封闭），其次是使用原子类，包括现场本地存储类<code>ThreadLocal&lt;&gt;</code></li><li>大多数情况下，我们无须直接使用<code>Thread</code>这种基础类，java提供了很多适用范围广泛的组件，包括：</li><li>并发容器类，使用<code>java.util.concurrent</code>中定义的包括<code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code>，<code>ConcurrentLinkedQueue</code>和<code>BlockingQueue</code>（<code>BlockingDeque</code>),以及<code>ConcurrentSkipListMap</code>和<code>ConcurrentSkipListSet</code>（作为<code>SortedMap</code>和<code>SortedSet</code>的替代品）.<code>BlockingQueue</code>在<code>take</code>和<code>put</code>时，如果没有元素/空间就会阻塞；</li><li>如果线程被中断，会抛出<code>InterruptedException</code>如果是<code>Runnable</code>的对象，是不可以直接抛出这个异常的，必须捕获并使用<code>Thread.currentThread().interrupt()</code>恢复中断；其他类型的对象倒是无所谓，可以直接抛出或者捕获清理后重新抛出；</li><li>闭锁。<code>CountDownLatch</code>可以用来等待计数，<code>FutureTask</code>是一种<code>Callable</code>，可以通过<code>get</code>来获得结果（或者阻塞），<code>Semaphore</code>用来对资源进行限制计数，可以用来实现资源池，使用<code>acquire</code>获得一个资源，使用<code>release</code>释放一个资源，<code>Barrier</code>用来实现分段任务，当所有任务都到达Barrier时，任务继续，否则抛出<code>BrokenBarrierException</code>异常。本章给出了一个缓存的例子。</li><li>Executor框架。<code>Executor</code>是一个接口，只规定了<code>execute</code>一个接口（其参数是一个<code>Runnable</code> class）；<code>Executors</code>包含生产线程池的几个静态方法，如<code>newFixedThreadPool</code>（固定大小），<code>newCachedThreadPool</code>（无限增长）和<code>newSingleThreadExecutor</code>（单线程串行）,和<code>newScheduledThreadPool</code>（定时执行）。如果这些都不能满足需求，可以直接使用<code>ThreadPoolExecutor</code>自己灵活构造线程池</li><li><code>ExecutorService</code>接口在<code>Executor</code>接口的基础上增加了生命周期，可以使用<code>shutdown</code>，<code>shutdownNow</code>，<code>awaitTermination</code>等方法进行生命周期（运行、关闭和已终止）控制和感知。</li><li><code>ExecutorService</code>的<code>submit</code>方法用于提交一个任务并返回一个<code>Future</code>，使用这个结果可以控制任务的生命周期；</li><li>线程的超时：一般可以用重载的<code>get</code>，<code>await</code>等方法指定超时时间；</li><li>线程的取消：习惯上使用一个<code>volatile</code>变量作为取消标志，但是如果线程阻塞了，这个方法就不好用了。最佳方式是使用中断(<code>Future.cancel</code>)，注意需要处理好相关的异常；</li><li>可以通过继承<code>Thread</code>重载<code>interrupt</code>方法来将中断处理封闭在异常类中；可以通过使用<code>ThreadPoolExecutor</code>中的<code>newTaskFor</code>静态方法由<code>Callable</code>生产<code>RunnableFuture</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> base </tag>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重拾Haskell</title>
      <link href="2017/06/12/%E9%87%8D%E6%8B%BEHaskell/"/>
      <url>2017/06/12/%E9%87%8D%E6%8B%BEHaskell/</url>
      
        <content type="html"><![CDATA[<p>我打算学习但是最终没能完全理解的语言大概有三门：因为复杂性而放弃的Scala和Rust，因为难以理解而放弃的Haskell. 学习过C++以后，我对太过复杂的语言一项是敬而远之的，这一点暂时不会有变化，以后在工作中如果遇到必须使用Scala的时候我还是会认真学习。但是对于Haskell还是有些不甘心。虽然这是一门号称不看论文很难理解的语言，我还是想尽力学习一下。</p><p>Haskell相对于其他语言，变化的速度非常快，现在最新的平台是<code>stack</code>，连<code>Haskell Platform</code>也过时了（有种web前端的感觉），不过其核心理念还是比较稳定的，以前从<code>Haskell趣学指南</code>中学习的东西，现在也大多还能用。</p><p>在ubuntu中添加官方PPA, <code>sudo apt-get install stack</code>以后，使用<code>stack setup</code>安装环境，使用<code>stack ghci</code>打开交互式环境，然后就可以愉悦的学习了。目前最的版本是ghc-8.0.1；</p><h2 id="优化显示"><a href="#优化显示" class="headerlink" title="优化显示"></a>优化显示</h2><p>默认的stack使用起来不是很方便，有些地方可以优化一二。<br>首先编辑<code>~/.stack/config.yaml</code>，删掉空白的<code>&#123;&#125;</code>，加入以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">templates:</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">        <span class="attr">author-email:</span> <span class="string">yaotairan@gmail.com</span></span><br><span class="line">        <span class="attr">author-name:</span> <span class="string">tryao</span></span><br><span class="line">        <span class="attr">category:</span> <span class="string">Personal</span></span><br><span class="line">        <span class="attr">copyright:</span> <span class="string">&#x27;Copyright (c) TairanYao&#x27;</span></span><br><span class="line">        <span class="attr">github-username:</span> <span class="string">YiuTerran</span></span><br><span class="line"><span class="attr">package-indices:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Tsinghua</span></span><br><span class="line">  <span class="attr">download-prefix:</span> <span class="string">http://mirrors.tuna.tsinghua.edu.cn/hackage/package/</span></span><br><span class="line">  <span class="attr">http:</span> <span class="string">http://mirrors.tuna.tsinghua.edu.cn/hackage/00-index.tar.gz</span></span><br></pre></td></tr></table></figure><p>上面的email和名字之类的需要换成自己的，后面加了清华的源，加快<code>cabal</code>的下载速度。</p><p>编辑<code>~/.ghci</code>加入以下内容：</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> IPPrint</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.Haskell.HsColour <span class="keyword">as</span> HsColour</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.Haskell.HsColour.Colourise <span class="keyword">as</span> HsColour</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.Haskell.HsColour.Output <span class="keyword">as</span> HsColour</span><br><span class="line"></span><br><span class="line"><span class="title">let</span> myColourPrefs = <span class="type">HsColour</span>.defaultColourPrefs &#123; <span class="type">HsColour</span>.conid = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Yellow</span>, <span class="type">HsColour</span>.<span class="type">Bold</span>], <span class="type">HsColour</span>.conop = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Yellow</span>], <span class="type">HsColour</span>.string = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Green</span>], <span class="type">HsColour</span>.char = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Cyan</span>], <span class="type">HsColour</span>.number = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Red</span>, <span class="type">HsColour</span>.<span class="type">Bold</span>], <span class="type">HsColour</span>.layout = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">White</span>], <span class="type">HsColour</span>.keyglyph = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">White</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">let</span> myPrint = putStrLn . <span class="type">HsColour</span>.hscolour (<span class="type">HsColour</span>.<span class="type">TTYg</span> <span class="type">HsColour</span>.<span class="type">XTerm256Compatible</span>) myColourPrefs <span class="type">False</span> <span class="type">False</span> <span class="string">&quot;&quot;</span> <span class="type">False</span> . <span class="type">IPPrint</span>.pshow</span><br><span class="line"></span><br><span class="line">:set -interactive-print=myPrint</span><br><span class="line">:set -<span class="type">XNoMonomorphismRestriction</span></span><br><span class="line">:set prompt <span class="string">&quot;λ &quot;</span></span><br></pre></td></tr></table></figure><p>然后在shell里运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libbz2-dev</span><br><span class="line">stack install ipprint hscolour</span><br></pre></td></tr></table></figure><p>执行stack安装依赖时，可能会报错，根据提示修正即可.<br>这是给<code>ghci</code>添加语法高亮.</p><p>最后，如果用zsh的话， 可以打开<code>stack</code>插件，方便自动完成. 也可以<code>alias ghci=&#39;stack ghci&#39;</code>. 另外，最好把<code>~/.local/bin</code>加到PATH里面去.</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>仍然从<a href="http://wiki.jikexueyuan.com/project/haskell-guide/introduction.html">《Haskell趣学指南指南》</a>这本书开始是比较合适的，虽然内容有些过时，但是基础部分变动应该不大。上次看这本书的时候我还不会python呢，如今js我也驾轻就熟了，看起来应该简单很多了。完成后开始看<a href="http://cnhaskell.com/">《Real World Haskell》</a>，后者相关习题的个人解答：<a href="https://github.com/YiuTerran/rwh-exercise">https://github.com/YiuTerran/rwh-exercise</a></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>基本语法大体和普通语言（C系）相似，除了：</p><ul><li>不等于符号是 <code>/=</code>，和数学中的$\neq$长的很像</li><li><code>not</code>和python里面一样，但是<code>&amp;&amp;</code>, <code>||</code>和C语言一样</li><li>函数调用使用<strong>空格</strong>，且具有最高优先级</li><li>括号用来保持更高的优先级</li><li><code>if..then..else</code>句式中，<code>else</code>是不可省略的，类似python中的单句<code>if..else</code></li><li>函数不允许首字母大写，按规定，所有首字母大写的都是类型或者类型类</li><li>由于允许操作符重载（自定义），很多符号的定义在不同的包里有不同的意思。如<code>Data.Ratio</code>里面有一堆分数相关的操作，<code>Data.Bits</code>里面则定义了很多位操作</li><li>操作符重载只是一种C++的描述，其实在这里是一种函数（当然<br>在ghci中，使用<code>let</code>定义变量，在脚本中直接赋值即可，变量可以看作是没有参数的函数（名字）。</li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul><li><code>list</code>和python中的形式大体一致，除了一点：所有元素的类型必须相同。</li><li>将两个列表合并使用<code>++</code>(效率较低）,使用<code>:</code>将元素插入队首，本质上<code>[1, 2, 3]</code>就是<code>1: 2: 3: []</code></li><li>使用<code>!!</code>取下标，越界会报错</li><li>list中的list也必须是同样元素类别（但是不关心长度）</li><li><code>head</code>返回头部（<code>car</code>)，<code>tail</code>返回尾部(<code>cdr</code>)，<code>last</code>返回最后一个元素，<code>init</code>返回除了最后一个元素的列表</li><li>对空的list，以上函数都会报错</li><li>Haskell的string就是<code>[Char]</code></li><li>使用<code>length</code>函数返回list的长度</li><li>使用<code>null</code>函数检测是否为空</li><li>使用<code>reverse</code>函数进行反转</li><li>使用<code>take</code>函数取出队首任意多个元素，超过长度也不会报错，只是返回所有</li><li>使用 <code>drop</code>删除队首任意多个元素</li><li>使用<code>maximum</code>和<code>minimum</code>求出队列中的极值</li><li>使用<code>sum</code>和<code>product</code>求出队列的和,积</li><li>使用<code>elem</code>判断是否是元素，一般用中缀形式表达（类似python中的<code>in</code>）</li><li>range生成使用<code>..</code>，例如[1..20]， step可以在第二个元素中指定，如[10,8..0];字母也可以用；但是不要用浮点数；由于惰性的原因，可以是无限长的range;</li><li>repeat函数用于生成重复序列，类似python中的<code>*</code></li><li>大名鼎鼎的list comprehesion,和python中类似，不同的是形式更加数学化。比如生成1到10的平方，在python中是<code>[k^2 for k in range(1, 10)]</code>，在hs中则是<code>[k^2 | k &lt;- [1..10]]</code>，感觉有点像高中数学吧，哈。后面的条件用逗号隔开表示<code>&amp;&amp;</code></li></ul><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><ul><li>仍然类似python中的tuple，但是：不允许有仅含有一个元素的tuple</li><li>在模式匹配中被大量使用</li><li>tuple的大小是不可改变的，但是类型可以不同</li><li><code>fst</code>, <code>snd</code>分别返回tuple的第一项和第二项，显然仅对<code>pair</code>（二元组）有效；</li><li><code>zip</code>用于使list组成tuple对，类似python</li><li><code>map</code>也类似python</li></ul><h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><ul><li>类型推导最强的语言，显式类型声明<code>::</code>，如<code>a :: Char</code></li><li>在ghci中使用<code>:t</code>判断类型，使用<code>:info</code>查看具体相关</li><li>类型的首字母必须大写</li><li><code>Int</code>是有限的，<code>Integer</code>是无限的</li><li>类型无关的时候，使用小写字母代替，比如<code>[a]</code>表示任意元素组成的list</li><li>typeclass是预定义的类型接口，比如可以相等的类型，必定是<code>Eq</code>的一个实现</li><li>类型约束<code>=&gt;</code>，类似于接口中的<code>where</code>，可以是任意类型，但必须满足。例如 <code>(Eq a)=&gt; a -&gt; a</code></li></ul><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>对于Haskell的纯函数而言，其主要书写格式就是大名鼎鼎的模式匹配，<code>Rust</code>也学习了这套语法。模式匹配其实是将数学按照构造函数进行拆分，能够这么干的主要原因是Haskell是纯函数式语言，没有副作用，变量被赋值后不能够再次修改。</p><ul><li>最好自己写上函数的签名，方便在编译期查错</li><li>对于函数来说，从上到下匹配，允许递归</li><li>对于<code>switch...case</code>类型的句子，使用<code>Guard</code>(<code>|</code>)，如果条件需要计算，在后面使用<code>where</code>（允许多个变量，但是要垂直隔开）</li><li>也可以使用<code>let..in</code>表示中某个作用域中的变量声明</li><li><code>let</code>是一个表达式，而<code>where</code>是一个语法结构，表达式（类似<code>if..then..else</code>）可以放在各种位置</li><li>除了这些以外，<code>case</code>表达式本身也存在，其语法结构是<code>case xx of x -&gt; ...</code>，模式匹配本质上都是这个表达式的语法糖</li><li>使用<code>_</code>可以匹配任意情况</li><li>除了纯函数外，Haskell也有有副作用的函数比如IO，这种函数的书写格式更类似普通命令式语言。</li><li>函数的基本形式是<code>a-&gt;b-&gt;c</code>，箭头连接各个参数，由于函数是柯里化的，所以也可以看做<code>a-&gt;(b-&gt;c)</code>，每个部分是一个<strong>偏函数</strong>，整个被称为<strong>全函数</strong>。如果函数不返回任何东西（在某些语言中被称为过程），这个函数肯定是非纯函数，一般返回<code>()</code>【读作<code>unit</code>】，如<code>IO ()</code></li></ul><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>lambda表达式本来就源自FP(lisp)，所以很自然的：<code>\xs -&gt; length xs</code>，不过haskell中用lambda比其他语言应该少很多。</p><p>常用的一些函数：<br><code>fold</code>, <code>fold1</code>, <code>foldr</code>, scan家族类似<br><code>$</code> 符号同样也可以调用函数，但是与空格不同，他具有最低优先级，主要用来减少括号的数量；<br><code>.</code>符号表示右结合的函数，即先算最右边的，然后依次应用左边的函数，右边函数的返回值是左边函数的参数；<br>上面两个符号主要用来做函数组合，简化书写。。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>熟悉的import语句，不过和python的语法不太像，倒是有点像java.</p><ul><li><code>import Data.List</code> 会导入该模块下的所有函数；</li><li><code>import Data.List (nub, sort)</code>仅导入两个函数</li><li><code>import Data.list hiding (nub)</code> 导入除了nub之外的所有函数</li><li><code>import qualified Data.Map</code> 导入所有函数，但是如果和已加载模块冲突的话，必须使用全引用</li><li>可以在后面加上<code>as x</code>做别名</li></ul><h3 id="自定义结构"><a href="#自定义结构" class="headerlink" title="自定义结构"></a>自定义结构</h3><p>关键字： <code>data</code><br>和其他语言不一样，标准格式很奇怪</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">BookInfo</span> = <span class="type">Book</span> <span class="type">Int</span> <span class="type">String</span> [<span class="type">String</span>]</span></span><br><span class="line">                                <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure><p>BookInfo就是类型的名字（类型构造器），Book是值构造器的名字，后面是成员；两者名字可以一致；</p><p>这样访问属性还要写专门的函数（模式匹配），很蛋疼，所以有个惯用法（标准称呼是<strong>记录</strong>）：</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">BookInfo</span> = <span class="type">BookInfo</span> &#123;</span></span><br><span class="line"><span class="class">    <span class="title">price</span>   :: <span class="type">Int</span>,</span></span><br><span class="line"><span class="class">    <span class="title">author</span>  :: <span class="type">String</span>,</span></span><br><span class="line"><span class="class">    <span class="title">buyer</span>   :: [<span class="type">String</span>]</span></span><br><span class="line"><span class="class">&#125; <span class="keyword">deriving</span> (<span class="title">show</span>)</span></span><br></pre></td></tr></table></figure><p>这些成员当然也可以是函数。</p><p>递归定义也是很常见的，比如一个二叉树：</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Node</span> a (<span class="type">Node</span> <span class="title">a</span>) (<span class="type">Node</span> <span class="title">a</span>)</span></span><br></pre></td></tr></table></figure><p>这里a是类型参数。</p><p>关键字<code>type</code>类似C++中的<code>typedef</code>，用于定义类型的别名。</p><p>此外<code>newtype</code>也可以自定结构，不过有很多约束。<code>newtype</code>关键字给现有类型一个不同的身份，因此只能有一个值构造器，并且这个构造器只能有一个字段。</p><p>由<code>data</code>关键字创建的类型在运行时有一个记录开销，如记录某个值是用哪个构造器创建的。而<code>newtype</code>只有一个构造器，所以不需要这个额外开销。这使得它在运行时更省时间和空间。由<code>newtype</code>的构造器只在编译时使用，运行时甚至不存在。</p><h3 id="typeclass"><a href="#typeclass" class="headerlink" title="typeclass"></a>typeclass</h3><p>就是其他语言中的类型类/接口/模板，语法是</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">BasicEq</span> a <span class="keyword">where</span></span></span><br><span class="line">    isEqual:: a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>实例是</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">BasicEq</span> bool <span class="keyword">where</span></span></span><br><span class="line">    isEqual <span class="type">True</span> <span class="type">True</span> = <span class="type">True</span></span><br><span class="line">    isEqual <span class="type">False</span> <span class="type">False</span> = <span class="type">True</span></span><br><span class="line">    isEqual _ _ = <span class="type">False</span></span><br></pre></td></tr></table></figure><ul><li>常见的Typeclass包括<code>Eq</code>, <code>Ord</code>(可比较), <code>Show</code>(可以转换为字符串), <code>Read</code>可以被<code>String</code>转换(可以用<code>::</code>显式指定类型)，<code>Enum</code>（可以被迭代)，<code>Bounded</code>(有上下限），<code>Num</code>(有数字特征，必须实现<code>Eq</code>和<code>Show</code>)，<code>Integral</code>, <code>Floating</code></li><li><code>fromIntegral</code>可以将整数转换成浮点数（根据后续操作转换）</li><li>默认情况下，Haskell不支持模板特化（重载）。可以通过语言扩展<code>FlexibleInstances</code>取消这个限制。</li><li>扩展<code>OverlappingInstances</code>可以允许重叠实例。</li><li>在文件最前面加上<code>&#123;-# LANGUAGE TypeSynonymInstances, OverlappingInstances #-&#125;</code>即可打开编译器扩展；</li><li>在<code>RWH</code>上面提到了单一同态错误问题，经过我的测试，在最新的(8.0.1)的GHC中这个问题已经不存在了；</li><li>同C++的模板一样，允许多参数类型类（MultiParamTypeClasses），多参数之间可以定义条件约束表明多个参数之间的关系</li><li>多参数类型类比较复杂，谨慎使用</li></ul><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>使用 error 函数输出错误<br>避免抛出错误，使用<code>Maybe</code>, <code>Just</code>和<code>Nothing</code></p><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><blockquote><p>Haskell 依据缩进来解析代码块。这种用排版来表达逻辑结构的方式通常被称作缩进规则。在源码文件开始的那一行，首个顶级声明或者定义可以从该行的任意一列开始，Haskell 编译器或解释器将记住这个缩进级别，并且随后出现的所有顶级声明也必须使用相同的缩进。<br>let 表达式和 where 从句的规则与此类似。一旦 Haskell 编译器或解释器遇到一个 let 或 where 关键字，就会记住接下来第一个标记（token）的缩进位置。然后如果紧跟着的行是空白行或向右缩进更深，则被视作是前一行的延续。而如果其缩进和前一行相同，则被视作是同一区块内的新的一行。</p></blockquote><p>也可以使用显式语法结构（使用花括弧代替缩进），不过一般不这么做</p><h3 id="节"><a href="#节" class="headerlink" title="节"></a>节</h3><p>节其实是高阶函数的一种形式（语法糖），如</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">test</span> = (+<span class="number">2</span>)</span><br><span class="line">// test <span class="number">3</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="As模式"><a href="#As模式" class="headerlink" title="As模式"></a>As模式</h3><blockquote><p>模式 <code>xs@(_:xs&#39;)</code> 被称为 as-模式，它的意思是：如果输入值能匹配 @ 符号右边的模式（这里是 <code>(_:xs&#39;)</code> ），那么就将这个值绑定到 @ 符号左边的变量中（这里是 xs ）。</p></blockquote><p>除了增强可读性外，可以简化代码，减少内存分配</p><h3 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h3><ul><li><code>foldl</code>，接受一个初始值，一个步进函数，对一个列表进行迭代求职，显然<code>sum = foldl (+) 0</code></li><li><code>foldr</code>，格式同上，从右侧开始折叠。</li></ul><blockquote><p>一种思考 foldr 的方式是，将它看成是对输入列表的一种转换（transform）：它的第一个参数决定了该怎么处理列表的 head 和 tail 部分；而它的第二个参数则决定了，当遇到空列表时，该用什么值来代替这个空列表。</p></blockquote><ul><li>千万不要把 foldl 用在实际使用中，这是因为会发生内存泄露（因为惰性求值的关系</li><li>真正的情况使用的是<code>foldl&#39;</code>，<code>foldr&#39;</code> (Data.List)</li><li><code>foldl</code>的步进函数格式是 <code>step acc x</code>, <code>foldr</code>的则是<code>step x acc</code>，对于list <code>(x:xs)</code>而言，从左折叠第一个元素是<code>x</code>，从右折叠第一个元素是<code>[]</code>；</li></ul><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>module的规定类似java，名字必须和文件名一致，首字母必须大写；</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> SimpleJSON(</span><br><span class="line">    <span class="type">Xxxx</span>,   //导出部分，如果省略则全部导出</span><br><span class="line">) <span class="keyword">where</span></span><br></pre></td></tr></table></figure><p>显然入口模块应该是<code>Main.hs</code></p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>单文件可以用<code>runghc</code>命令运行，相当于脚本；也可以在ghci里面<code>:l</code>外部文件进行测试；<br>编译则需要使用<code>stack ghc</code>命令；</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul><li>IO是有副作用的（非幂等的），因此Haskell中的IO和非IO函数一般严格分开。</li><li>IO动作可以被创建，赋值和传递到任何地方，但是仅能在另一个IO动作里被执行</li><li><code>&lt;-</code>运算符从I/O中抽出结果并保存到一个变量中</li><li>当有多个动作时，使用<code>do</code>引入代码块</li><li>在<code>do</code>中，使用命令式语言的语法完成一系列操作（赋值用<code>let</code>）</li><li><code>do</code> 代码块中的每一个声明，除了 <code>let</code> ，都要产生一个I/O操作，这个操作在将来被执行（惰性）</li><li>IO相关函数被定义在<code>System.IO</code>中</li><li><code>return</code>的作用和<code>&lt;-</code>相反，将一个纯值包装进IO，可以把IO想象成一个流。<code>return</code>入流后，将来可以通过<code>-&gt;</code>取出来赋值；</li><li>除了普通IO以外，haskell还有自己特色的惰性IO，<code>hGetContents</code>就是惰性的</li><li>除了<code>openFile</code>和<code>hClose</code>外，使用<code>readFile</code>也可以，同时可以避免忘记关掉<code>hClose</code>的问题</li><li>对于指定的模式，比如打开文件流，做一些变化，再输出到流，可以用<code>interact</code></li><li>IO与普通函数的联系通过<code>Monad</code>实现，或者说IO是一种Monad</li><li>命名习惯： <code>mapM</code>返回一个IO动作，<code>mapM_</code>完成IO，但是不返回任何值，<code>M</code>的后缀表示<code>Monad</code></li><li><code>map</code>不能执行操作（纯函数），这就是<code>mapM</code>存在的意义</li><li><code>forM</code>意思与<code>mapM</code>相反，第一个参数是列表，第二个是动作，存在的意义是更干净的代码</li><li><code>do</code>代码块实际上是把操作连接在一起的快捷记号，可以用<code>&gt;&gt;</code>和<code>&gt;&gt;=</code>代替</li><li><code>&gt;&gt;</code> 运算符把两个操作串联在一起：第一个操作先运行，然后是第二个，整个计算的结果是最后运算的结果</li><li><code>&gt;&gt;=</code> 运算符运行一个操作，然后把它的结果传递给一个返回操作的函数。类似linux 管道操作</li><li>类似地，还有<code>=&lt;&lt;</code>运算符，将右边的动作传递给左边</li><li>换句话说，<code>do</code>块的最后一个操作的值就是整个<code>do</code>的值。如果以<code>return</code>结尾，返回一个<code>Monad</code>，比如整个函数的返回值是<code>IO()</code>，最后多半就是以<code>return</code>结尾。这种函数的返回值只能在另一个Monad函数中重新读出，不能直接用于任何操作。</li><li>Haskell中的纯代码不能运行那些能触发副作用的命令。纯函数不能修改全局变量，请求I/O，或者运行一条关闭系统的命令</li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li>默认的String类型速度堪忧，可以用<code>bytestring</code>库代替。<code>Data.ByteString</code>和<code>Data.ByteString.Lazy</code>分别代表了惰性和普通模式的情况；</li><li>不要在类型定义上加类型约束，在需要它们的函数上加；</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>除了<code>List</code>和<code>Tuple</code>, Haskell自带了其他的一些常见的数据结构；</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li>关联列表也可以当作字典用，但是效率比较低。使用<code>lookup</code>可以在关联列表中查询数据；</li><li><code>Data.Map</code>，不同于大部分语言，这个<code>Map</code>是用平衡二叉树实现的，而不是哈希表。这和haskell的不可变性有关；</li><li>常用函数：<code>fromList</code>(通过关联列表转换)，<code>insert</code>（插入新值返回新的<code>Map</code>）</li><li>虽然是二叉树实现的，这个<code>Map</code>仍然是无序的（有点奇怪）</li></ul><h2 id="通用序列"><a href="#通用序列" class="headerlink" title="通用序列"></a>通用序列</h2><p><code>Data.Sequence</code>提供了比默认<code>list</code>更好的效率</p><ul><li>使用<code>fromList</code>创建，或者用<code>empty</code>和<code>singleton</code>函数创建</li><li>使用<code>|&gt;</code>, <code>&lt;|</code>和<code>&gt;&lt;</code> 添加元素，箭头指向被添加的元素</li><li>使用<code>Foldable.toList</code>将<code>Sequence</code>转回list</li></ul><h2 id="Functor（函子）"><a href="#Functor（函子）" class="headerlink" title="Functor（函子）"></a>Functor（函子）</h2><p>对于一个递归的数据结构，对于应用于其上的函数也很可能是同构递归的。书中的例子是将一棵字符串树转变为包含字符串长度的树，也就是说，树的结构不变，但是元素变成长度：</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">treeLengths</span>:: <span class="type">Tree</span> -&gt; <span class="type">Tree</span></span><br><span class="line"><span class="title">treeLengths</span> (<span class="type">Leaf</span> s) = <span class="type">Leaf</span> (treeLengths s)</span><br><span class="line"><span class="title">treeLengths</span> (<span class="type">Node</span> l r) = <span class="type">Node</span> (treeLengths l) (treeLengths r)</span><br></pre></td></tr></table></figure><p>这种能够同构映射的，满足类型类<code>Functor</code>，映射函数即<code>fmap</code>：</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure><p><code>Functor</code>是非常重要的一类class，有几个基本原则进行约束。首先，<code>fmap id</code>必须返回相同的值，其次，<code>Functor</code>必须是可组合的，换句话说，<code>fmap a . fmap b</code> == <code>fmap (a . b)</code>应该成立。</p><p>编译器不会检查这些规则，程序员需要自己保证这些规则成立。这些规则是函子在范畴论中的数学约束。</p><h2 id="幺半群"><a href="#幺半群" class="headerlink" title="幺半群"></a>幺半群</h2><p>在范畴论中，有一类简单的抽象结构被称为幺半群。许多数学结构都是幺半群，因为成为幺半群的要求非常低。 一个结构只要满足两个性质便可称为幺半群：</p><ul><li>一个满足结合律的二元操作符。我们称之为 <code>(*)</code>：表达式 <code>a * (b * c)</code> 和 <code>(a * b) * c</code> 结果必须相同。</li><li>一个单位元素。我们称之为 <code>e</code>，它必须遵守两条法则：<code>a * e == a</code> 和 <code>e * a == a</code>。</li></ul><p>即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Monoid a where</span><br><span class="line">    mempty  :: a                -- the identity</span><br><span class="line">    mappend :: a -&gt; a -&gt; a      -- associative binary operator</span><br></pre></td></tr></table></figure><p>如果我们真的需要在同一个类型上实现多个 Monoid 实例，我们可以用 newtype 创建不同的类型来达到目的。</p><h2 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h2><p><code>Monad</code>（单子）是Haskell最难理解的东西之一，这个概念和上文中的幺半群有关，<a href="http://jiyinyiyong.github.io/monads-in-pictures/">这里</a>有一些辅助理解的漫画。</p><p>一个Monad由以下几个构造元素：</p><ul><li>一个类型构造器 m</li><li>一个用于把某个函数的输出串联到另外一个函数输入上的函数，它的类型是 <code>m a -&gt; (a -&gt; m b) -&gt; m b</code></li><li>一个类型为 <code>a -&gt; m a</code> 的函数，它把普通值注入到调用链里面，也就是说，它把类型 a 用类型构造器 m 包装起来。</li></ul><p>标准的monad定义为：</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">    <span class="comment">-- chain</span></span><br><span class="line">    (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">    <span class="comment">-- inject</span></span><br><span class="line">    return :: a -&gt; m a</span><br></pre></td></tr></table></figure><p>显然<code>&gt;&gt;=</code>就是串联函数，<code>return</code>是注入函数（IO monad就是把普通值放入IO），类型构造器就是<code>m</code>本身。除此之外，还有<code>&gt;&gt;</code>函数用户忽略返回值的过程（即按步骤一步步来），以及<code>fail</code>函数接受一个错误消息让整个调用链失败（默认使用<code>error</code>函数）。</p><p>下面是具体的解析：</p><ul><li>如漫画里所述，单子、函子、态射都是对普通值一种包装(context)，由于haskell里值是不可变的，所以都可以重新用构造器进行匹配解析。</li><li>对于函子，是这样一种类型类（接口），存在<code>fmap</code>函数，可以让让普通函数与该类型类的实例进行运算，最简单的来讲<code>fmap (+3) (Just 5)</code>应该是<code>Just 8</code>；函子的中缀形式是<code>&lt;$&gt;</code>；</li><li>对于普通的函子，<code>fmap</code>仅能将函数应用于被包装的数据。对于<code>Applicative</code>这种，则可以将函数应用于被包装的函数。<code>import Control.Applicative</code>以后，可以使用<code>(Just (+3)) &lt;*&gt; (Just (+5))</code>，这将会生成一个<code>Just (+8)</code>的函数；这是因为函数也可以是函子的实例。因为函子的约束只有<code>可以应用fmap</code>这一个而已.</li><li>单子与上面的两个函子很类似，单子主要定义了<code>&gt;&gt;=</code>（bind）和<code>return</code>这两个函数，前者用于连接包装值和接受普通值作为参数的函数，该函数返回一个包装值。换句话说，Monad定义了一种行为，如何将包装值分解为普通值行为，最后再返回包装值。也就是<code>M a -&gt; (a -&gt; M b) -&gt; M b</code>.</li><li>单子的<code>return</code>其实就是将任意普通值包装起来；</li><li>有了上面两个性质，Monad就可以类似管道一样将普通函数串接起来使用了；</li></ul><hr><ul><li><p><code>Monad</code> class里面没有提供任何函数可以使一个<code>monadic</code>的值还原成一个普通值，这需要写代码的人自己定义。</p></li><li><p>我们经常需要将数据从<code>Monad</code>中取出来，然后使用纯函数进行计算，最后再用原来的类型构造器重新包围这个计算的结果,这种需求被称为<code>lifting</code>.对于<code>Monad</code>而言，已经定义了<code>&gt;&gt;=</code>和<code>return</code>，所以很容易得出：</p></li></ul><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">liftM</span> :: (<span class="type">Monad</span> m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b</span><br><span class="line"><span class="title">liftM</span> f m = m &gt;&gt;= \i -&gt;</span><br><span class="line">    return (f i)</span><br></pre></td></tr></table></figure><p>该函数被定义在<code>Control.Monad</code>中。比如我们要计算<code>Just (1 + 3)</code>，就可以用</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Just 4</span></span><br><span class="line">( <span class="number">1</span> + ) `liftM` (<span class="type">Just</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这与 <code>Just 3 &gt;&gt;= \x -&gt; Just (x+1)</code>等价。</p><p>另外，从函子的角度，这个也可以写作<code>(1+) &lt;$&gt; (Just 3)</code></p><p>如果函数<code>f</code>有多余一个参数，<code>Control.Monad</code>中也有对应的<code>liftM2</code>~`liftM5`</p><ul><li>在<code>Control.Monad</code>中定义<code>ap</code>函数，其签名为：<br><code>ap :: Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b</code><br>解读一下：第一个参数是一个被Monad包装的函数，第二个参数是一个普通的Monad值，这个值的类型与第一个参数中被包装的函数的参数相同（很拗口）。我们知道标准库总只定义了几个常见的<code>liftM</code>，如果我们需要大量链式调用，除了<code>&lt;*&gt;</code>外，还可以组合<code>liftM</code>和<code>ap</code>. 举个例子，定义</li></ul><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fee</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fee</span> a b = a + b</span><br></pre></td></tr></table></figure><p>那么 <code>liftM fee</code>的类型为：</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Monad</span> m =&gt; m <span class="type">Int</span> -&gt; m (<span class="type">Int</span> -&gt; <span class="type">Int</span>)</span><br></pre></td></tr></table></figure><p>显然这个函数的返回值满足<code>ap</code>的参数需求， 所以以下两个表达式相等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fee &#96;liftM&#96; (Just 1) &#96;ap&#96; (Just 1)</span><br><span class="line">fee &#96;liftM&#96; (Just 1) &lt;*&gt; (Just 1)</span><br><span class="line">liftM2 fee (Just 1) (Just 1)</span><br></pre></td></tr></table></figure><ul><li><code>join</code>函数也很常用：</li></ul><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">join</span> :: <span class="type">Monad</span> m =&gt; m (m a) -&gt; m a</span><br><span class="line"><span class="title">join</span> x = x &gt;&gt;= id</span><br></pre></td></tr></table></figure><p>用来移除一层Monad，<code>join (Just (Just a))</code>就是<code>Just a</code></p><ul><li>Monad的三个约束（数学意义上），类似Functor，Monad也有一些潜在的约束：<ul><li><code>return x &gt;&gt;= f</code> == <code>f x</code></li><li><code>m &gt;&gt;= return</code> == <code>m</code></li><li><code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code> === <code>(m &gt;&gt;= f) &gt;&gt;= g</code></li></ul></li></ul><p>第三条是结合律，如果我们把一个大的action分解成一系列的子action，只要我们保证子action的顺序，把哪些子action提取出来组合成一个新action对求值结果是没有影响的。</p><ul><li><code>Control.Monad</code>里面定义了<code>MonadPlus</code>，这其实是短路求值。</li></ul><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadPlus</span> m <span class="keyword">where</span></span></span><br><span class="line">    mzero :: m a</span><br><span class="line">    mplus :: m a -&gt; m a -&gt; m a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadPlus</span> [] <span class="keyword">where</span></span></span><br><span class="line">    mzero = []</span><br><span class="line">    mplus = (++)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadPlus</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    mzero = <span class="type">Nothing</span></span><br><span class="line">    <span class="type">Nothing</span> `mplus` ys = ys</span><br><span class="line">    xs `mplus` _ = xs</span><br></pre></td></tr></table></figure><ul><li><p>在<code>Control.Monad</code>中定义了标准函数<code>guard</code>：</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">guard</span> :: (<span class="type">MonadPlus</span> m) =&gt; <span class="type">Bool</span> -&gt; m()</span><br><span class="line"><span class="title">guard</span> <span class="type">True</span>  = return ()</span><br><span class="line"><span class="title">guard</span> <span class="type">False</span> = mzero</span><br></pre></td></tr></table></figure></li><li><p>在<code>Control.Arrow</code>中定义了函数<code>first</code>和<code>second</code>用于将普通函数应用到<code>Pair</code>中去</p></li></ul><h2 id="Monad变换器"><a href="#Monad变换器" class="headerlink" title="Monad变换器"></a>Monad变换器</h2><p>Monad变换器主要用来修改已经存在的Monad，以<code>T</code>结尾。大量Monad变换器进行叠加，就可以得到拥有多种功能的Monad.</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>讨论一些常用的haskell处理方式：<code>Maybe</code>, <code>Either</code>和<code>Exception</code>，一般都使用Monad配合。</p><p>再往后就是一些实际使用的例子了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> FP </tag>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heka源码解析</title>
      <link href="2016/05/29/Heka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2016/05/29/Heka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>Heka是目前我需要在工作中使用的唯一Go语言项目，出于对Golang的好感，我觉得仔细学习以下Heka的源码。如果力所能及的话，也可以为代码做出一些贡献。</p><p>先看最外层的文件目录结构(0.11.0dev):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ tree -L 1 -av --dirsfirst</span><br><span class="line">.</span><br><span class="line">├── .git</span><br><span class="line">├── build           # source &#96;build.sh&#96;生成</span><br><span class="line">├── client</span><br><span class="line">├── cmake</span><br><span class="line">├── cmd             # 命令行工具</span><br><span class="line">├── dasher          # 监控的前端文件，使用bootstrap和Backbone构建</span><br><span class="line">├── docker          # docker相关</span><br><span class="line">├── docs            # 文档</span><br><span class="line">├── examples</span><br><span class="line">├── externals       # 用户自定义程序放置位置</span><br><span class="line">├── logstreamer     # 日志流相关</span><br><span class="line">├── message         # Message相关</span><br><span class="line">├── packaging       # 打包</span><br><span class="line">├── pipeline        # 流程</span><br><span class="line">├── plugins         # 插件</span><br><span class="line">├── ringbuf</span><br><span class="line">├── rpm             # build to rpm</span><br><span class="line">├── sandbox         # 沙盒系统(lua)</span><br><span class="line">├── .dockerignore</span><br><span class="line">├── .gitattributes</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .gitmodules</span><br><span class="line">├── .travis.yml     # for Travis Ci</span><br><span class="line">├── CHANGES.txt</span><br><span class="line">├── CMakeLists.txt  # cmake root file</span><br><span class="line">├── CPackConfig.cmake</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── build.bat</span><br><span class="line">├── build.sh</span><br><span class="line">├── coverage.txt    # 测试代码覆盖率</span><br><span class="line">├── env.bat</span><br><span class="line">└── env.sh</span><br></pre></td></tr></table></figure><p>这是一个比较大的项目，从这里可以学到一些大型工程的基础知识，这是我所欠缺的。</p><p><code>.gitattributes</code>里面是控制git对换行符的处理的；<code>.gitmodules</code>比较有意思，是用来在项目中引用其他git项目的。仔细查找了<a href="https://codingkilledthecat.wordpress.com/2012/04/28/why-your-company-shouldnt-use-git-submodules/">一些资料</a>，得出的结论是：submodule用起来并不友好，尽量小心使用。</p><p><code>.travis.yml</code>是Travis Ci的配置文件，这个东西是用来做持续集成的。可以看到很多github repo的ReadMe中有一个图标表示<code>build|passing</code>之类的信息，一般就是来自于Travis Ci的反馈信息。</p><p>项目使用cmake构建，所以根目录有一个<code>CMakeLists.txt</code>文件。</p><p>Dockerfile用来搭建一个纯净的docker环境，方便各种构建。使用<code>sudo docker build .</code>来根据该文件创造docker镜像。</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>从<code>examples/host_filter.go</code>中可以看出，插件的入口在<code>init</code>函数中的<code>pipeline.RegisterPlugin</code>中。那么就从这里开始看起。</p><p>这个函数位于<code>pipeline/config.go</code>中，它的作用仅仅是把注册的组件放入一个<code>pipeline</code>包的全局变量中。</p><p>通过搜索这个变量，可以看到在<code>plugin_maker.go</code>的<code>NewPluginMaker</code>中被使用，而这个函数是用来通过<code>toml</code>产生新插件的。继续反向搜索使用这个函数的文件，迭代此过程，可以找到整个程序的入口文件<code>heka/cmd/hekad/main.go</code>文件。</p><h3 id="自上而下"><a href="#自上而下" class="headerlink" title="自上而下"></a>自上而下</h3><p>从main函数开始读代码，逻辑是很清晰的。首先是命令行解析，使用了标准库中的<code>flag</code>库。 Heka的命令行参数很少，除了打印版本号以外，只剩下加载配置文件一个功能。</p><p>加载配置文件后，首先进行全局配置，然后如果pid文件存在，就检测进程是否仍然存活。  (这里defer的顺序值得学习, <code>os.Exit</code>会忽略所有的defer，所以必须放在最前面，最后执行)。</p><p>然后是各种profile的记录，最后来到了pipeline. 通过全局配置生成一个<code>PipelineConfig</code>，然后再遍历配置文件。</p><p><code>PreloadFromConfigFile</code>从TOML配置文件里面生成<code>PluginMaker</code>，并存放起来(category-&gt;maker的映射)。这个过程中就调用了注册插件的构造函数。</p><p><code>LoadConfig</code>集中处理<code>MultiDecoder</code>的情况，然后将plugin分类到几个不同的字段(runner)中。</p><p>最后，调用<code>Run</code>方法，开始运行。</p><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p>定位到pipeline/pipeline_runner文件中的Run函数，该函数驱动整个工作流的进行。</p><p>首先启动的是Output插件，随之是Filter，最后是input相关插件。各个插件运行在不同的goroutine里。最后注册外界信号处理函数。</p><p>最后是注册各种清理函数，当程序收到信号退出时执行。</p><p>各类Runner要实现pipeline/pipeline_runners.go中的接口才能正常运行。</p><h3 id="Runner"><a href="#Runner" class="headerlink" title="Runner"></a>Runner</h3><p><code>PluginRunner</code>是各类Runner的接口（抽象基类），不过这里还有一个更基础的<code>flag_interfaces.go</code>，里面定义了一些接口。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> heka </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
