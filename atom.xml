<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮生倒影</title>
  <subtitle>技术类文章博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://YiuTerran.github.io/"/>
  <updated>2017-06-12T16:44:47.000Z</updated>
  <id>http://YiuTerran.github.io/</id>
  
  <author>
    <name>tryao</name>
    <email>yaotairan@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hello-world</title>
    <link href="http://YiuTerran.github.io/2017/06/13/hello-world/"/>
    <id>http://YiuTerran.github.io/2017/06/13/hello-world/</id>
    <published>2017-06-12T16:43:56.000Z</published>
    <updated>2017-06-12T16:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>最后再折腾一次，把所有的blog迁移到GitHub Pages，以后再也不折腾了ORZ</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后再折腾一次，把所有的blog迁移到GitHub Pages，以后再也不折腾了ORZ&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java web基础学习</title>
    <link href="http://YiuTerran.github.io/2017/06/12/java%20web%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://YiuTerran.github.io/2017/06/12/java web基础学习/</id>
    <published>2017-06-12T15:50:02.000Z</published>
    <updated>2017-06-12T16:27:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>做java项目有两个月了，一直忙着修复业务上的东西，java的web基础这块没怎么看。最近在coding时涉及底层较多，必须抽时间看看底层的一些东西了。</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h3><p>java的web底层主要是指servlet和filter，前者替代了普通的CGI（for C/C++，perl），相当于python中的wsgi。这一块主要的类：<br><img src="http://img.my.csdn.net/uploads/201301/04/1357284746_5560.png" alt="servlet class UML"></p>
<p>这是servlet相关的类，这是一个请求——应答模型，不涉及具体协议。和http相关的主要是下面这些：<br><img src="http://img.my.csdn.net/uploads/201301/05/1357367807_2250.png" alt="servlet http class UML"><br>和<code>Servlet</code>关系很大的是web.xml文件，所有的servlet必须在web.xml中声明、配置初始化参数，做url映射。url映射采用最大前缀匹配，如果两个完全一样，用靠前声明的那个匹配。类似django中的<code>settings.py</code>.</p>
<p>ServletFilter是Servlet的一种extension，用于在Servlet被调用之前检查Request对象，并修改Request Header和Request内容；以及在Servlet被调用之后检查Response对象，修改Response Header和Response的内容（一种中间件）。Filter也需要配置url mapping，其调用顺序是其在web.xml中声明的顺序，习惯上filter被声明在所有servlet之前。</p>
<p>Servlet异常处理，可以配置<code>&lt;error-page&gt;</code>将status-code导向不同的html页面，或者干脆导向一个自定义类，然后在该错误处理类中使用<code>Integer status_code=(Integer)req.getAttribute(&quot;javax.servlet.error.status_code&quot;);</code>得到错误码，然后根据错误码做处理；而java程序中的异常可以通过try…catch捕获，然后forword一个专门的处理类中。</p>
<p>session id应该只对当前servlet有效，虽然确实有方法使其跨servlet共享，但是不推荐使用。</p>
<h3 id="代码书写"><a href="#代码书写" class="headerlink" title="代码书写"></a>代码书写</h3><p>首先实现一个servlet（继承<code>HttpServlet</code>），实现<code>init</code>和<code>service</code>方法，在后者中实现web服务的逻辑处理。然后在<code>web.xml</code>中注册该servlet的类，将之与url相关联。</p>
<h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>外层web服务器（Tomcat等）在收到http请求后，根据url路径找到对应的servlet，实例化（如果不存在）。</p>
<p>实例化的servlet对象处理请求，并返回响应（或者转发给其他servlet）.</p>
<p>请求全部处理完毕后，Tomcat会根据需求销毁servlet（正常运行的服务不会销毁）。Java是多线程模型，并发的请求会使用新的线程来处理。</p>
<h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>类似其他语言中的模板，不过模板一般是获得结果，然后进行渲染。JSP本质是一种特殊的Servlet，所以在接收到请求后，JSP文件会被编译为Java的字节码。</p>
<p>语法：</p>
<ol>
<li><code>&lt;%...%&gt;</code>：Java代码片段，用于定义0~N条Java语句，方法中能够写什么，这里面就能放什么；</li>
<li><code>&lt;%=  %&gt;</code>：Java 表达式，用于输出一条表达式或变量的结果。<code>response.getWriter().print()</code> 方法中能够写什么，这里面就能够写什么；</li>
<li><code>&lt;%! … %&gt;</code> ：声明，用来创建类的成员变量和成员方法，Java类中能够写什么，这里面就能够写什么，要注意的是，里面的内容不在<code>_jspService()</code> 方法之内，直接被JSP转化后的类体包含。</li>
</ol>
<p>在<code>&lt;%  %&gt;</code> 和 <code>&lt;%= %&gt;</code> 脚本中定义的Java 代码都会放在JSP 的 <code>_jspService()</code> 方法中（实际上就是Servlet中的<code>service</code> 方法），而<code>&lt;%! %&gt;</code> 脚本中定义的却会放到生成类的成员位置的。</p>
<h2 id="Spring3"><a href="#Spring3" class="headerlink" title="Spring3"></a>Spring3</h2><p>spring存在的意义是因为Java不够灵活。</p>
<ol>
<li>Spring通过xml来增强Java的灵活性，减少因配置更改导致的重新编译需求；</li>
<li>Spring支持面向切面编程（也就是Python中的装饰器），方便进行拦截；</li>
<li>同样，通过AOP，可以管理数据库连接，以及事务回滚等等；</li>
<li>此外，Spring还提供了一系列工具包，如果JDBC连接；SpringMVC的web框架；</li>
<li>良好的可扩展性，可以方便的与其他JavaEE框架结合使用；</li>
</ol>
<p>简单来说，Spring通过XML定义了一套新的语言，该语言能被无缝整合到Java程序中。</p>
<h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>所谓的依赖反转。</p>
<p>按着HTTP的请求应答模型，正常情况下，Tomcat等web服务器就请求直接塞给servlet，获得应答返回给客户端。但是Spring为了增强灵活性，在这里加了一层，也即是所谓的“容器”。</p>
<p>这个容器（BeanFactory）本质上就是对象的托管工厂，根据请求容器创建对象（Bean），并进行一系列的注入等操作，并进行对象的生命周期管理。对于web而言显然Servlet被包含在这些Bean中。</p>
<p>初始化的流程是可配置化的，默认在一系列xml配置文件中。</p>
<h3 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h3><p>Spring是按着接口进行类的管理的，一般情况下，需要有一个接口类（假设叫<code>HelloApi</code>）。</p>
<p>一个实现了个该接口的普通类（假设就叫<code>HelloImpl</code>）。</p>
<p>在spring对应的xml中配置bean，大致如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter2.helloworld.HelloImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>id</code>是组件的名字，最后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</div><div class="line">       <span class="meta">@Test</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloWorld</span><span class="params">()</span> </span>&#123;</div><div class="line">             <span class="comment">//1、读取配置文件实例化一个IoC容器</span></div><div class="line">             ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"helloworld.xml"</span>);</div><div class="line">             <span class="comment">//2、从容器中获取Bean，注意此处完全“面向接口编程，而不是面向实现”</span></div><div class="line">              HelloApi helloApi = context.getBean(<span class="string">"hello"</span>, HelloApi.class);</div><div class="line">              <span class="comment">//3、执行业务逻辑</span></div><div class="line">              helloApi.sayHello();</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用容器读取<code>xml</code>配置文件，然后通过名字查找Bean，利用反射创建对应的实例（生成的是接口的实例）。</p>
<p>上文中的<code>ApplicationContext</code>是<code>BeanFactory</code>的子类，Spring针对不同的场景内置了大量不同的Bean工厂，以适应不同的场景。</p>
<p>如果构造器有参数，可以在xml的<code>bean</code>的结点中放入<code>constructor</code>结点，进行参数注入。</p>
<p>除了普通类以外，Bean还可以作用于静态/普通工厂类。只是xml中的配置文件项略有不同而已。</p>
<p>在初始化（生成对象）后，还可以通过<code>property</code>结点注入属性（setter）.</p>
<p>如果想要使用<code>Bean</code>技术，必须遵从其命名规范，不然找不到对应的方法/对象。如下：</p>
<ul>
<li>该类必须是一个普通Java类（POJO），不受Java规范外其他规范约束；</li>
<li>该类必须要有公共的无参构造器，如public HelloImpl4() {}；</li>
<li>属性为private访问级别，不建议public，如private String message;</li>
<li>属性必要时通过一组setter（修改器）和getter（访问器）方法来访问；</li>
<li>setter方法，以“set” 开头，后跟首字母大写的属性名，如<code>setMesssage</code>,简单属性一般只有一个方法参数，方法返回值通常为<code>void</code>;</li>
<li>getter方法，一般属性以“get”开头，对于boolean类型一般以“is”开头，后跟首字母大写的属性名，如<code>getMesssage</code>，<code>isOk</code>；</li>
<li>还有一些其他特殊情况，比如属性有连续两个大写字母开头，如“URL”,则setter/getter方法为：<code>setURL</code>和<code>getURL</code>，其他一些特殊情况请参看“Java Bean”命名规范。</li>
</ul>
<p>得益于xml的强大，可以注入的数据类型，除了基本类型外， 还有<code>list</code>、<code>set</code>和<code>map</code>等集合类，甚至可以引用其他Bean.</p>
<h3 id="bean-xml语法"><a href="#bean-xml语法" class="headerlink" title="bean xml语法"></a>bean xml语法</h3><ol>
<li>首先使用<code>&lt;bean&gt;</code>构建一个bean，指定<code>id</code>（全局唯一）和<code>class</code>。如果该bean对应的类需要使用静态工厂方法，使用<code>factory-method=&quot;xxxx&quot;</code>属性；如果需要实例工厂方法，则必须在前面先声明工厂类的bean，然后在这里指定<code>factory-bean</code>；bean的scope分为两类：<code>prototype</code>和<code>singleton</code>。显然单例的bean全局只有一个，原型的则每次产生新的。</li>
<li>使用<code>&lt;constructor-arg&gt;</code>调用构造器进行初始化，可以使用<code>index</code>属性指定构造器参数次序，或者直接用<code>type</code>按参数类型进行匹配（就像正常调用重载方法时那样），或者用<code>name</code>指定参数的名字。使用<code>value</code>注入需要的值。</li>
<li>使用<code>&lt;property&gt;</code>调用对应的<code>setter</code>来注入各种属性。如果注入的是常量，直接用<code>value</code>赋值就行；如果注入的是其他bean的<strong>名字</strong>，使用<code>idref bean=&#39;xxx&#39;</code>；如果注入的是其他bean对应类的实例，需要使用<code>ref bean=&#39;xxx&#39;</code>;还可以注入<code>list</code>,<code>set</code>, <code>array</code>和<code>map</code>，甚至<code>prop</code>(<code>java.util.Properties</code>) ；如果想要注入<code>null</code>，必须使用<code>&lt;null/&gt;</code>标签，直接写当然是字符串。</li>
<li>使用<code>lazy-init</code>可以对bean进行延迟初始化；</li>
<li>使用<code>depends-on</code>指定依赖的bean来影响初始化/销毁的顺序；</li>
<li>自动装配：为了减少配置文件的长度，spring支持自动装配。简单来说可以根据参数的名称自动找到对应bean的名称；</li>
<li>此外，spring还支持method注入。这个主要是为了解决单例bean调用原型bean导致的一系列问题；</li>
</ol>
<h3 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h3><p>spring为外部资源抽象了一系列的接口</p>
<h3 id="Spring表达式"><a href="#Spring表达式" class="headerlink" title="Spring表达式"></a>Spring表达式</h3><p>为Java语言提供了<code>eval</code>功能，类型动态语言的功能<br>在bean中可以使用SpEL，格式为<code>#{}</code>，表达式放在大括号中<br>可以在Java语言中使用<code>@Value(#{})</code>注释进行注入</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>Spring是面向接口编程的，这是装饰器模式的基础。</p>
<p>所谓装饰器模式，指的是对于一个<code>HelloApi</code>接口，定义一个装饰器也实现<code>HelloApi</code>接口，其构造器也是需要一个<code>HelloApi</code>对象。这样，我们将需要装饰的对象传入装饰器对象，通过调用装饰器的接口方法来实现装饰。</p>
<p>Spring通过注解/xml的方式完成装饰器的注入，就是所谓的AOP. 使用流程：</p>
<ol>
<li>写一个切面类；</li>
<li>定义连接点（具体什么场景下在哪里被调用），切入点表达式形如<code>execution(* com.spring.service.*.*(..))</code>，匹配语法：<code>*</code>表示一级上的任意字符，<code>..</code>表示任意级的任意字符，<code>+</code>指定类型的子类型；这里的语法很复杂，可以参见<a href="http://blog.csdn.net/wangpeng047/article/details/8556800" target="_blank" rel="external">这里</a>；</li>
<li>定义通知的回调方法</li>
<li>通知顺序：前置通知→环绕通知连接点之前→连接点执行→环绕通知连接点之后→返回通知→后通知；如果发生异常：异常通知→后通知</li>
</ol>
<h3 id="JDBC支持"><a href="#JDBC支持" class="headerlink" title="JDBC支持"></a>JDBC支持</h3><p>Spring扩展了原生的jdbc支持，但是一般情况下我们在生产环境会和ORM结合使用</p>
<h3 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h3><p>一般使用注释来简化配置文件，常见注释包括：</p>
<ol>
<li>Required：必须注入的属性，修饰setter；</li>
<li>Autowired： 自动装配，可以后面跟上<code>(required=true)</code>，自动装配有点坑爹，谨慎使用</li>
</ol>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>Spring MVC是一套常见的MVC web框架，主要涉及了几个层次……</p>
<h2 id="Apache-Shiro"><a href="#Apache-Shiro" class="headerlink" title="Apache Shiro"></a>Apache Shiro</h2><p>一个权限认证系统</p>
<h2 id="SiteMeth"><a href="#SiteMeth" class="headerlink" title="SiteMeth"></a>SiteMeth</h2><p>一个服务端渲染的页面装饰框架</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做java项目有两个月了，一直忙着修复业务上的东西，java的web基础这块没怎么看。最近在coding时涉及底层较多，必须抽时间看看底层的一些东西了。&lt;/p&gt;
&lt;h2 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; t
    
    </summary>
    
    
      <category term="java" scheme="http://YiuTerran.github.io/tags/java/"/>
    
      <category term="web" scheme="http://YiuTerran.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>jeesite代码解析</title>
    <link href="http://YiuTerran.github.io/2017/06/12/jeesite%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://YiuTerran.github.io/2017/06/12/jeesite代码解析/</id>
    <published>2017-06-12T15:49:11.000Z</published>
    <updated>2017-06-12T16:27:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在某个项目需要用到Java Web来写控制台，考虑到外包人员的能力，这边只能用传统的JSP技术来写了… 技术选项上用了jeesite这个成熟框架。该框架使用了最传统的SpringMVC + MyBatis，然后装了一堆框架，我会根据需求删掉其中大部分内容但是保留其基础框架。</p>
<h2 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h2><ol>
<li>直接运行项目，会自动打开浏览器，跳转到登录页。这个应该是在哪里配置的，暂时不明；</li>
<li>首页会匹配到<code>modules/sys/web/LoginController</code>里面的<code>index</code>方法；</li>
<li>该类继承自<code>BaseController</code>，这里定义了<code>logger</code>, <code>adminPath</code>, <code>frontPath</code>和<code>urlSuffix</code>，这些变量是从bean里面注入的. 同时定义了一些通用的方法；</li>
<li>所以index方法中的map, <code>${adminPath}</code>会被渲染为<code>a</code>；</li>
<li>该方法有两个注释，<code>RequiresPermissions</code>是<code>Apache shiro</code>进行鉴权，详见鉴权流程。</li>
</ol>
<h2 id="鉴权流程"><a href="#鉴权流程" class="headerlink" title="鉴权流程"></a>鉴权流程</h2><p>使用了组件<code>Apache Shiro</code>，这个东西定义了通用的鉴权模型，参考<a href="http://howiefh.github.io/2015/05/12/shiro-note/" target="_blank" rel="external">这篇blog</a>。使用流程如下：</p>
<ol>
<li>定义配置文件，本项目中与spring结合，为<code>spring-context-shiro.xml</code>，</li>
<li>大部分都是标准配置，注释掉的部分可以用redis作为sessionManager和CacheManager。在<code>SecurityManager</code>里面配置了<code>realm</code>，即为自己实现的<code>systemAuthorizingRealm</code></li>
<li>该类继承自<code>AuthorizingRealm</code>，</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在某个项目需要用到Java Web来写控制台，考虑到外包人员的能力，这边只能用传统的JSP技术来写了… 技术选项上用了jeesite这个成熟框架。该框架使用了最传统的SpringMVC + MyBatis，然后装了一堆框架，我会根据需求删掉其中大部分内容但是保留其基础框架
    
    </summary>
    
    
      <category term="java" scheme="http://YiuTerran.github.io/tags/java/"/>
    
      <category term="web" scheme="http://YiuTerran.github.io/tags/web/"/>
    
      <category term="jeesite" scheme="http://YiuTerran.github.io/tags/jeesite/"/>
    
  </entry>
  
  <entry>
    <title>lua5.1要点笔记</title>
    <link href="http://YiuTerran.github.io/2017/06/12/lua5.1%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
    <id>http://YiuTerran.github.io/2017/06/12/lua5.1要点笔记/</id>
    <published>2017-06-12T15:49:06.000Z</published>
    <updated>2017-06-12T16:28:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>sudo apt-get install lua5.1</code></p>
<p>lua的各个版本之间不兼容问题很严重，5.1-5.2-5.3之间都有一些不兼容的问题，5.1是最经典的版本，适用范围广泛。luajit与lua的关系相当于pypy与cpython的关系，luajit采用lua5.1语法，作者已经另起炉灶了，永远不和lua5.2兼容。Heka的lua扩展也是使用5.1版本的lua。</p>
<p>lua是一门嵌入式语言，也就是程序的入口点必定在别处，这是和python等脚本语言的最大区别。lua的性能很好，虽然比不上v8的js。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol>
<li>作为一门动态语言，可以从lua身上看出许多动态语言的影子。lua与js，python都有一定的相似性，可以说是综合了二者之所长。但是有个坑，就是unicode问题，lua5.3解决了这个问题。不过对于heka，一般情况下我们不太需要处理utf8，毕竟日志数据track一般都是编号和数据。</li>
<li>与python不同而与js类似，lua是动态类型语言。字符串会在适当时候自动转成数字， 当然也可以使用string.format自己进行转换；</li>
<li>所有的变量默认是全局的（与js一致），需要使用local修饰符来创建局部变量；全局变量被存放在一个table中，被称为环境，可以通过<code>getfenv</code>和<code>setfenv</code>来对环境进行操作；</li>
<li>只有一种数据结构：table. 赋值语句比较奇怪:<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = &#123;x=<span class="number">3</span>, [<span class="number">2</span>]=<span class="number">2</span>&#125;</div><div class="line">a[<span class="number">1</span>] == <span class="number">2</span></div><div class="line">a[<span class="string">"x"</span>] == <span class="number">3</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>注意table里面值不能是nil，否则会有各种奇怪的问题，比如<code>#</code>返回的是<code>nil</code>值之前的长度；所以可以用<code>a[x] == nil</code>或者<code>if a[x]</code>来判断exists；将<code>a[x]=nil</code>则相当于删除了<code>x</code>元素。但是不能这样删除数组里面的元素，因为会导致<code>#</code>操作符的结果错误，需要使用<code>table.remove(x)</code>;</p>
<ol>
<li>连接操作符：<code>..</code>; 取长度操作符（相当于<code>len</code>)<code>#</code>，但是<code>#</code>返回的是字节数，所以更像是<code>sizeof</code></li>
<li>函数与js中的很像，支持闭包。<code>：</code>可以用来定义方法，本质上是一种语法糖；</li>
<li><code>metatable</code>类似与python的内置方法，各种重载操作符。</li>
<li>lua支持<code>coroutine</code>.</li>
</ol>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><ol>
<li>由于lua中table不支持<code>nil</code>，这与json中的<code>null</code>产生了矛盾，需要使用<code>cjson.null</code>来表示</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;&lt;code&gt;sudo apt-get install lua5.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;lua的各个版本之间不兼容问题很严重，5.1
    
    </summary>
    
    
      <category term="heka" scheme="http://YiuTerran.github.io/tags/heka/"/>
    
      <category term="lua" scheme="http://YiuTerran.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Heka源码解析</title>
    <link href="http://YiuTerran.github.io/2017/06/12/Heka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://YiuTerran.github.io/2017/06/12/Heka源码解析/</id>
    <published>2017-06-12T15:48:46.000Z</published>
    <updated>2017-06-12T16:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Heka是目前我需要在工作中使用的唯一Go语言项目，出于对Golang的好感，我觉得仔细学习以下Heka的源码。如果力所能及的话，也可以为代码做出一些贡献。</p>
<p>先看最外层的文件目录结构(0.11.0dev):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">$ tree -L 1 -av --dirsfirst</div><div class="line">.</div><div class="line">├── .git</div><div class="line">├── build           # source `build.sh`生成</div><div class="line">├── client</div><div class="line">├── cmake</div><div class="line">├── cmd             # 命令行工具</div><div class="line">├── dasher          # 监控的前端文件，使用bootstrap和Backbone构建</div><div class="line">├── docker          # docker相关</div><div class="line">├── docs            # 文档</div><div class="line">├── examples</div><div class="line">├── externals       # 用户自定义程序放置位置</div><div class="line">├── logstreamer     # 日志流相关</div><div class="line">├── message         # Message相关</div><div class="line">├── packaging       # 打包</div><div class="line">├── pipeline        # 流程</div><div class="line">├── plugins         # 插件</div><div class="line">├── ringbuf</div><div class="line">├── rpm             # build to rpm</div><div class="line">├── sandbox         # 沙盒系统(lua)</div><div class="line">├── .dockerignore</div><div class="line">├── .gitattributes</div><div class="line">├── .gitignore</div><div class="line">├── .gitmodules</div><div class="line">├── .travis.yml     # for Travis Ci</div><div class="line">├── CHANGES.txt</div><div class="line">├── CMakeLists.txt  # cmake root file</div><div class="line">├── CPackConfig.cmake</div><div class="line">├── Dockerfile</div><div class="line">├── LICENSE.txt</div><div class="line">├── README.md</div><div class="line">├── build.bat</div><div class="line">├── build.sh</div><div class="line">├── coverage.txt    # 测试代码覆盖率</div><div class="line">├── env.bat</div><div class="line">└── env.sh</div></pre></td></tr></table></figure></p>
<p>这是一个比较大的项目，从这里可以学到一些大型工程的基础知识，这是我所欠缺的。</p>
<p><code>.gitattributes</code>里面是控制git对换行符的处理的；<code>.gitmodules</code>比较有意思，是用来在项目中引用其他git项目的。仔细查找了<a href="https://codingkilledthecat.wordpress.com/2012/04/28/why-your-company-shouldnt-use-git-submodules/" target="_blank" rel="external">一些资料</a>，得出的结论是：submodule用起来并不友好，尽量小心使用。</p>
<p><code>.travis.yml</code>是Travis Ci的配置文件，这个东西是用来做持续集成的。可以看到很多github repo的ReadMe中有一个图标表示<code>build|passing</code>之类的信息，一般就是来自于Travis Ci的反馈信息。</p>
<p>项目使用cmake构建，所以根目录有一个<code>CMakeLists.txt</code>文件。</p>
<p>Dockerfile用来搭建一个纯净的docker环境，方便各种构建。使用<code>sudo docker build .</code>来根据该文件创造docker镜像。</p>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>从<code>examples/host_filter.go</code>中可以看出，插件的入口在<code>init</code>函数中的<code>pipeline.RegisterPlugin</code>中。那么就从这里开始看起。</p>
<p>这个函数位于<code>pipeline/config.go</code>中，它的作用仅仅是把注册的组件放入一个<code>pipeline</code>包的全局变量中。</p>
<p>通过搜索这个变量，可以看到在<code>plugin_maker.go</code>的<code>NewPluginMaker</code>中被使用，而这个函数是用来通过<code>toml</code>产生新插件的。继续反向搜索使用这个函数的文件，迭代此过程，可以找到整个程序的入口文件<code>heka/cmd/hekad/main.go</code>文件。</p>
<h3 id="自上而下"><a href="#自上而下" class="headerlink" title="自上而下"></a>自上而下</h3><p>从main函数开始读代码，逻辑是很清晰的。首先是命令行解析，使用了标准库中的<code>flag</code>库。 Heka的命令行参数很少，除了打印版本号以外，只剩下加载配置文件一个功能。</p>
<p>加载配置文件后，首先进行全局配置，然后如果pid文件存在，就检测进程是否仍然存活。  (这里defer的顺序值得学习, <code>os.Exit</code>会忽略所有的defer，所以必须放在最前面，最后执行)。</p>
<p>然后是各种profile的记录，最后来到了pipeline. 通过全局配置生成一个<code>PipelineConfig</code>，然后再遍历配置文件。</p>
<p><code>PreloadFromConfigFile</code>从TOML配置文件里面生成<code>PluginMaker</code>，并存放起来(category-&gt;maker的映射)。这个过程中就调用了注册插件的构造函数。</p>
<p><code>LoadConfig</code>集中处理<code>MultiDecoder</code>的情况，然后将plugin分类到几个不同的字段(runner)中。</p>
<p>最后，调用<code>Run</code>方法，开始运行。</p>
<h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p>定位到pipeline/pipeline_runner文件中的Run函数，该函数驱动整个工作流的进行。</p>
<p>首先启动的是Output插件，随之是Filter，最后是input相关插件。各个插件运行在不同的goroutine里。最后注册外界信号处理函数。</p>
<p>最后是注册各种清理函数，当程序收到信号退出时执行。</p>
<p>各类Runner要实现pipeline/pipeline_runners.go中的接口才能正常运行。</p>
<h3 id="Runner"><a href="#Runner" class="headerlink" title="Runner"></a>Runner</h3><p><code>PluginRunner</code>是各类Runner的接口（抽象基类），不过这里还有一个更基础的<code>flag_interfaces.go</code>，里面定义了一些接口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Heka是目前我需要在工作中使用的唯一Go语言项目，出于对Golang的好感，我觉得仔细学习以下Heka的源码。如果力所能及的话，也可以为代码做出一些贡献。&lt;/p&gt;
&lt;p&gt;先看最外层的文件目录结构(0.11.0dev):&lt;br&gt;&lt;figure class=&quot;highligh
    
    </summary>
    
    
      <category term="heka" scheme="http://YiuTerran.github.io/tags/heka/"/>
    
      <category term="golang" scheme="http://YiuTerran.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习</title>
    <link href="http://YiuTerran.github.io/2017/06/12/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://YiuTerran.github.io/2017/06/12/Go语言学习/</id>
    <published>2017-06-12T15:48:42.000Z</published>
    <updated>2017-06-12T16:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实前段时间我已经试着学习Go了，但是由于没啥项目需求所以很快就忘了，这次借着要写heka插件的机会重新学习一下，巩固一下基础知识。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>安装GoLang，直接用官网的安装指南就行；</li>
<li>设置环境变量<code>GOPATH</code>，这个是用默认包的存放位置，用<code>go get</code>安装的包会存放在这个位置。在<code>~/.zshrc</code>或<code>~/.bashrc</code>里面加入<code>export GOPATH=~/.go</code>，然后在<code>PATH</code>里面加入<code>GOPATH/bin</code>即可；</li>
<li>如果是项目的依赖，最好不要放入全局系统。使用<code>glide</code>等工具进行包管理，1.9官方会推出管理工具（一直不重视的傻逼）</li>
<li>设置代理。<code>go get</code>命令下载必定被墙，使用<code>git config --global http.proxy &quot;xxxx:oooo&quot;</code>设置代理方可使用，也可以使用<code>http_proxy=xxxx:oooo go get</code>这个格式，或者在bashrc里面加个<code>alias</code>；</li>
<li>IDE，Sublime + GoSublime、vscode+go，或者gogland(EAP阶段）；</li>
<li>官方教程，建议下载到本地运行，速度更快；</li>
<li>交互式命令行：<code>gore</code>(<code>go get -u github.com/motemen/gore</code>)，或者用iPython的Notebook本地调试使用；</li>
<li>可以使用<code>https://play.golang.org/</code>跑一些短小的程序测试；</li>
</ol>
<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ol>
<li>打头的<code>package xxx</code>，类似java，<code>import</code>可以用括号打包；</li>
<li>类型在变量名后，这种奇特的声明方式虽然有篇blog来解释，但总而言之是扯淡的；</li>
<li>连续多个变量同类型可省略前面的只保留最后一个；</li>
<li>类似python的多值返回（但是python本质是一个tuple);</li>
<li>裸返回会返回当前所有的变量值，如果给返回值命名了，就不必在函数体中声明这些变量；</li>
<li><code>var name int</code>是典型的声明变量格式，自动推导类型的语法是<code>name := 0</code>（但是这个语法只能在函数体里面用，外面必须用<code>var</code>声明）。可以在一行给多个变量赋值（类似python的解包）；</li>
<li>基本类型，和c++类似，包括<code>bool</code>, <code>int</code>, <code>uint</code>, <code>byte</code>(<code>uint8</code>),<code>rune</code>(<code>int32</code>), <code>float32</code>, <code>float64</code>, <code>uintptr</code>, <code>complex64</code>, <code>complex128</code>, <code>string</code>，注意么有<code>double</code>，类似其他GC语言，所有类型会被自动化初始化；</li>
<li>Go没有隐式类型转换，所有类型之间必须显式转换。注意<code>int</code>和<code>string</code>之间不能互转，可以用<code>strconv</code>中的<code>Itoa</code>和<code>Atoi</code>来完成（非常烦躁的设定）；</li>
<li>常量使用<code>const</code>关键字声明，常量只能是基础类型，且不能用<code>:=</code>声明。常量的实际类型由上下文决定，数值常量本身是高精度的；</li>
<li>和C语言一样，单引号表示字符(byte)，双引号表示字符串（话说这一套早就过时了啊。。。）</li>
</ol>
<hr>
<h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><ol>
<li>循环只有<code>for</code>语句，且不需要括号（后面的都不需要），基本格式还是类似c的<code>for i := 0; i &lt; 10; ++i</code>，这种，后面必须跟大括号，且大括号必须和<code>for</code>在同一行…</li>
<li>如果省略前后前后的分号，<code>for</code>就成了<code>while</code>；如果全部省略，裸的<code>for</code>代表死循环；</li>
<li>if类似，不要括号，花括号必须；而且if也可以在分号前声明一个变量，作用域仅限于花括号以及后面跟着的<code>else</code>里面；</li>
<li><code>switch</code>语句，好吧，和上面也类似。有个有趣的地方是，默认自动终止，除非使用<code>fallthrough</code>，和C中的默认自动向下，除非手动<code>break</code>相反；<code>switch</code>也可以直接用空语句，条件比较复杂时使用可以让代码看起来更加整洁；</li>
<li><code>defer</code>语句，这是Go的特色语句了…<code>defer</code>是在函数返回后再执行，其本质是压栈，所以弹出顺序与<code>defer</code>的顺序相反；</li>
</ol>
<hr>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ol>
<li>虽然Go是一门GC语言，但是仍然拥有指针。<code>*T</code>表示指向类型<code>T</code>的指针，取地址仍然使用<code>&amp;</code>。不过与C不一样的是，不允许指针运算；</li>
<li>和C一样，拥有<code>struct</code>，而且蛋疼的是，也只能拥有字段（和C一样，POD）。结构体通过指针访问字段也是使用<code>.</code>符号（没有了<code>-&gt;</code>符号）；</li>
<li>使用<code>{}</code>进行结构体初始化，如<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</div><div class="line">    X, Y <span class="keyword">float32</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> (</div><div class="line">    a = Point&#123;X: <span class="number">10</span>&#125;</div><div class="line">    b = Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</div><div class="line">    c = Point&#123;&#125;</div><div class="line">    p = &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div><div class="line">)</div><div class="line">fmt.Println(p.X)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>虽然感觉有点奇怪，不过和C++11后的初始化列表其实挺像的。</p>
<hr>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ol>
<li>声明方式： <code>var a [10]int</code>，这语法也是醉了。和C一样，数组不能动态扩张；</li>
<li>使用<code>slice</code>代替数组，声明方式： <code>a = make([]int, 0, 5)</code>，第二个参数表示长度(len)，第三个参数表示容量(cap)。类似python中的<code>list</code>，可以切片；注意，如果仅仅声明<code>var []a</code>那么<code>a==nil</code>是成立的；</li>
<li><code>make</code>关键字只能用来生成系统内置的一些对象，如slice, map, chan</li>
<li>go的切片有一些匪夷所思的问题，切片得到的并不是新的对象，而是原来对象的指针</li>
<li>可以通过<code>append</code>往slice中添加元素，类似C++中的<code>vector</code>可以自动扩展长度；</li>
<li><code>range</code>关键字（注意这货不是函数。。）用来对<code>slice</code>进行循环，格式是<code>for i, v := range a</code>;</li>
</ol>
<hr>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><ol>
<li><code>map</code>现在也是新兴语言的标配了，<code>map</code>和<code>slice</code>一样，必须通过<code>make</code>创建，语法是<code>m := make(map[string]int)</code>,<code>[]</code>中的是键的类型，后面跟着的是值的类型。初始化语法神马的和struct类似；</li>
<li>删除元素使用<code>delete</code>关键字；检测存在使用双赋值：<code>a, ok = m[&#39;test&#39;]</code>，如果存在则ok为<code>true</code>，否则为<code>false</code>；</li>
</ol>
<hr>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ol>
<li>函数被提到第一公民的位置，和javascript里面的语法很像，当然，除了强类型声明很麻烦以外；</li>
<li>函数的闭包与js类似，内嵌函数引用的是各自的闭包（其实有点像C中的<code>static</code>局部变量）；</li>
</ol>
<hr>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li>虽然Go里面没有类，但是可以声明struct关联的方法，虽然语法非常别扭…例如（接着上面的<code>Point</code>）<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p1 *Point)</span> <span class="title">distance</span><span class="params">(p2 *Point)</span> <span class="title">int</span></span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>方法接受者位置在<code>func</code>关键字和函数名之间，呃，其实和C++的外置方法声明还是有点像的…</p>
<ol>
<li>值得注意的是，不仅仅是struct，可以通过这种声明向本包内任意非内置类型注入方法，甚至可以通过<code>type</code>声明别称后向别称的内置类型进行注入；</li>
<li>方法接受者可以是指针，也可以不是，当然只有指针才能改变元素的实际值；</li>
</ol>
<hr>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><ol>
<li><code>struct</code>从语法上来讲和C基本是一样的；</li>
<li>可以在字段后面添加字符串，表示<code>tag</code>，在反射的时候用；</li>
<li>可以在结构体内塞入另一个结构体（或其指针），达到继承的效果；</li>
</ol>
<hr>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ol>
<li>虽然没有类，但是由接口。关键字<code>interface</code>声明一种接口：<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Flyable <span class="keyword">interface</span>&#123;</div><div class="line">    Fly();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面<code>Flyable</code>声明了一个接口，拥有<code>Fly</code>方法. 这样后面假设我给<code>pig</code>加上<code>fly</code>方法，那么变量<code>var item Flyable</code>就可以被赋值为<code>item = &amp;pig{}</code><br>这里值得注意的是，这里的接口实现本质是隐式的（非侵入式的），或者可以说是<code>duckable</code>的，pythoner对此应该深有理解：）</p>
<ol>
<li><code>Stringers</code>是一个常见的接口，类似python中的<code>__str__</code>或者java中的<code>toString</code>，它只需要实现<code>String</code>方法；</li>
<li>Go里面没有异常，仍然使用错误。<code>error</code>是一个接口，只有一个方法<code>Error() string</code>，通常函数会返回一个<code>error</code>，放在第二个位置，如果其不为<code>nil</code>则说明出了错误；</li>
<li>其他常见接口包括<code>io.Reader</code>，表示从数据流结尾读取；<code>http.Handler</code>表示处理HTTP请求的服务器；<code>image.Image</code>表明一个图像的接口；</li>
<li>接口可以通过接口来组合</li>
</ol>
<hr>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ol>
<li><code>goroutine</code>是Go运行时的轻量级线程（协程），在方法名前加<code>go</code>就在另一个线程中同步执行了；</li>
<li><code>channel</code>是有类型的管道，可以使用<code>&lt;-</code>操作符对其发送或接受值，使用<code>make(chan int， 100)</code>创建一个<code>int</code>的<code>channel</code>，第二个参数表示缓冲区长度，也可以不带，表示完全无缓冲；</li>
<li><code>&lt;-chan</code>和<code>chan&lt;-</code>分别表示只读和只写的chan，后面跟着管道中的数据类型，如<code>a &lt;-chan *int</code>表示只读的整数指针通道；</li>
<li><code>close</code>一个<code>channel</code>表示不再发送数据（只有发送者可以关闭），向已经<code>close</code>的<code>channel</code>发送数据会引起<code>panic</code>。使用<code>range</code>则表示从<code>channel</code>中源源不断的接受数据直到被关闭；</li>
<li><code>select</code>语句使得一个goroutine在多个通讯操作上等待，阻塞直到某个分支可行，例如：<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// var a, b chan int</span></div><div class="line"><span class="keyword">select</span>&#123;</div><div class="line">    <span class="keyword">case</span> x &lt;- a:</div><div class="line">        <span class="comment">//...</span></div><div class="line">    <span class="keyword">case</span> &lt;- b:</div><div class="line">        <span class="comment">//...</span></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当所有分支都不可行时，执行<code>default</code>语句；</p>
<ol>
<li><code>sync.Mutex</code>提供了互斥锁，包括<code>Lock</code>和<code>Unlock</code>两个方法，可以使用<code>defer</code>语句保证锁一定会被释放；</li>
<li>Go与Erlang的并发模型分别是CPS和Actor，但是Go的channel里面可以传递指针，这和Erlang的变量不可更改有着根本性质的区别。</li>
</ol>
<hr>
<p>至此，基础部分结束。</p>
<hr>
<h2 id="进阶部分"><a href="#进阶部分" class="headerlink" title="进阶部分"></a>进阶部分</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li>前面导出了<code>GOPATH</code>环境变量，这个路径就是实际的工作空间。从结论来看，Go提倡将所有Go语言项目放入同一个工作路径，这是很不好的；</li>
<li>如果使用过<code>go get</code>命令，那么<code>GOPATH</code>下会自动创建<code>bin</code>, <code>pkg</code>和<code>src</code>三个文件夹，源码存放在<code>src</code>之下，<code>import</code>本地包时，就是从这一层开始的。<code>go get</code>无法控制依赖的版本（垃圾）；</li>
<li><code>go install</code>会生成输出文件（可执行或者库），<code>go build</code>则仅编译；</li>
</ol>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><ol>
<li>Go自带了一个工具<code>go fmt</code>用来对代码进行格式化；</li>
<li>注释的格式和C++一致。使用<code>godoc</code>生成文档，类似python的docstring，但是约定更加简单：对类型、变量、常量、函数或者包的注释，在其定义前编写普通的注释即可，不要插入空行。Godoc 将会把这些注释识别为对其后的内容的文档。</li>
<li>与顶级定义不相邻的注释，会被 godoc 的输出忽略，但有一个意外。以“BUG(who)”开头的顶级注释会被识别为已知的 bug，会被包含在包文档的“Bugs”部分。</li>
<li><code>getter</code>没有必要用<code>Get</code>开头，直接大写首字母就行，<code>setter</code>还可以留着<code>Set</code>；</li>
<li>Go习惯使用驼峰式写法，而不是下划线；</li>
<li>Go其实是需要分号的，但是分号是自动插入的。这造成了一些非常奇怪的约定。例如左大括号必须放在一行末尾…</li>
<li><code>new</code>用来分配内存，并且填0，返回指向对象的指针，程序可以利用这些指针进行手动初始化；<code>make</code>则只能用来创建内置类型(slice, map和channel)，返回的是对象本身，而不是指针；</li>
<li><code>array</code>是一种对象，和它的大小相关；array名并不是指针（和C不同）；</li>
<li><code>print</code>语系和C中基本一致, <code>%v</code>可以拿到值，<code>%T</code>可以拿到类型；</li>
<li><code>interface {}</code>相当于C中的<code>void *</code>可以被转化为任意类型，一种常见的反射方式是使用<code>v.(type)</code>，这被称作<code>type assertion</code>. 比如<code>str, ok = v.(string)</code>，返回的就是string类型；另外可以在<code>switch</code>语句里面用<code>x.(type)</code>，然后再<code>case</code>里面判断类型；</li>
<li><code>import</code>后必须使用，否则会报错（傻逼设定。。），可以用<code>import _ &quot;fmt&quot;</code>的方法导入但不使用，或者用<code>_</code>赋值；另外就是可以直接导入包内全部方法，使用<code>import * &quot;fmt&quot;</code>；</li>
<li>可以通过往<code>struct</code>里面塞匿名字段（另一个struct，或其指针）来达到继承的目的，虽然看起来很奇怪就是了。注意的是，这本质上只是一种语法糖。外围的同名元素会覆盖继承（内嵌）的；同样，也可以往<code>interface</code>里面塞一个别的<code>interface</code>达到继承接口的目的；</li>
<li><code>panic</code>和<code>recover</code>是最后手段；</li>
</ol>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ol>
<li>使用<code>reflect</code>包来进行反射；</li>
<li>golang里面每个值都有<code>Type</code>和<code>Value</code>，这是因为所有值都是<code>interface{}</code>的实现者，而后者实际上是一个空类型，所以需要<code>Type</code>和<code>Value</code>用于反射。这也就对应着<code>reflect.Type</code>和<code>reflect.Value</code>，也对应着<code>%T</code>和<code>%v</code>，也对应着<code>reflect.TypeOf()</code>和<code>reflect.ValueOf</code>；</li>
<li><code>reflect.Type</code>和<code>reflect.Value</code>并不是并列的（并不能顾名思义）；而是一种包含关系，<code>reflect.Value</code>是一个<type, value="">的二元组，<code>reflect.ValueOf(x).Type</code>与<code>reflect.TypeOf(x)</code>是一致的，返回的是静态类型；<code>reflect.ValueOf(x).Kind</code>可以返回一个常量定义的类型（如<code>reflect.Float64</code>)，这是一个底层类型。</type,></li>
<li>可以从<code>reflect.ValueOf(x).Interface()</code>还原接口值，后续跟随类型断言等；输出<code>reflect.Value</code>的正确方法是将其先转为<code>interface{}</code>；</li>
<li><code>reflect.ValueOf(x).SetXXX</code>的前提是x是可修改的(<code>CanSet</code>)，借助指针来修改的方法是：<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">1.1</span></div><div class="line">p := reflect.ValueOf(&amp;x)</div><div class="line">v := p.Elem()</div><div class="line">v.CanSet() == <span class="literal">true</span></div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实前段时间我已经试着学习Go了，但是由于没啥项目需求所以很快就忘了，这次借着要写heka插件的机会重新学习一下，巩固一下基础知识。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://YiuTerran.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Heka插件开发</title>
    <link href="http://YiuTerran.github.io/2017/06/12/Heka%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://YiuTerran.github.io/2017/06/12/Heka插件开发/</id>
    <published>2017-06-12T15:48:37.000Z</published>
    <updated>2017-06-12T16:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习Go主要是为了开发heka的插件，heka和logstash不一样，插件多半还是靠自己开发。而logstash大部分情况下只需要使用自带的插件，简单的自定义处理只需用自带的<code>ruby</code>插件，复杂的才需要自己写插件来处理。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Heka是一个基于插件的日志处理系统，其基本结构如下（图片来自网络）：<br><img src="http://skoo.me/assets/images/heka-overview-diagram.png" alt="Heka结构图"></p>
<p>显然这是一个流式处理系统，从输入流到输出流之间经过一系列的处理。其流程被抽象成几个类似与logstash的步骤，包括分割；解码；过滤；编码；输出。</p>
<h3 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h3><ol>
<li>使用<code>go get github.com/mozilla-services/heka</code>(自备梯子)下载heka项目；</li>
<li>到<code>$GOPATH/github.com/mozilla-services/heka</code>下，先用<code>git checkout v0.10.0</code>切换到最新的<code>0.10.0</code>稳定版，然后再<code>source build.sh</code>进行编译，系统依赖参见<a href="https://hekad.readthedocs.org/en/v0.10.0/installing.html" target="_blank" rel="external">官方文档</a>。编译过程中会去线上下载一些go的依赖，所以仍然注意要备好梯子…</li>
<li>第一次编译时间较长，尤其是网速不给力的时候，你可以去喝杯咖啡…编译完成后可以使用<code>ctest</code>来测试一下。令人尴尬的是使用go1.5测试失败…貌似有些bug；</li>
<li>官方给出了一个插件的example，就在<code>heka/examples</code>文件夹下。使用方法：在<code>heka/</code>下新建<code>externals/host_filter</code>文件夹，然后将<code>examples/host_filter.go</code>复制到该文件夹下，最后在<code>heka/cmake/plugin_loader.cmake</code>中添加<code>add_external_plugin(git http://xxx/host_filter :local)</code>，最后重新编译项目，就会得到包含插件<code>host_filter</code>的二进制文件<code>hekad</code>；</li>
</ol>
<blockquote>
<p>使用Go1.5编译v0.10.0自带的example <code>host_filter.go</code>会提示<code>enough arguments in call to pack.Recycle</code>。查看提示的79行代码，发现<code>pack.Recycle()</code>少了个参数，传入<code>nil</code>重新编译即可。重新编译前在<code>build</code>文件夹中运行<code>make clean-heka</code>进行一次清理。</p>
</blockquote>
<h3 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h3><p>手头的项目需求如下：</p>
<ol>
<li>输出json形式的按行分割的log；</li>
<li>json中有<code>type</code>字段，根据type的不同生成不同的<code>map</code>，但最后被送到同一个output插件中；</li>
<li>output到mongo中，每个数据需要存在两个表中，分别是按日统计的累加表和总的累加表，以便统计按日数据和总体趋势数据；</li>
</ol>
<p>根据上述描述，应该使用<code>LogstreamerInput</code>引入输入，spliter使用默认的<code>token_spliter</code>按行进行分割即可，decoder使用<code>json decoder</code>，参考配置：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[LogstreamerInput]</div><div class="line">log_directory = "/var/log/lucky"</div><div class="line">file_match = 'track\.json'</div><div class="line">decoder = "JsonDecoder"</div><div class="line"></div><div class="line">[JsonDecoder]</div><div class="line">type = "SandboxDecoder"</div><div class="line">filename = "lua_decoders/json.lua"</div><div class="line">    [JsonDecoder.config]</div><div class="line">    Type = "type"</div><div class="line">    payload_keep = true</div><div class="line">    Timestamp = "@timestamp"</div><div class="line">    timestamp_format = "%Y-%m-%dT%H:%M:%S.%f"</div></pre></td></tr></table></figure></p>
<p>我现在需要编写一个自定义的filter和一个output插件。filter的格式可以参考<code>host_filter</code>里面的例子， output则可以参考plugin里面的<code>elasticserach.go</code>。</p>
<p>实际在编写过程中发现，如果log的格式是json，使用go做解析非常费劲。Json比较适合动态语言，对于静态的Go，只能通过<code>map[string]interface{}</code>这种做映射和强制转换。而<code>Message.Fields</code>是一个<code>*[]Field</code>，这意味着Json被映射成了一个数组，由于这里是业务日志分析，有很多数据结构不同的日志输出，如果使用默认的这种数组遍历的filter方式，写起来非常麻烦。所以我把payload仍然保留，然后使用<code>encoding/json</code>将payload解析成一个<code>map[string]interface{}</code>，这样虽然仍然很麻烦，但是工作量已经减轻不少。</p>
<p>mongo和redis在go中已经有成熟的库，直接引用即可。个人的工作量就是自定义解析过程，其实不难，就是动态语言写久了再写静态语言感觉有点繁琐。官方有<a href="https://hekad.readthedocs.org/en/v0.10.0/developing/plugin.html" target="_blank" rel="external">插件开发指导</a>，仔细阅读一遍，然后再参考里面已有的plugin，就可以动手写了。注意现在（刚发布）example的<code>host_filter</code>和0.10.0有些标准不和，可能随后才会更新。</p>
<h3 id="lua开发"><a href="#lua开发" class="headerlink" title="lua开发"></a>lua开发</h3><p>使用lua解析json显然更加得心应手。最后我自己写了一个decoder，将数据解析为<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"UserId"</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">"Set"</span>: &#123;&#125;,</div><div class="line">    <span class="attr">"Inc"</span>: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，在Go文件中仅仅需要把对应的数据直接更新到mongo中，而无需一层层的分析数据。大大减轻了工作量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Go主要是为了开发heka的插件，heka和logstash不一样，插件多半还是靠自己开发。而logstash大部分情况下只需要使用自带的插件，简单的自定义处理只需用自带的&lt;code&gt;ruby&lt;/code&gt;插件，复杂的才需要自己写插件来处理。&lt;/p&gt;
&lt;h3 id=&quot;概
    
    </summary>
    
    
      <category term="go" scheme="http://YiuTerran.github.io/tags/go/"/>
    
      <category term="heka" scheme="http://YiuTerran.github.io/tags/heka/"/>
    
  </entry>
  
  <entry>
    <title>java GC调优步骤</title>
    <link href="http://YiuTerran.github.io/2017/06/12/java%20GC%E8%B0%83%E4%BC%98%E6%AD%A5%E9%AA%A4/"/>
    <id>http://YiuTerran.github.io/2017/06/12/java GC调优步骤/</id>
    <published>2017-06-12T15:48:32.000Z</published>
    <updated>2017-06-12T16:26:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>0.增加GC相关选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-verbose:gc</div><div class="line">-XX:+UseGCLogFileRotation</div><div class="line">-XX:NumberOfGCLogFiles=5</div><div class="line">-XX:GCLogFileSize=512K</div><div class="line">-XX:+PrintGCDetails</div><div class="line">-XX:+PrintGCTimeStamps</div><div class="line">-XX:+PrintGCDateStamps</div><div class="line">-XX:+PrintTenuringDistribution</div><div class="line">-XX:+PrintGCApplicationStoppedTime</div><div class="line">-Xloggc:/var/app/log/Push-server/gc.log</div></pre></td></tr></table></figure></p>
<ol>
<li>如果不能确定所需内存，使用自动jvm自动调优；</li>
<li>大致确定所需内存后，使用-Xmx -Xms设置堆大小；</li>
<li>观察GC log确定FullGC后剩余堆大小（即为活跃数据大小）；</li>
<li>整个堆大小宜为老年代活跃数据大小的3-4倍；</li>
<li>永久带大小应该比永久带活跃数据大1.2~1.5倍；</li>
<li>新生代空间应该为老年代空间活跃数据的1~1.5倍；</li>
<li>通过top命令观察栈占用空间、直接内存占用空间，决定所需机器内存大小；</li>
<li>新生代大小决定了Minor GC的周期和时长，缩短新生代大小可以减少停顿时长，但是增加了GC频率；在调整新生代大小时，尽量保持老年代大小不变；</li>
<li>老年代大小不应该小于活跃数据的1.5倍；新生代空间至少为java堆大小的10%；增加堆大小时，注意不要超过可用物理内存数；</li>
<li>从throughput收集器迁移到CMS时，需要将老年代空间增加20%~30%；</li>
<li>新生代分为Eden和Survivor两部分，Survivor可以通过<code>-XX:SurvivorRatio=xx</code>来控制，对应的大小为<code>-Xmn&lt;value&gt;/(ratio+2)</code>；</li>
<li>通过<code>-XX:MaxTenuringThreshold=&lt;n&gt;</code>来指定晋升阈值（年龄），n为0~15之间；</li>
<li>期望Survivor空间为剩余总存活对象大小的2倍(age=1；</li>
<li>注意调节Survivor大小时，保持Eden大小不变；</li>
<li>如果Survivor空间足够大，且对象大部分并未到达老年代，那么就可以将晋升年纪指定的足够大（15）。在Eden与Survivor之间复制和CMS老年代空间压缩之间，我们宁愿选择前者；</li>
<li>CMS必须能以对象从新生代提升到老年代的同等速度对老年代中的对象进行收集，否则，就会失速；</li>
<li>如果观察到’concurrent mode failures’，意味着失速已经发生，必须减少<code>-XX:CMSInitiatingOccupancyFraction=&lt;percent&gt;</code>的值；</li>
<li>使用上述选项的同时，最好同时使用<code>-XX:+UseCMSInitiatingOccupancyOnly</code>，强制使用该比例,该比例的大小应该大于老年代占用空间和活跃数据大小之比，一般而言<code>老年代大小*该比例&gt;1.5*老年代活跃数据大小</code>；</li>
<li>使用<code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsCloasses</code>可以使用CMS进行显式垃圾回收（<code>System.gc()</code>)；通过<code>-XX:+DisableExplicitGC</code>关闭显示垃圾回收（慎用）；</li>
<li>使用<code>-XX:+CMSClassUnloadingEnabled</code>打开永久带垃圾回收，使用<code>-XX:+CMSPermGenSweepingEnabled</code>打开CMS对永久带的扫描；使用<code>-XX:CMSInitiatingPermOccupancyFraction=&lt;perscent&gt;</code>激活回收比例阈值；</li>
<li>使用<code>-XX:ParallelGCThreads=&lt;n&gt;</code>控制扫描线程数；使用<code>-XX:+CMSScavengeBeforeRemark</code>强制重新标记前进行一次MinorGC；如果由大量的引用对象或可终结对象要处理，使用<code>-XX:+ParallelRefProcEnabled</code>；</li>
<li>CMS包括Minor GC所带来的开销应该小于10%；</li>
<li>如果缺少长时间调优的条件，安全起见，可以使用G1，仅设置如下参数即可：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-d64</div><div class="line">-Xmx5g</div><div class="line">-Xms5g</div><div class="line">-XX:PermSize=100m</div><div class="line">-XX:MaxPermSize=100m</div><div class="line">-XX:MaxDirectMemorySize=1g</div><div class="line">-XX:+UseG1GC</div><div class="line">-XX:MaxGCPauseMillis=80</div></pre></td></tr></table></figure>
</li>
</ol>
<p>G1不必明确设置新生代大小，其自动调优也十分可靠，对于停顿时间往往在长时间运行后可以达到预期效果；对吞吐量优先的应用，可能不是那么明显。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0.增加GC相关选项：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div 
    
    </summary>
    
    
      <category term="java" scheme="http://YiuTerran.github.io/tags/java/"/>
    
      <category term="gc" scheme="http://YiuTerran.github.io/tags/gc/"/>
    
      <category term="jvm" scheme="http://YiuTerran.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>web开发进阶</title>
    <link href="http://YiuTerran.github.io/2017/06/12/web%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"/>
    <id>http://YiuTerran.github.io/2017/06/12/web开发进阶/</id>
    <published>2017-06-12T15:48:23.000Z</published>
    <updated>2017-06-12T16:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前的项目还是用backbone写控制台，说实话，快写吐了…前段时间看了一下ES6，ES7的变化，发现javascript正在变得越来越好，加上V8的给力性能，在web开发这块，js取代python指日可待。当然python丰富的第三方库决定了它在运维/科学计算/爬虫等方面的可靠性，仍然是值得推荐的第一入门语言（当然，学院派最好从lisp入手）。</p>
<p>要我说，现在创业公司就应该从js全栈起步，后台前端都用js，小活用meteor这种神器快速搭建，确定方向后再前后端分离认真设计。后端用react，再到naive，桌面段由node-webkit，大全栈一统天下。性能跟不上的模块再重构就可以直接用go/C++之类的，或者用jvm系的东西。时至今日，java的速度已经不慢（至少比一堆脚本语言快），组件多，好招人，适合迅速起步。</p>
<p>10个人的创业团队，5个js全栈（back/front/react-naive/node-webkit），3个jvm系(android/spark/storm等)，1个object-C系（apple），1个python系（运维），感觉就够了。js必将一统天下，这也是大势所趋。虽然说没有银弹，但是有一门能解决大部分场景问题的语言，还是非常了不起的。</p>
<p>我之前一直讨厌用js的原因无非是因为这门语言实在太糟蹋了，到了ES6，js越来越python，也可以愉悦的使用了。</p>
<p><strong>推荐使用nesh作为交互程序进行测试，或者使用nodejs kernel for ipython</strong></p>
<p>学习步骤：ES6-&gt;React-&gt;redux-&gt;meteor，目的是熟练使用meteor搭建一些小网站满足需求。<br>然后是react native -&gt; app开发，目的是了解一下客户端技术。</p>
<h2 id="ES6要点"><a href="#ES6要点" class="headerlink" title="ES6要点"></a>ES6要点</h2><blockquote>
<p>from [阮一峰的书][1]，测试推荐使用<code>nesh</code> -b</p>
</blockquote>
<ol>
<li>使用<code>let</code>声明变量，而不是<code>var</code>，主要引入原因是<code>var</code>有性能问题，且作用域自动提升；使用<code>let</code>声明的变量，其表现行为与其他语言中的变量一致（如c++）；</li>
<li>使用<code>const</code>声明常量；</li>
<li><p>使用<code>...</code>进行解构。这个是FP中常用的语法，<code>python</code>中也有(<code>*</code>和<code>**</code>)；不同的是，js的解构允许默认值，如果解构失败，变量就是undefined，如果有默认值，这里就会使用默认值；默认值是惰性求值的；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [a, b=<span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line"><span class="keyword">var</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]      <span class="comment">//这个解构只能放在最后，不如haskell中那么高级</span></div></pre></td></tr></table></figure>
</li>
<li><p>对象也可以解构，当然对象本身是无序的，所以解构的变量名必须和key名字一致，否则必须重新映射：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: baz&#125; = &#123;<span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span>&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个功能经常用在传递函数参数上，调用方传入一个Object，接受函数可以用(<code>{param1, param2}</code>)直接解包，将key对应的value赋给变量；</p>
<ol>
<li>字符串也可以解构成字符，因为字符串本来就是字符数组（只是不可变）</li>
<li>Unicode支持增强，允许使用<code>\u{20BB7}</code>来进行UTF-16表示；使用新的<code>String.fromCharCode</code>来转换Unicode；使用新的<code>at</code>方法来取出字符；</li>
<li>提供了类似python的<code>includes</code>, <code>startsWith</code>,<code>endsWith</code>方法；提供<code>repeat</code>方法快速生成字符串；提供<code>padStart</code>,<code>padEnd</code>方法填充字符串；</li>
<li>终于，有官方支持的字符串模板了（泪流满面）。格式类似shell：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>${}</code>内部可以进行各种运算，包括直接调用函数，这个看起来有点像bash中的引用变量；</p>
<ol>
<li>标签模板，允许使用函数后紧跟模板，相当于把模板中的常量和变量当做参数传入该函数；使用<code>String.raw</code>后跟模板，输出的就是别的语言中的原生字符串；</li>
<li>正则表达式也有所增强，使用的时候再看吧；</li>
<li><code>Number.isFinite</code>和<code>Number.isNaN</code>用来检测特殊值，和内置的区别是非数字直接返回false；</li>
<li>同样，将内置的<code>parseInt</code>, <code>parseFloat</code>也变成了Number的方法；</li>
<li><code>isInteger</code>用来检测是否整数，但是由于js只有浮点数，所以<code>15.0</code>就是<code>15</code>；</li>
<li>用<code>Number.EPSILON</code>表示一个极小的误差范围；</li>
<li>引入常量表示精度上下限；</li>
<li>新增了17个Math方法；</li>
<li>使用<code>**</code>表示指数运算，同python；</li>
<li><code>Array.from</code>将类数组或可迭代对象转为数组；<code>Array.of</code>将一组值转换为数组；使用<code>includes</code>查找是否在数组中；</li>
<li>ES6会明确把数组中的空洞转为<code>undefined</code>；</li>
<li>ES7将引入列表推导，pythoner的最爱之一；</li>
<li>函数允许默认参数；引入lambda表达式<code>=&gt;</code>，lambda表达式的this就是外界的this；ES7引入作用域绑定符号<code>::</code>用来绑定lambda的作用域；</li>
<li>尾递归优化；</li>
<li>可以使用<code>Object.assign</code>进行深拷贝；</li>
<li>Symbol用来生成独一无二的标识，可以用来当key；</li>
<li>Proxy可以用来给对象做代理，做一些限制；</li>
<li>引入二进制数组；</li>
<li>引入Set和Map，注意不能使用<code>[]</code>进行操作；</li>
<li>引入<code>for..of..</code>循环，代替原来一些循环方式；注意的是在object中<code>for..of..</code>返回的是value，key仍然用<code>for..in..</code>，但是<code>Map</code>则返回的是<code>[k, v]</code>的一个数组；</li>
<li>引入<code>yield</code>作为生成器；</li>
<li>引入<code>Promise</code>解决异步编程问题；</li>
<li>引入<code>Async</code>，作为生成器的语法糖。使用async将过程转为异步，使用<code>await</code>表示同步阻塞；这个东西是ES6最精华的部分；</li>
<li>引入<code>Class</code>语法糖，更加OO. 构造函数是<code>constructor</code>，成员函数无需<code>function</code>关键字；使用<code>extends</code>进行继承；使用<code>super</code>关键字表示父类；可以扩充原生对象；方法前加星号表示生成器函数；<code>static</code>关键字表示静态函数；静态属性只能写在外面，ES7可能可以写在里面；</li>
<li>装饰器。</li>
<li>导入命令，格式是：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; stat, exists &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">'./test'</span>; <span class="comment">//overide namespace</span></div><div class="line"><span class="keyword">import</span> &#123; long <span class="keyword">as</span> l &#125; <span class="keyword">from</span> <span class="string">'xx'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> xxx;</div><div class="line"><span class="keyword">import</span> x <span class="keyword">from</span> xxx; <span class="comment">// import default</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> firstName = <span class="string">"xxx"</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前的项目还是用backbone写控制台，说实话，快写吐了…前段时间看了一下ES6，ES7的变化，发现javascript正在变得越来越好，加上V8的给力性能，在web开发这块，js取代python指日可待。当然python丰富的第三方库决定了它在运维/科学计算/爬虫等方面
    
    </summary>
    
    
      <category term="web" scheme="http://YiuTerran.github.io/tags/web/"/>
    
      <category term="javascript" scheme="http://YiuTerran.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="http://YiuTerran.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>erlang速记</title>
    <link href="http://YiuTerran.github.io/2017/06/12/erlang%E9%80%9F%E8%AE%B0/"/>
    <id>http://YiuTerran.github.io/2017/06/12/erlang速记/</id>
    <published>2017-06-12T15:48:18.000Z</published>
    <updated>2017-06-12T16:25:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于学习过Haskell的人来说，学习Erlang并没有太大的难度。</p>
<h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><ol>
<li>首字母小写或者用单引号括起来的表示原子；首字母大写表示变量；原子等于原子本身。</li>
<li>tuple用{}表示，列表用[]表示；</li>
<li>用<code>=</code>作模式匹配，用<code>|</code>做头尾区分，用双引号表示字符串（本质是一串数字，可以用<code>$</code>取得字符对应的数字）;</li>
<li><code>.</code>表示模式终结，<code>,</code>用来分割参数，函数；<code>;</code>用来分割子句；</li>
<li>函数的参数个数，称为函数的目；<code>func</code>关键字用来定义匿名函数；</li>
</ol>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">func</span><span class="params">(X, Y)</span> -&gt;</span> math:sqrt(X*X + Y*Y) <span class="keyword">end</span>.</div></pre></td></tr></table></figure>
<p>可以把返回值放到括号里面。</p>
<ol>
<li>标准库<code>lists</code>里面含有很多常见的函数，如<code>map</code>, <code>reduce</code>， <code>filter</code>等；</li>
<li>没有<code>for</code>循环，和haskell一样，使用尾递归；</li>
<li>使用<code>import</code>, <code>export</code>, <code>module</code>来导入/导出/声明模块；</li>
<li><p>列表解析，格式是<code>[X *2 || X &lt;- L].</code></p>
<figure class="highlight erl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">qsort</span><span class="params">([])</span> -&gt;</span> [];</div><div class="line"><span class="function"><span class="title">qsort</span><span class="params">([H|T])</span> -&gt;</span></div><div class="line">    qsort([X || X &lt;- T, X &lt; H]) ++</div><div class="line">    [H] ++</div><div class="line">    qsort([X || X &lt;- T, X &gt;= H]).</div></pre></td></tr></table></figure>
</li>
<li><p>断言，关键字<code>when</code>。使用<code>,</code>表示<code>andalso</code>语义， 使用<code>orelse</code>而不是<code>or</code>因为后者不是短路求值；</p>
</li>
<li>使用<code>record</code>表示字典，声明方式：<figure class="highlight erl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">-record</span><span class="params">(todo, &#123;stats=reminder, who=joe, text&#125;)</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>需要将其存放在<code>.hrl</code>后缀的文件中，然后使用<code>rr</code>读取。<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">X=#todo&#123;&#125;.</div><div class="line">Y=#todo&#123;status=urgent, text=<span class="string">"Fix errata in book"</span>&#125;.</div><div class="line">Z=Y#todo&#123;status=done&#125;.</div><div class="line">#todo&#123;who=W, text=Txt&#125; = Z <span class="comment">%模式匹配</span></div></pre></td></tr></table></figure></p>
<p>可以使用<code>is_record</code>做模式匹配；</p>
<ol>
<li><p><code>case xxx of Pattern1 [when Guard1] -&gt; xxx end</code></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">odds_and_evens_acc</span><span class="params">(L)</span> -&gt;</span></div><div class="line">    odds_and_evens_acc(L, [], []).</div><div class="line"></div><div class="line"><span class="function"><span class="title">odds_and_evens_acc</span><span class="params">([H|T], Odds, Evens)</span> -&gt;</span></div><div class="line">    <span class="keyword">case</span> (H <span class="keyword">rem</span> <span class="number">2</span>) <span class="keyword">of</span></div><div class="line">        <span class="number">1</span> -&gt; odds_and_evens_acc(T, [H|Odds], Evens);</div><div class="line">        <span class="number">0</span> -&gt; odds_and_evens_acc(T, Odds, [H|Evens])</div><div class="line">    <span class="keyword">end</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="title">odds_and_evens_acc</span><span class="params">([], Odds, Evens)</span> -&gt;</span></div><div class="line">    &#123;Odds, Evens&#125;.</div></pre></td></tr></table></figure>
</li>
<li><p>异常的捕捉采用<code>try...catch..after...end</code>格式，非常类似java；</p>
</li>
<li>数字格式包括<code>2#01011</code>其中<code>#</code>前面是进制，浮点数可以用科学计数法，即<code>-2.3e+6</code>等；</li>
<li>每个进程都有一个私有数据存储，称为进程字典，可以用<code>put</code>,<code>get</code>, <code>get_keys</code>, <code>erase</code>等函数进行操作；但是如果使用进程字典，代码就不再是没有副作用的，因此要避免使用；</li>
<li>引用是全局唯一的Erlang值，使用<code>erlang:make_ref()</code>来创建引用；</li>
<li>奇怪的操作符： <code>==</code>, <code>/=</code>, <code>=:=</code>全等，<code>=/=</code>不全等；数值比较会有隐式转换；<code>==</code>仅限于浮点数和整数的比较，大部分情况下，应该使用<code>=:=</code>；</li>
<li>奇怪的排序：<code>number</code>&lt;<code>atom</code>&lt;<code>reference</code>&lt;<code>fun</code>&lt;<code>port</code>&lt;<code>pid</code>&lt;<code>tuple</code>&lt;<code>list</code>&lt;<code>binary</code>；</li>
<li><p>下划线变量：仅用来声明不准备使用的变量（占位符）；或者用来调试；</p>
</li>
<li><p>对于大的程序，还是要使用makefile的，然而直到今天我还是不会写makefile，不过我决定抽个时间学习以下cmake的使用；使用<code>code:get_path()</code>查看搜索路径，<code>code:add_patha</code>, <code>code:add_pathz</code>用来增加新目录；</p>
</li>
<li>可以在<code>~/.erlang</code>下增加一些命令，当启动<code>erl</code>shell时，会先执行这里的初始化语句；当前目录下的<code>.erlang</code>会覆盖home下的执行优先级。可以使用<code>init:get_argument(home)</code>确定home的路径（for windows）；</li>
<li>erlang需要在运行前编译，或者用<code>escript</code>命令执行而无需编译（解释器）。escript的语法与erlang本身略有不同。当然我想不到在什么情况下要写erlang脚本。。。因为erlang并不是一门好的脚本语言。python才是现在的最优选择：）</li>
</ol>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><ol>
<li>和go一样，很简单的创建进程：<code>Pid=spawn(Fun)</code>；</li>
<li>发送消息： <code>Pid ! Message</code>，异步发送。返回值是消息本身，这意味着使用<code>Pid1 ! Pid2 ! M</code>会将M发送到所有的Pid中；</li>
<li><p><code>receive ... end</code>， 接收一个发送到当前进程的消息；格式是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">receive</span></div><div class="line">    Pattern1 [When Guard1] -&gt;</div><div class="line">        Expression1;</div><div class="line">    Pattern2 [When Guard2] -&gt;</div><div class="line">        Expression2;</div><div class="line"><span class="keyword">after</span> Time -&gt;   <span class="comment">%超时</span></div><div class="line">    Expressions</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
</li>
<li><p>消息发送到进程的邮箱中，receive说白了是检查邮箱，如果消息不能匹配任何模式，则会被放到保存队列里；如果有一条消息能成功匹配，则放入保存队列里的旧消息会按着到达的先后顺序重新取出放入邮箱；如果有<code>after</code>设置，计时器到达后也会触发上述规则；</p>
</li>
<li><p>除了Pid机制外，可以采用注册进程的方式公开进程。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">register</span><span class="params">(Name, Pid)</span> %将P<span class="title">id</span>注册为N<span class="title">ame</span></span></div><div class="line"><span class="title">unregister</span><span class="params">(Name)</span></div><div class="line"><span class="title">whereis</span><span class="params">(Name)</span> -&gt; Pid | undefined <span class="comment">%检测是否注册成功</span></div><div class="line">registered() <span class="comment">%已注册进程list</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果想要热更新代码，最好使用MFA（即带着模块名）的调用方式创建进程；</p>
</li>
<li>使用<code>link(Pid)</code>在两个进程之间建立联系。二者之中任意一个挂掉，另一个都会收到系统通知；</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Erlang并不难，但是OTP很难。Erlang设计很用心，目标很明确，对于分布式大型系统的构建提供了很多基础支撑。缺点是生态系统略显封闭，社区不活跃，各种第三方库支持不全。相比之下，个人更看好Go的发展，虽然后者并不是为构建大规模系统而生，但是CPS模型的并发写起来也很舒服，加上简单的语法，快速的编译过程，完善的生态链，杰出的性能，是一个很不错的工具。</p>
<p>目前来看，Skynet+Lua就是仿制了Erlang的思想。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于学习过Haskell的人来说，学习Erlang并没有太大的难度。&lt;/p&gt;
&lt;h2 id=&quot;语法结构&quot;&gt;&lt;a href=&quot;#语法结构&quot; class=&quot;headerlink&quot; title=&quot;语法结构&quot;&gt;&lt;/a&gt;语法结构&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首字母小写或者用单引号括起来
    
    </summary>
    
    
      <category term="erlang" scheme="http://YiuTerran.github.io/tags/erlang/"/>
    
      <category term="FP" scheme="http://YiuTerran.github.io/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>java Proxy模式</title>
    <link href="http://YiuTerran.github.io/2017/06/12/java%20Proxy%E6%A8%A1%E5%BC%8F/"/>
    <id>http://YiuTerran.github.io/2017/06/12/java Proxy模式/</id>
    <published>2017-06-12T15:48:04.000Z</published>
    <updated>2017-06-12T16:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>java也可以使用反射生成动态代理，从而完成面向切面编程，这是spring框架的基础。<br>由于java的第一元素只有object，所以函数处于第二阶梯，这导致在其他语言中很容易(函数是第一类的语言中）实现的动态代理，在java中就必须以对象的形式实现。</p>
<p>在Python中使用<code>getattr(object, method)</code>可以轻易完成反射；最简单的可以这么做：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> inspect</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._real = Real()</div><div class="line">        <span class="keyword">for</span> method <span class="keyword">in</span> inspect.getmembers(_real, predicate=inspect.ismethod):</div><div class="line">            setattr(self, method[<span class="number">0</span>], self._call_real(m[<span class="number">0</span>])</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_call_real</span><span class="params">(self, method)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_real_proxy</span><span class="params">(*args, **kargs)</span>:</span></div><div class="line">            <span class="keyword">return</span> getattr(self._real, method)(*args, **kargs)</div><div class="line">        <span class="keyword">return</span> _real_proxy</div></pre></td></tr></table></figure></p>
<p>java生成动态代理的主要使用了<code>java.lang.reflect.Proxy</code>类的<code>newProxyInstance()</code>方法，其原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static Object newProxyInstance(ClassLoader loader,</div><div class="line">                                        Class&lt;?&gt;[] interfaces,</div><div class="line">                                        InvacationHandler h)throws IllegalArgumentException;</div></pre></td></tr></table></figure></p>
<p>参数：<br>loader - 定义代理类的类加载器<br>interfaces - 代理类要实现的接口列表<br>h - 指派方法调用的调用处理程序<br>返回：<br>一个带有代理类的指定调用处理程序的代理实例，它由指定的类加载器定义，并实现指定的接口<br>抛出：<br>IllegalArgumentException - 如果违反传递到 getProxyClass 的参数上的任何限制<br>NullPointerException - 如果 interfaces 数组参数或其任何元素为 null，或如果调用处理程序 h 为 null</p>
<p>动态代理类：在运行时生成的class，在其生成过程中，你必须提供一组接口给它，然后该class就声称实现了这些接口。可以把该class的实例当做这些接口中的任何一个来用。其实，这个Dynamic Proxy就是一个Proxy，他不会替你做任何实质性的工作。在生成它的实例时，必须提供一个Handler，由它接管实际的工作。<br>在使用动态代理类时，必须实现InvocationHandler接口。</p>
<p><code>InvaocationHandler</code>接口必须实现的方法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object invoke(Object proxy,</div><div class="line">              Method method,</div><div class="line">              Object[] args)</div><div class="line">              throws Throwable</div></pre></td></tr></table></figure></p>
<p>此处控制流翻转，该方法被回调，传入用户尝试调用的方法和参数，以及代理本身的实例。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java也可以使用反射生成动态代理，从而完成面向切面编程，这是spring框架的基础。&lt;br&gt;由于java的第一元素只有object，所以函数处于第二阶梯，这导致在其他语言中很容易(函数是第一类的语言中）实现的动态代理，在java中就必须以对象的形式实现。&lt;/p&gt;
&lt;p&gt;在
    
    </summary>
    
    
      <category term="java" scheme="http://YiuTerran.github.io/tags/java/"/>
    
      <category term="design_pattern" scheme="http://YiuTerran.github.io/tags/design-pattern/"/>
    
      <category term="proxy" scheme="http://YiuTerran.github.io/tags/proxy/"/>
    
      <category term="reflect" scheme="http://YiuTerran.github.io/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>cometd 学习文档</title>
    <link href="http://YiuTerran.github.io/2017/06/12/Cometd%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://YiuTerran.github.io/2017/06/12/Cometd使用笔记/</id>
    <published>2017-06-12T15:47:35.000Z</published>
    <updated>2017-06-12T16:22:36.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>cometd client 分为remote client和local client，remote client即是传统的cometd客户端，分为java和javascript两个版本；当remote client与server建立bayeux协议连接后，server session才被创建；而local client则是server侧的client，当server想要创建一个不与remote client直接连接的session时，必须先创建一个local client；</li>
<li>local client的作用在于，如果server并非简单的无条件转发信息到其他remote client，而是想要做一些server端的处理（比如仅仅发往特定的客户端），就需要一个local client。service通道都对应一个local client；</li>
<li>通道类型分为meta channel, broadcast channel和service channel，meta channel是禁止订阅的，用来处理协议的基本功能，包括/meta/handshake, /meta/connect, /meta/disconnect, /meta/subscribe, /meta/unsubscribe, /meta/publish, /meta/unsucessful；而broadcast channel类似与聊天室，服务器无条件转发来自broadcast channel的信息到所有的subscribers；service channel则类似于私聊，服务器有条件转发到指定的订阅了该服务的某一个或多个remote client；</li>
<li>server端是一个<code>BayeuxServer</code>对象，相关联的对象包括：<ul>
<li>transport，包括http和websocket，或其他自己实现的接口，这里用来实现bayeux的底层通信方式；</li>
<li>channels，通道</li>
<li>extensions，扩展用来与bayeux协议交互，是一种listener，可以用于在消息接收后、发送前等时刻对消息进行自定义处理</li>
<li>authorization，认证机制，一般通过<code>SecurityPolicy</code>来实现；也可以通过<code>Authorizer</code>进行更细粒度（如针对某个channel）的处理；</li>
<li>消息处理，可以通过回调（监听）对客户端发来的消息进行处理；</li>
</ul>
</li>
<li><p>Listener.</p>
<ul>
<li>客户端对某个channel的listener，用来处理服务器发送（或转发）的message(通过<code>ClientSession.getChannel(String).addListener(ClientSessionChannel.MessageListener)</code>来添加)；此外也可以通过添加extension对消息做最初或最后的处理；</li>
<li>Server端的Listener类似，但更加丰富，包括：<ul>
<li>extension, 对server的或对session的</li>
<li>channel create|destroy listener</li>
<li>subscribe|unsubscribe channel</li>
<li>session被remove</li>
<li>与server的message queue交互(<code>MaxQueueListener</code>, <code>DeQueueListener</code>等)</li>
<li>MessageListener</li>
</ul>
</li>
</ul>
</li>
<li><p>消息流动的过程：</p>
<ol>
<li>客户端通过client-side的channel发送消息，这些消息首先通过clientsession extension，做最后的过滤；然后通过底层的transport发往server。transport会将message转换为JSON格式，server transport接受到这些消息后，再将JSON字符串转为普通消息；</li>
<li>消息在server侧首先通过server extension，做最初的处理，此时如果被拒绝，返回给client的错误标示该消息已被删除；</li>
<li>消息随即被送往serversession extension，如果被拒绝，操作同上；</li>
<li>消息被送往security policy和authorizers接受审核，如果被拒绝，返回给客户端说明未通过认证；</li>
<li>消息被送往channel listener，服务器可以在channel listener里面对消息做任意修改；该步骤后，消息被冻结；</li>
<li>如果是nonbroadcast channel，会随即回复一条消息给发送者，表明服务器已收到消息并且该消息不是广播消息（貌似是将消息原样返回）；</li>
<li>如果是broadcast message，消息会通过serversession extension，然后插入server的message queue，准备发出；</li>
<li>如果是lazy message，消息需要等待一段时间，否则消息被立即发送出去；如果消息被发往remote client，会单独开一个线程进行异步发送，后续步骤包括转换为JSON格式，通过底层的transport等，类似客户端发送消息之前的方式；如果是local client，就直接发送过去；</li>
<li>不管是不是广播消息，消息被插入消息队列后，服务器会返回一条信息给发送者，标明发送结束；</li>
<li>客户端接收到消息，底层的tranport将消息转回普通格式，然后依次经过client session extension, channel listener和channel subscriber；</li>
<li>server每收到一条bayeux消息，会分配一个单独的线程进行消息处理，所有的listener都在这个单独的线程中被依序唤醒。client与server之间的连接是有限的，如果同一个连接在短时间内收到大量消息，而消息的处理过程过慢，就会导致后续消息被堵塞而无法得到及时处理。因此服务器在处理消息过程中如果有<strong>耗时处理</strong>，务必要<strong>单开线程</strong>；</li>
</ol>
</li>
<li>消息类型：<ul>
<li>客户端发往server的，主要是meta消息；</li>
<li>客户端发往指定客户端的，需要通过service通道，然后通过clientId deliver过去</li>
<li>服务器发往客户端的，需要服务器本地起一个local client session，与服务器握手，然后在该通道publish一个消息，这个local client充当了消息的sender</li>
<li>即使client没有subscribe一个channel，也可以在这个channel上publish message</li>
</ul>
</li>
<li>cometd server无法保证消息被正确送往client，除非client和server都打开message acknowledgment extension，这样二者在handshake时会在ext段增加特殊属性，协商完毕后，客户端会对每一条接受到的消息做出应答；这种机制提供了一种<strong>不可靠的</strong>失败重传功能；</li>
<li>seti是oort集群时用来发送消息的一种工具，如果a想向b发送信息，但是二者连在不同的comet节点上，这时候就需要转发消息、操作clientId等。seti可以将client与其他标识进行关联，这种关联可以是一对一的，也可以是一对多的。比如说，一个userid有多个deviceid，我们可以将userid与该用户的所有device的clientId都关联起来，也可以将其deviceid和对应的clientid对应起来，这样就可以直接转发了。</li>
<li>每个oort节点仅有1个seti对象，当userid第一次与seti关联时，会向所有节点广播此消息，这样其他节点都知道如果需要向某个userid发消息，需要把消息转发给这个seti；用户断开连接或者超时被移除session，这种关联会自动取消。当一个seti中，userid关联的所有session都断开连接时，userid会解除与seti的关联，然后广播此消息。我们可以监听这两种广播消息。</li>
<li>通过seti发送消息很简单，我们只需要指定userid，seti会自动找到其所连接的comet节点，进行发送；</li>
<li>comet节点之间的数据共享。<code>OortObject</code>用于解决此问题，这是一个分布式的架构，所有节点拥有此对象，此对象存放所有节点的共享数据，每个节点只能修改属于自己的那一部分，其他的是只读的，每次修改会广播给其他节点，其他节点可以监听这种广播，并做一些自定义修改。</li>
<li>服务转发功能，如果集群各个节点提供的服务不一致，可能需要此功能用于转发服务。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;cometd client 分为remote client和local client，remote client即是传统的cometd客户端，分为java和javascript两个版本；当remote client与server建立bayeux协议连接后，ser
    
    </summary>
    
    
      <category term="cometd" scheme="http://YiuTerran.github.io/tags/cometd/"/>
    
      <category term="java" scheme="http://YiuTerran.github.io/tags/java/"/>
    
      <category term="push" scheme="http://YiuTerran.github.io/tags/push/"/>
    
  </entry>
  
  <entry>
    <title>cometd使用haproxy做负载均衡的配置指南</title>
    <link href="http://YiuTerran.github.io/2017/06/12/cometd%E4%BD%BF%E7%94%A8haproxy%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <id>http://YiuTerran.github.io/2017/06/12/cometd使用haproxy做负载均衡的配置指南/</id>
    <published>2017-06-12T15:47:30.000Z</published>
    <updated>2017-06-12T16:22:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>Ubuntu14.04直接用apt安装就是最新的稳定版，其他旧版本Ubuntu需要使用ppa获得：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:vbernat/haproxy-1.5</div></pre></td></tr></table></figure></p>
<p>然后update，install即可。<br>(PS: 如果连<code>add-apt-repository</code>都不能用，先执行<code>sudo apt-get install python-software-properties</code>）</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>理论上直接用<code>sudo service haproxy start|stop|restart|status|reload</code>就可以，不过ubuntu直接安装后这个命令是没法用的…需要编辑<code>/etc/init.d/haproxy</code>，然后把<code>ENABLED=0</code>改成<code>ENABLED=1</code>，然后删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if [ -e /etc/default/haproxy ]; then</div><div class="line">	. /etc/default/haproxy</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>这几行。当然，也可以直接使用<code>sudo haproxy -f /etc/haproxy/haproxy.conf</code>来启动，加上<code>-d</code>参数可以在前台运行调试。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>如果同时使用两种transport(websocket和http)，需要注意long-polling的session保持问题。如果只使用websocket，需要注意的只有timeout的设置问题。</p>
<p>典型配置如下<a href="http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/" target="_blank" rel="external">^1</a>，默认路径为<code>/etc/haproxy/haproxy.conf</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">global</div><div class="line">  log 127.0.0.1 local0  #see /etc/rsyslog.d/haproxy.conf</div><div class="line">  chroot /var/lib/haproxy</div><div class="line">  pidfile /var/run/haproxy.pid</div><div class="line">  uid 99</div><div class="line">  gid 99</div><div class="line">  daemon        #run as service</div><div class="line">  nbproc 1      #only one instance allowed</div><div class="line">  maxconn 120000</div><div class="line"></div><div class="line">defaults</div><div class="line">  mode http</div><div class="line">  log global</div><div class="line">  option httplog        #log http info</div><div class="line">  option  http-server-close     #Don&apos;t keepalive between haproxy and server</div><div class="line">  option  redispatch    #if health check failed, dispath new server</div><div class="line">  option  forwardfor    #for server get Ip of client</div><div class="line">  retries 3             #connect to server fail max times before redispatch</div><div class="line">  timeout connect 10s   #timeout tcp connection between haproxy and backend servers</div><div class="line">  timeout client 50s    #timeout client inactivity</div><div class="line">  timeout server 50s    #timeout for server to process the request</div><div class="line">  timeout queue 30s     #timeout for request in queue when server reach max connection</div><div class="line">  timeout http-keep-alive 2s</div><div class="line">  timeout http-request 15s</div><div class="line">  default-server inter 5s rise 2 fall 3</div><div class="line">  stats uri /stats</div><div class="line">  stats refresh 10s</div><div class="line">  stats auth baina:P@55word</div><div class="line"></div><div class="line">frontend ft_web</div><div class="line">  bind *:80</div><div class="line">  timeout client 10m</div><div class="line">  timeout client-fin 5s</div><div class="line">  maxconn 120000</div><div class="line">  option  http-pretend-keepalive        #without this, handshake can&apos;t be established</div><div class="line">  default_backend cometd</div><div class="line"></div><div class="line">backend cometd</div><div class="line">  timeout server 10m</div><div class="line">  timeout tunnel 10m</div><div class="line">  balance roundrobin</div><div class="line">#  balance source</div><div class="line">  option httpchk GET /cometd HTTP/1.1\r\nHost:\ \r\nConnection:\ upgrade\r\nUpgrade:\ websocket</div><div class="line">  http-check expect status 101</div><div class="line">  cookie SERVERID insert</div><div class="line"></div><div class="line">  appsession SERVERID len 25 timeout 15m        #for Long-polling keep session</div><div class="line"></div><div class="line">server bayuex-srv1 10.232.2.118:80 maxconn 40000 weight 10 cookie bayuex-srv1 check</div><div class="line">server bayeux-srv2 10.235.30.6:80 maxconn 40000 weight 10 cookie bayeux-srv2 check</div><div class="line">server bayeux-srv3 10.45.160.213:80 maxconn 40000 weight 10 cookie bayexu-srv3 check</div></pre></td></tr></table></figure></p>
<p>存活检测通过<code>httpchk</code>选项来完成，cometd要求必须使用http1.1，因此header中必须要有Host，这里留空。</p>
<p>这里通过插入cookie来满足long polling的session保持需求，这要求client每次post都必须携带server发给client的cookie。当然这个问题也可以通过<code>balance source</code> hash ip来解决，但是后者可能会导致负载均衡度不高。</p>
<p><strong>注意</strong>，如果使用long polling，切记加上<code>option http-pretend-keepalive</code>，不然server会把<code>Connection: close</code>发给client，握手直接被终结.</p>
<h2 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h2><p>上述配置中，<code>log 127.0.0.1 local0</code>这句是用来配置log的，如果使用syslog，在<code>/etc/syslog.conf</code>中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">local0.* /var/log/haproxy/haproxy.log</div></pre></td></tr></table></figure></p>
<p>即可指定到具体文件。</p>
<p>ubuntu使用rsyslog，因此对应的配置方法如下<a href="http://blog.hintcafe.com/post/33689067443/haproxy-logging-with-rsyslog-on-linux" target="_blank" rel="external">^2</a>，默认路径<code>/etc/rsyslog.d/haproxy.conf</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ModLoad imudp</div><div class="line">$UDPServerRun 514</div><div class="line">$template Haproxy,&quot;%msg%\n&quot;</div><div class="line">local0.* -/var/log/haproxy.log;Haproxy</div><div class="line">&amp; ~</div></pre></td></tr></table></figure></p>
<p><strong>为使配置生效，请将文件名改为49-haproxy.conf</strong><br>日志的格式<a href="http://www.rsyslog.com/doc/rsyslog_conf_templates.html" target="_blank" rel="external">^3</a>可以通过配置<code>$template</code>参数来完成，这里写了最简单的一种输出格式。</p>
<p>日志滚动通过配置<code>/etc/logrotate.d/haproxy</code>来实现，默认有一个按日滚动的策略，一般够用了。<br>其格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/var/log/haproxy.log &#123;</div><div class="line">    daily       #按日滚动</div><div class="line">    rotate 10   #保留10个</div><div class="line">    missingok</div><div class="line">    notifempty</div><div class="line">    compress</div><div class="line">    delaycompress</div><div class="line">    postrotate</div><div class="line">        invoke-rc.d rsyslog rotate &gt;/dev/null 2&gt;&amp;1 || true</div><div class="line">    endscript</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##DDOS防范<br>haproxy可以用来做ddos防范，具体可参见：<br><a href="http://blog.sina.com.cn/s/blog_704836f40101f4qh.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_704836f40101f4qh.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;p&gt;Ubuntu14.04直接用apt安装就是最新的稳定版，其他旧版本Ubuntu需要使用ppa获得：&lt;br&gt;&lt;figure c
    
    </summary>
    
    
      <category term="cometd" scheme="http://YiuTerran.github.io/tags/cometd/"/>
    
      <category term="haproxy" scheme="http://YiuTerran.github.io/tags/haproxy/"/>
    
      <category term="websocket" scheme="http://YiuTerran.github.io/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>CometD源码学习[0]</title>
    <link href="http://YiuTerran.github.io/2017/06/12/CometD%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0_1/"/>
    <id>http://YiuTerran.github.io/2017/06/12/CometD源码学习_1/</id>
    <published>2017-06-12T15:47:25.000Z</published>
    <updated>2017-06-12T16:24:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jetty生命周期"><a href="#jetty生命周期" class="headerlink" title="jetty生命周期"></a>jetty生命周期</h2><p>Jetty的核心组件是<code>Server</code>和<code>Connector</code>，<code>Server</code>基于<code>Handler</code>容器工作，里面包括<code>ServletHandler</code>，<code>SessionHandler</code>等处理器，<code>Server</code>本身也继承自<code>Handler</code>类。<code>Connector</code>类用于监听连接请求；此外还有<code>Container</code>用来管理<code>MBean</code>。<br>Jetty的Server扩展是通过实现<code>Handler</code>并将至注册到<code>Server</code>中来实现的。<br>整个Jetty的组件的生命周期管理是基于观察者模板设计的，每个组件都有个<code>Listener</code>，用来监听Jetty启动/停止过程中的事件。</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>Jetty本身提供了两类<code>HandlerWrapper</code>和<code>ScopeHandler</code>两种<code>Handler</code>，前者是一个装饰器修饰的<code>Handler</code>，用来做委托(<code>Proxy</code>模式)，后者是一个拦截器——在调用<code>Handler</code>之前或之后做某些事情。</p>
<h3 id="prestart"><a href="#prestart" class="headerlink" title="prestart"></a>prestart</h3><p>Jetty在启动之前会先初始化jetty的相关配置(start.ini)，然后通过自己的<code>IOC</code>(<code>XmlConfiguration</code>)将这些服务组装在一起，最后调用<code>start</code>启动这些组件。其中最重要的配置文件包括<code>jetty.xml</code>, <code>jetty-deploy.xml</code>以及<code>contexts/*.xml</code>。然后根据配置文件中的参数新建一个进程应用JVM参数（如果有<code>--exec</code>，没有的话不会再起新的进程，<code>start.ini</code>中的JVM参数就不可能重新得到应用)。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Jetty的启动入口是<code>Server</code>类或者其子类。下图是Jetty启动过程：<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-jetty/image011.jpg" alt="Jetty Start process"><br>在创建线程池后，Server开始依次调用已注册Handler组件的<code>Start</code>方法，直至整个调用链结束（调用链的末尾应该是用户自定义的service），这一步是初始化各组件（filter, servlet，包括用户的服务）的配置；然后启动<code>Container</code>中已注册的MBean（for JMX），最后启动<code>Connector</code>开始接受请求。</p>
<p>Jetty作为一个轻量级web容器，不仅可以接受http协议作为web服务器，还可以与其他web应用服务器集成（如Jboss或Apache），这时候Jetty工作于AJP协议。</p>
<h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><p>对于http协议，按着传统的划分方式，分为BIO（阻塞式）和NIO（非阻塞式），以及AIO（异步式），windows的IOCP是AIO。</p>
<blockquote>
<p>BIO是一个连接一个线程。<br>NIO是一个请求一个线程。<br>AIO是一个有效请求一个线程。</p>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>如果jetty工作在BIO模式（选用<code>org.eclipse.jetty.server.bi.SocketConnector</code>作为<code>Connector</code>），建立连接的步骤分为：</p>
<ol>
<li>创建队列线程池，用于处理请求；</li>
<li>创建ServerSocket用于准备接受请求；</li>
<li>创建一个或多个监听线程（Accptor)，开始监听。</li>
<li>对于每个连接，BIO从线程池中分配一个线程进行处理；<br>时序图如下：<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-jetty/image013.jpg" alt="Connect process"></li>
</ol>
</blockquote>
<p>Accptor对每个请求创建ConnectorEndPoint，后者对实际消息做出具体解析并应答。Jetty9 移除了BIO的Connecter（现在是异步的世界了…）<br>如果工作在AJP协议下，与 HTTP 方式唯一不同的地方的就是将 SocketConnector 类替换成了 Ajp13SocketConnector，即监听的协议不同而已。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO是非阻塞的，类似于linux中的<code>select</code>系统接口：</p>
<ol>
<li>创建N个<code>Acceptor</code>对象，每个对应一个<code>SelectSet</code>对象，用于存放已注册的socket集合；</li>
<li>创建N个<code>Selector</code>线程用于轮询<code>SelectSet</code>(<code>select</code>)或监听<code>SelectSet</code>中的事件(<code>epoll</code>)，线程数同<code>Acceptor</code>的个数(<code>jetty.xml</code>中指定）；</li>
<li><code>Connector</code>接受(<code>accept</code>)到请求，得到<code>Socket</code>，将之设为非阻塞，然后以轮询机制分发给<code>Acceptor</code>并返回（异步)；</li>
<li><code>Acceptor</code>将之放入自己的<code>SelectSet</code>，并返回；</li>
<li><code>Selector</code>检测到新的<code>Socket</code>，开始监听该<code>Socket</code>的<code>read</code>事件（<code>select</code>）；</li>
<li>一旦有新事件到来，立刻新建<code>ConnectorEndPoint</code>，调用<code>schedule</code>方法并返回继续监听该<code>Socket</code>（异步）；</li>
<li><code>schedule</code>方法调用线程池中的线程，进行实际的逻辑处理(<code>worker</code>)，该线程会调用<code>Server</code>的<code>handle</code>方法，这里形成<code>handle</code>的调用链（这是在server启动前注册到server中的）。</li>
</ol>
<p>NIO的一般工作原理用代码描述如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Selector selector = Selector.open();   <span class="comment">//实例化selector</span></div><div class="line">ServerSocketChannel ssc = ServerSocketChannel.open(); <span class="comment">//实例化socket</span></div><div class="line">ssc.configureBlocking( <span class="keyword">false</span> );  <span class="comment">//非阻塞</span></div><div class="line">SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT ); <span class="comment">//注册事件</span></div><div class="line">ServerSocketChannel ss = (ServerSocketChannel)key.channel();</div><div class="line">SocketChannel sc = ss.accept();</div><div class="line">sc.configureBlocking( <span class="keyword">false</span> );</div><div class="line">SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );</div><div class="line">Set selectedKeys = selector.selectedKeys();</div></pre></td></tr></table></figure></p>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>java7开始支持AIO，而jetty则从jetty9开始支持这一特性。AIO在linux上使用<code>epoll</code>完成，在windows上则使用IOCP（IO完成端口）完成。</p>
<p>一般而言，AIO对应<code>Proactor</code>模式，NIO对应<code>Reactor</code>模式，两者最大的区别在于IO是由谁来完成：AIO中，由内核完成IO，然后将结果通知给用户（信号/回调函数）；NIO中，内核只是将准备好进行IO的描述符通知给用户（信号/回调函数），然后由用户自己处理IO。</p>
<hr>
<p>需要了解的预备知识到此结束，下一篇开始正式分析CometD源码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;jetty生命周期&quot;&gt;&lt;a href=&quot;#jetty生命周期&quot; class=&quot;headerlink&quot; title=&quot;jetty生命周期&quot;&gt;&lt;/a&gt;jetty生命周期&lt;/h2&gt;&lt;p&gt;Jetty的核心组件是&lt;code&gt;Server&lt;/code&gt;和&lt;code&gt;Conne
    
    </summary>
    
    
      <category term="cometd" scheme="http://YiuTerran.github.io/tags/cometd/"/>
    
      <category term="jetty" scheme="http://YiuTerran.github.io/tags/jetty/"/>
    
      <category term="java" scheme="http://YiuTerran.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CometD源码学习[1]</title>
    <link href="http://YiuTerran.github.io/2017/06/12/CometD%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0_2/"/>
    <id>http://YiuTerran.github.io/2017/06/12/CometD源码学习_2/</id>
    <published>2017-06-12T15:47:20.000Z</published>
    <updated>2017-06-12T16:24:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先学习server部分，主要包括<code>cometd-java-server</code>这个package，同时涉及到<code>cometd-java-common</code>和<code>bayeux-api</code>这两个package。</p>
<h2 id="org-cometd-server-CometDServlet"><a href="#org-cometd-server-CometDServlet" class="headerlink" title="org.cometd.server.CometDServlet"></a>org.cometd.server.CometDServlet</h2><p>在web.xml中，服务的配置顺序一般是<code>CometDServlet</code>，<code>oort</code>，<code>seti</code>和用户自定义应用的<code>Servlet</code>，我们也按这个顺序来看。显然，这个类主要用于Long-Polling模式。<br><code>init</code>中主要就是新建（如果未导出）并启动一个bayeuxServer;<br><code>service</code>中，”OPTION”请求，用于允许CORS访问，直接返回200；否则转发给transport；<br><code>destroy</code>用于生命周期中stop过程调用，依次cancelSchedule, stop bayeuxServer, remove导出的bayeuxServer.</p>
<h2 id="org-cometd-server-BayeuxServer"><a href="#org-cometd-server-BayeuxServer" class="headerlink" title="org.cometd.server.BayeuxServer"></a>org.cometd.server.BayeuxServer</h2><p>这个接口规定了bayeux服务器需要实现的接口。值得关注的地方：</p>
<ol>
<li>可监听事件：<br> a. ChannelListener用于监听add/remove Channel的事件；<br> b. SessionListener用于监听add/remove Session的事件，这个比较重要。可以通过Session建立事件来给client push 欢迎消息，通过Session removed事件来确认client断开连接。<br> c. SubscriptionListener用于监听订阅事件；</li>
<li>extension接口:<br> extension本质是一个消息钩子，可以在rcv之初/send之末对消息做一些修改（主要是操作bayeux协议的<code>ext</code>字段），所以参数中ServerMessage都是Mutable的.这里normal message和meta message被区分开来。</li>
</ol>
<h2 id="org-cometd-server-BayeuxServerImpl"><a href="#org-cometd-server-BayeuxServerImpl" class="headerlink" title="org.cometd.server.BayeuxServerImpl"></a>org.cometd.server.BayeuxServerImpl</h2><p>顾名思义，bayeuxServer的实现类。<br><code>VALID</code>用了一个技巧，即字符本质上是一个short的ASCII码；<br><code>System.identityHashCode</code>用于获取对象的原始hashcode码；<br><code>SecureRandom</code>是一个强加密的随机数类；<br><code>listeners</code>, <code>extension</code>都被存放在线程安全的<code>CopyOnWriteArrayList</code>里面；<br>client_id与<code>ServerSessionImpl</code>、channel_name与<code>ServerChannelImpl</code>的映射也被存放在线程安全的<code>ConcurrentHashMap</code>里面；<br>Server支持的transport被存入<code>LinkedHashMap</code>里面，因为transport的顺序很重要，优先使用迭代中最前的，不可行时才使用后续者；<br><code>currentTransport</code>是一个<code>ThreadLocal</code>变量，因为每个线程（连接）当前的Transport肯定不一样。</p>
<p>_scheduler是一个周期性定时器，此外是一个policy、一个JSON的server，这三个变量。</p>
<h3 id="dostart"><a href="#dostart" class="headerlink" title="dostart"></a>dostart</h3><ol>
<li>首先初始化Meta Channel：创建Channel并增加相关的Listener；</li>
<li>初始化JSON服务器，这里有一个缺省的实现（<code>JettyJSONContextServer</code>），但是用户也可以通过option自定义一个实现类（通过反射，使用<code>isAssignableFrom</code>判断是否是<code>JSONContext.Server</code>的子类）；</li>
<li>初始化transport.如果没有设置，初始化为websocket接口，否则依序初始化配置文件中指定的端口并添加到容器中；如果<code>allowedTransports</code>没有设置，默认允许所有transport，否则依序初始化配置文件中允许的且存在于transport列表中的transport；上述所有数据都被添加到公用的容器中了。</li>
<li>启动_scheduler，执行周期性扫除(sweep)任务（每次计时任务结束后需要手动再启动定时任务），该任务会扫描所有Channel和端口以及session，扫描周期默认是997ms，可以自己设置。<br>session扫描即服务端超时机制，如果now&gt;一定时间间隔，则从服务端移除session；Channel扫描就是检测Channel的订阅数量，如果没有活动的（即已握手的session的）订阅，那么就从BayeuxServer中清除（除非设置为<code>persistent</code>）；</li>
<li>最后是2.9新增的<code>validateMessageFields</code>用于校验消息格式。</li>
</ol>
<h3 id="createChannelIfAbsent"><a href="#createChannelIfAbsent" class="headerlink" title="createChannelIfAbsent"></a>createChannelIfAbsent</h3><p>创建通道，传入channel名和初始化器。<br>如果Channel name尚不存在：</p>
<ol>
<li>根据channel name创建<code>ChannelId</code>，然后创建一个新的<code>ServerChannelImpl</code>，后者是一个<code>ServerChannel</code>接口的实现类。注意在<code>ServerChannelImpl</code>的构造函数中，如果非broadcast channel，会被设置为persistent的；</li>
<li>存放channel，会再次检测channel是不是已经存在（多线程检测），确认无误后，开始配置channel；使用传入的<code>initializers</code>和已注册的<code>listener</code>配置channel；</li>
<li>初始化完毕，触发ChannelListener的Channel added事件；<br>如果Channel name已存在：<br>什么都不做，简单的给将channel的存活评估值（_sweeperPasses)重置。会再次check channel（<code>putIfAbsent</code>）是不是已存在于容器中。</li>
</ol>
<h2 id="PushServlet"><a href="#PushServlet" class="headerlink" title="PushServlet"></a>PushServlet</h2><p>先跳过Oort和Seti，直接看PushServlet（我们的应用程序）。<br>由于在CometDServlet里面已经导出了<code>bayeuxServer</code>，这里可以通过<code>getServletContext()</code>直接拿到Server了.<br>现在可以创建<code>SecurityPolicy</code>和<code>PushService</code>了。</p>
<h2 id="AbstractService"><a href="#AbstractService" class="headerlink" title="AbstractService"></a>AbstractService</h2><p>顾名思义，这个类是<code>abstract</code>的，注意构造函数里面会先create一个<code>LocalSession</code>，然后自己和自己握手。这个LocalSession本子上是用于服务端主动publish消息的.<br><strong>初始化的时候可以指定线程池的大小，否则使用同步访问。</strong>显然，如果不使用线程池，那么在处理消息时如果有费时间的操作，必须新建线程。<br>这里用了一个技术，使用反射技术查看自己所处的类的<code>Modifier</code>是不是<code>public</code>的。</p>
<h3 id="addService"><a href="#addService" class="headerlink" title="addService"></a>addService</h3><p>创建Channel后，正常流程走到这里。传入channel name和callback func name，利用反射技术进行映射。<br><code>getClass</code>拿到类，然后从当前开始逐层向上遍历直到<code>AbstractService</code>，执行以下操作：<br><code>getDeclaredMethods</code>拿到方法集合，遍历方法集合，判定名称相等且有<code>public</code>描述符，那么找到候选<code>Method</code>。<br>候选<code>Method</code>的参数必须符合固定的签名类型，这里用<code>isAssignableFrom</code>配合<code>getParameterTypes()</code>来进行判断；<br><strong>注意</strong>：这里会主动调用<code>createChannelIfAbsent</code>创建服务（这里就没机会做配置了）；</p>
<p>创建一个<code>Invoker</code>，在并行队列里放入<code>messageName</code>和<code>Invoker</code>的映射。<br>该<code>Invoker</code>被增加为Channel的Listener.</p>
<h3 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h3><p>所有消息首先经过该函数进行分发。<br>首先验证消息，创建回复并关联。调用接受的extension对消息进行扩展；从消息中取出channel，对消息进行认证(<code>Authorizer</code>)；然后依据是否是Meta消息进行不同的分发，无论是接受消息还是发送消息，最终都是调用了<code>doPublish</code>方法。</p>
<h2 id="AbstractService-Invoker"><a href="#AbstractService-Invoker" class="headerlink" title="AbstractService.Invoker"></a>AbstractService.Invoker</h2><p><code>ServerChannel.MessageListener</code>接口的实现类。</p>
<h3 id="OnMessage"><a href="#OnMessage" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>消息的观察者。<br>Server可以通过<code>isSeeOwnPublish</code>相关参数的配置控制是否接收自己publish的消息，然后调用(<code>invoke</code>）回到函数。如果初始化的时候传递了最大线程数，那么这里就从线程池里面拿线程然后处理消息；<strong>否则直接在当前线程里面处理消息</strong>(<code>doInvoke</code>)；<br>如果回调函数的签名中有返回值，这个值会被立刻返回(send)给client端。</p>
<p>现在再次回到<code>BayeuxServerImpl</code>类中，<code>doStart</code>会给所有的<code>Meta</code> Channel增加Listener，这是预置的Meta handler；按着Bayeux协议约定的过程，client会首先handshake。</p>
<h2 id="BayeuxServerImpl-HandshakeHandler"><a href="#BayeuxServerImpl-HandshakeHandler" class="headerlink" title="BayeuxServerImpl.HandshakeHandler"></a>BayeuxServerImpl.HandshakeHandler</h2><p>先看父类，<code>HandlerListener</code>是<code>ServerChannel.ServerChannelListener</code>的实现类。<br><code>isSessionUnknown</code>没啥好说的；<code>toChannelList</code>有个有趣的地方，可以用<code>Collections.singletonList</code>生成单元素列表），对某些需要传一个集合，但是实际上只要传一个元素的API很有用；</p>
<h3 id="OnMessage-1"><a href="#OnMessage-1" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>handshake的时候session理论上还不存在，于是新建一个<code>ServerSession</code>，并且将HTTP的相关报头转移过来（UA），然后得到关联(<code>getAssociated</code>)的消息实体（消息可能是捎带回去的）。<br>这时候先判断<code>SecurityPolicy</code>有没有设置，如果设置了，就先判断<code>canHandshake</code>是不是成立，如果不成立，就要<code>reply.setSuccessful(false)</code>，并设置错误原因。</p>
<p>这里有个问题，reply并没有传给<code>canHandshake</code>，但是<code>message</code>被传进去了。根据<code>ServerMessageImpl</code>的实现，<code>canHandshake</code>也可以用<code>message.getAssociated</code>里面拿到reply，然后增加想要的字段（ext）。代码显示，这里并没有往advice里面添加重连间隔（<code>interval</code>)字段。<br>【这里显示了nest class如何得到outer class的实例，直接用<code>BayeuxServerImpl.this</code>.】</p>
<p>一切正常，<code>ServerSession</code>首先和自己握手，增加<code>ServerSession</code>（在此处<strong>通知回调</strong>，即应用程序注册的监听Session添加的方法），定义reply中的某些字段；如果<code>canHandshake</code>返回false，则返回403（handshake denied）错误；注意：如果应用程序的监听器没有设置<code>advice</code>中的<code>reconnect</code>字段，这里默认会填入<code>none</code>。</p>
<p><code>reconnect</code>字段分为3种，正常是<code>retry</code>；<code>handshake</code>一般是402错误，要求重新握手；<code>none</code>就是禁止自动重连了。<a href="http://docs.cometd.org/reference/bayeux_message_fields.html" target="_blank" rel="external">^1</a></p>
<h2 id="BayeuxServerImpl-ConnectHandler"><a href="#BayeuxServerImpl-ConnectHandler" class="headerlink" title="BayeuxServerImpl.ConnectHandler"></a>BayeuxServerImpl.ConnectHandler</h2><p>心跳信息处理。</p>
<h3 id="OnMessage-2"><a href="#OnMessage-2" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>如果session未知，那就需要重新握手，返回402错误。否则对session进行续期，并返回advice，内容包括<code>timeout</code>和<code>interval</code>字段（如果没有设置，默认是不过期的）</p>
<h2 id="BayeuxServerImpl-SubscribeHandler"><a href="#BayeuxServerImpl-SubscribeHandler" class="headerlink" title="BayeuxServerImpl.SubscribeHandler"></a>BayeuxServerImpl.SubscribeHandler</h2><p>订阅Channel处理。</p>
<h3 id="OnMessage-3"><a href="#OnMessage-3" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>402同上。如果没有<code>subscription</code>字段或者字段不符合格式，403；如果Channel不存在，尝试创建Channel(policy的<code>canCreate</code>，以及内部Channel格式约束)，失败则403。</p>
<h2 id="BayeuxServerImpl-UnsubscribeHandler"><a href="#BayeuxServerImpl-UnsubscribeHandler" class="headerlink" title="BayeuxServerImpl.UnsubscribeHandler"></a>BayeuxServerImpl.UnsubscribeHandler</h2><p>退订处理。</p>
<h3 id="OnMessage-4"><a href="#OnMessage-4" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>退订只要session存在，消息格式正确，没有理由不让你退XD</p>
<h2 id="BayeuxServerImpl-DisconnectHandler"><a href="#BayeuxServerImpl-DisconnectHandler" class="headerlink" title="BayeuxServerImpl.DisconnectHandler"></a>BayeuxServerImpl.DisconnectHandler</h2><p>断开连接处理。</p>
<h3 id="OnMessage-5"><a href="#OnMessage-5" class="headerlink" title="OnMessage"></a>OnMessage</h3><p>session存在即可断开。<br>会激活移除session的回调（timeout=false）<br>刷新session=&gt;</p>
<h2 id="ServerSessionImpl"><a href="#ServerSessionImpl" class="headerlink" title="ServerSessionImpl"></a>ServerSessionImpl</h2><h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>刷新session会取消上一次的lazyTask；</p>
<h3 id="LazyTask"><a href="#LazyTask" class="headerlink" title="LazyTask"></a>LazyTask</h3><p><code>Runnable</code>子类，其<code>scheduler</code>方法最终调用<code>BayeuxServerImpl</code>中的同名方法，作为一个计划任务执行（<code>Scheduler</code>是jetty的基础工具类）。</p>
<h3 id="Setxxx"><a href="#Setxxx" class="headerlink" title="Setxxx"></a>Setxxx</h3><p>可以设置的包括：<br>Interval<br>timeout</p>
<h3 id="ServerSessionListener"><a href="#ServerSessionListener" class="headerlink" title="ServerSessionListener"></a>ServerSessionListener</h3><p>可以监听的事件包括：<br><code>RemoveListener</code>=&gt;移除Session时通知<br><code>MessageListener</code>=&gt;有消息时通知<br><code>QueueListener</code>=&gt;消息被加入队列时通知<br><code>DeQueueListener</code>=&gt;消息出列时通知<br><code>MaxQueueListener</code>=&gt;队列满时通知</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先学习server部分，主要包括&lt;code&gt;cometd-java-server&lt;/code&gt;这个package，同时涉及到&lt;code&gt;cometd-java-common&lt;/code&gt;和&lt;code&gt;bayeux-api&lt;/code&gt;这两个package。&lt;/p&gt;
&lt;h2
    
    </summary>
    
    
      <category term="cometd" scheme="http://YiuTerran.github.io/tags/cometd/"/>
    
      <category term="jetty" scheme="http://YiuTerran.github.io/tags/jetty/"/>
    
      <category term="java" scheme="http://YiuTerran.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>cmake实践</title>
    <link href="http://YiuTerran.github.io/2017/06/12/cmake%E5%AE%9E%E8%B7%B5/"/>
    <id>http://YiuTerran.github.io/2017/06/12/cmake实践/</id>
    <published>2017-06-12T15:47:11.000Z</published>
    <updated>2017-06-12T16:22:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>heka使用了cmake进行构建，cmake是目前最好的大型项目构建工具（比autoconf之类的都要好），有很强的学习价值。另外JetBrain的CLion也是用cmake进行构建的。</p>
<p>初级学习材料是<a href="http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf" target="_blank" rel="external">CMake Practice</a>这本书.</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">PROJECT</span>(HELLO)</div><div class="line"><span class="keyword">SET</span>(SRC_LIST main.c)</div><div class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">"This is BINARY dir"</span> <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</div><div class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">"This is SOURCE dir"</span> <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</div><div class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello <span class="variable">$&#123;SRC_LIST&#125;</span>)</div></pre></td></tr></table></figure>
<p>上面是一个最简单的CMakeLists.txt示例，也很容易理解。使用<code>SET</code>命令设置变量，使用<code>MESSAGE</code>命令显示信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] &quot;message to display&quot;)</div></pre></td></tr></table></figure></p>
<p>使用空格键分割参数。</p>
<p><code>ADD_EXECUTABLE</code>添加生成的可执行文件，第一个参数是可执行文件的名字（与项目没什么关系）。</p>
<p>一般情况下，使用<code>${}</code>引用变量，但是如果在<code>IF</code>中，则默认就是一个变量名，这时候就不要再解引用了。</p>
<p>指令是大小写无关的，参数和变量是大小写敏感的，但是一般情况下推荐使用全大写的指令。</p>
<p>由于参数使用空格做分隔符，因此若某些参数中间含有空格（如文件名），则需要用引号包围。另外就是文件后缀可以省略，如果确定不会重复的话（推荐保留）。</p>
<p>另外就是参数也可以用分号分割，注意前后保持一致就行。</p>
<h3 id="外部构建"><a href="#外部构建" class="headerlink" title="外部构建"></a>外部构建</h3><p>上面的例子是内部构建，生成了一大堆中间文件，cmake官方更推荐使用外部构建。</p>
<p>删除除了<code>CMakeLists.txt</code>和<code>main.c</code>之外的所有文件，建立一个<code>build</code>目录。然后运行<code>cmake &lt;项目路径&gt;</code>，构建的中间文件和输出的MakeFile都会出现在这个目录里，对原来的项目没有影响。唯一不同的是<code>PROJECT_BINARY_DIR</code>指向<code>build</code>目录了。</p>
<h3 id="进一步复杂化"><a href="#进一步复杂化" class="headerlink" title="进一步复杂化"></a>进一步复杂化</h3><p>添加<code>src</code>子文件夹，将<code>main.c</code>移入。然后在其中再新建一个<code>CMakeLists.txt</code>。外部改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PROJECT(HELLO)</div><div class="line">ADD_SUBDIRECTORY(src bin)</div></pre></td></tr></table></figure></p>
<p>内部的写入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ADD_EXECUTABLE(hello main.c)</div></pre></td></tr></table></figure></p>
<p>再在<code>build</code>文件夹下cmake，就可以<code>build/bin/</code>文件夹下生成科执行文件。</p>
<p>可以通过修改<code>EXECUTABLE_OUTPUT_PATH</code>和<code>LIBRARY_OUTPUT_PATH</code>来修改最终输出的可执行文件或者链接库的路径。一般写在<code>ADD_EXECUTABLE</code>后面。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装使用<code>cmake -DCMAKE_INSTALL_PREFIX=&lt;dir&gt;</code>来指定安装目录。在根目录的<code>CmakeLists.txt</code>里面写入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/t2)</div><div class="line">INSTALL(PROGRAMS runhello.sh DESTINATION bin)</div><div class="line">INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake/t2)</div></pre></td></tr></table></figure>
<p>这里用了<code>INSTALL</code>指令，第一个参数表示写入文件类型，<code>DESTINATION</code>后面是写入的目标位置。</p>
<p>INSTALL指令参数较多，使用时可以参考文档。</p>
<h3 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h3><p>除了目录名外，与构建可执行文件的主要区别是lib文件夹中的CMakeLists.txt中加入了命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">SET(LIBHELLO_SRC hello.c)</div><div class="line">ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)</div><div class="line">ADD_LIBRARY(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</div><div class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES OUT_NAME &quot;hello&quot;)</div><div class="line">SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUPUT 1)</div><div class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUPUT 1)</div><div class="line">SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</div><div class="line">INSTALL(TARGETS hello hello_static</div><div class="line">        LIBRARY DESTINATION lib</div><div class="line">        ARCHIVE DESTINATION lib)</div><div class="line">INSTALL(FILES hello.h DESTINATION include/hello)</div></pre></td></tr></table></figure></p>
<p><code>ADD_LIBRARY</code>第二个参数指出了库的类型，可以用<code>STATIC</code>参数构建静态库，<code>SHARD</code>构建动态库。</p>
<p>由于<code>ADD_LIBRARY</code>第一个参数不能重复，所以同时生成静态库需要 <code>SET_TARGET_PROPERTIES</code>. 该命令用来设置很多目标属性，包括版本信息等。这里设置了防止同名删除库，以及版本信息。</p>
<h3 id="使用外部共享库"><a href="#使用外部共享库" class="headerlink" title="使用外部共享库"></a>使用外部共享库</h3><p>如果依赖外部库，且该库并不存在于系统搜索路径里， 需要使用<code>INCLUDE_DIRECTORIES</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)</div></pre></td></tr></table></figure>
<p>仅仅是这样还不够，上面只是指出了头文件的位置。链接库的位置需要使用<code>LINK_DIRECTORIES</code>或<code>TARGET_LINK_DIRECTORIES</code>。假设上面我们已经把库安装到<code>/usr</code>文件下，在<code>CMakeLists.txt</code>中加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INCLUDE_DIRECTORIES(/usr/include/hello)</div><div class="line">TARGET_LINK_LIBRARIES(main libhello.so)</div></pre></td></tr></table></figure></p>
<p>即可正常编译链接通过了。</p>
<p>也可使用<code>CMAKE_INCLUDE_PATH</code>和<code>CMAKE_LIBRARY_PATH</code>这两个特殊的环境变量为编译添加额外搜索路径。比如上面我们也可以先在bash里面<code>export CMAKE_INCLUDE_PATH=/usr/include/hello</code>，然后将上面的<code>INCLUDE_DIRECTORIES</code>变为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FIND_PATH(myHeader hello.h)</div><div class="line">IF(myHeader)</div><div class="line">INCLUDE_DIRECTORIES($&#123;myHeader&#125;)</div><div class="line">ENDIF(myHeader)</div></pre></td></tr></table></figure></p>
<h3 id="常用变量-环境变量"><a href="#常用变量-环境变量" class="headerlink" title="常用变量/环境变量"></a>常用变量/环境变量</h3><p>使用<code>SET</code>定义的是显式定义，除此之外，一些指令可以定义隐式变量。当然还有一些内置变量。</p>
<p>使用<code>$ENV{NAME}</code>来调用环境变量，设置环境变量则是<code>SET(ENV{变量名} 值)</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;heka使用了cmake进行构建，cmake是目前最好的大型项目构建工具（比autoconf之类的都要好），有很强的学习价值。另外JetBrain的CLion也是用cmake进行构建的。&lt;/p&gt;
&lt;p&gt;初级学习材料是&lt;a href=&quot;http://sewm.pku.edu.
    
    </summary>
    
    
      <category term="cmake" scheme="http://YiuTerran.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>python celery组件使用</title>
    <link href="http://YiuTerran.github.io/2017/06/12/python%20celery%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://YiuTerran.github.io/2017/06/12/python celery组件使用/</id>
    <published>2017-06-12T15:47:06.000Z</published>
    <updated>2017-06-12T16:28:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h2><p>install:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install celery</div></pre></td></tr></table></figure></p>
<p>选择broker，安装，这里假设使用Redis：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install redis-server</div></pre></td></tr></table></figure></p>
<h2 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h2><p>首先认真阅读<a href="http://docs.celeryproject.org/en/latest/index.html" target="_blank" rel="external">官方celery文档</a>的get start部分，如果有时间的话，最好全部看一边…</p>
<p>然后参考阅读别人的<a href="http://blog.csdn.net/orangleliu/article/details/37967433" target="_blank" rel="external">best practices</a>，基本就可以干活了。</p>
<h3 id="几个要点"><a href="#几个要点" class="headerlink" title="几个要点"></a>几个要点</h3><ol>
<li>task相关的文件，最好都是用绝对导入；否则，应该在task function上面指定name；</li>
<li>如果需要root权限执行，需要在相关文件中加入<code>platforms.C_FORCE_ROOT=True</code>，但是最好别用root；</li>
<li>可以根据需要消除<code>pickle</code>的警告，设置<code>CELERY_ACCEPT_CONTENT=[&#39;pickle&#39;,]</code>；</li>
<li>默认不发心跳，需要加上<code>BROKER_HEARTBEAT=10</code>，来消除心跳相关警告；<br>5.<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3>router是不支持通配符的，如果需要，可以自己写一个自定义Router类。下面是一个<code>celery.py</code>的例子：<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</div><div class="line"></div><div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery, platforms</div><div class="line"><span class="keyword">from</span> settings <span class="keyword">import</span> CELERY_BROKER</div><div class="line"><span class="keyword">from</span> kombu <span class="keyword">import</span> Queue, Exchange</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRouter</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="string">'''router for tasks using wildcard'''</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">route_for_task</span><span class="params">(self, task, *args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">if</span> task.startswith(<span class="string">'writer'</span>):</div><div class="line">            <span class="keyword">return</span> &#123;<span class="string">'queue'</span>: <span class="string">'async_writer'</span>, <span class="string">'routing_key'</span>: <span class="string">'async_writer'</span>&#125;</div><div class="line">        <span class="keyword">elif</span> task.startswith(<span class="string">'caller'</span>):</div><div class="line">            <span class="keyword">return</span> &#123;<span class="string">'queue'</span>: <span class="string">'async_caller'</span>, <span class="string">'routing_key'</span>: <span class="string">'async_caller'</span>&#125;</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> &#123;<span class="string">'queue'</span>: <span class="string">'default'</span>, <span class="string">'routing_key'</span>: <span class="string">'default'</span>&#125;</div><div class="line"></div><div class="line"></div><div class="line">QUEUES = (</div><div class="line">    Queue(<span class="string">'default'</span>, Exchange(<span class="string">'default'</span>), routing_key=<span class="string">'default'</span>),</div><div class="line">    Queue(<span class="string">'async_writer'</span>, Exchange(<span class="string">'async_writer'</span>),</div><div class="line">          routing_key=<span class="string">'async_writer'</span>),</div><div class="line">    Queue(<span class="string">'async_caller'</span>, Exchange(<span class="string">'async_caller'</span>),</div><div class="line">          routing_key=<span class="string">'async_caller'</span>),</div><div class="line">)</div><div class="line"></div><div class="line">platforms.C_FORCE_ROOT = <span class="keyword">True</span></div><div class="line"></div><div class="line">app = Celery(<span class="string">'async'</span>,</div><div class="line">             broker=CELERY_BROKER,</div><div class="line">             include=[<span class="string">'async.writer'</span>, <span class="string">'async.caller'</span>, <span class="string">'async.checker'</span>, ])</div><div class="line"></div><div class="line">app.conf.update(CELERY_ACCEPT_CONTENT=[<span class="string">'pickle'</span>, ],</div><div class="line">                CELERY_IGNORE_RESULT=<span class="keyword">True</span>,</div><div class="line">                CELERY_DISABLE_RATE_LIMITS=<span class="keyword">True</span>,</div><div class="line">                CELERY_DEFAULT_EXCHANGE=<span class="string">'default'</span>,</div><div class="line">                CELERY_DEFAULT_QUEUE=<span class="string">'default'</span>,</div><div class="line">                CELERY_DEFAULT_ROUTING_KEY=<span class="string">'default'</span>,</div><div class="line">                CELERY_DEFAULT_EXCHANGE_TYPE=<span class="string">'topic'</span>,</div><div class="line">                CELERY_TASK_SERIALIZER=<span class="string">'pickle'</span>,</div><div class="line">                CELERY_RESULT_SERIALIZER=<span class="string">'pickle'</span>,</div><div class="line">                BROKER_HEARTBEAT=<span class="number">10</span>,</div><div class="line">                CELERY_QUEUES=QUEUES,</div><div class="line">                CELERY_ROUTES=(MyRouter(),),</div><div class="line">                )</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app.start()</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>官方给出的init.d脚本不是很好用，下面是一个自己写的参考：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># PushserverCore uWSGI Web Server init script</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">### BEGIN INIT INFO</span></div><div class="line"><span class="comment"># Provides:          PushserverCore</span></div><div class="line"><span class="comment"># Required-Start:    $remote_fs $remote_fs $network $syslog</span></div><div class="line"><span class="comment"># Required-Stop:     $remote_fs $remote_fs $network $syslog</span></div><div class="line"><span class="comment"># Default-Start:     2 3 4 5</span></div><div class="line"><span class="comment"># Default-Stop:      0 1 6</span></div><div class="line"><span class="comment"># Short-Description: Start PushserverCore Service for generic init daemon</span></div><div class="line"><span class="comment"># Description:       PushserverCore Service thrift Server backend.</span></div><div class="line"><span class="comment">### END INIT INFO</span></div><div class="line"></div><div class="line">NAME=<span class="string">"Core Thrift Server"</span></div><div class="line">PROJECT=PushserverCore</div><div class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/var/app/enabled/<span class="variable">$PROJECT</span></div><div class="line">DESC=<span class="string">"PushserverCore"</span></div><div class="line">APP_DIR=/var/app/enabled/<span class="variable">$PROJECT</span>/Core</div><div class="line">APP_PATH=<span class="variable">$APP_DIR</span>/CoreServer.py</div><div class="line">CELERY_LOG_PATH=/var/app/<span class="built_in">log</span>/PushserverCore/celery.log</div><div class="line"></div><div class="line"><span class="function"><span class="title">print_succ</span></span>()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$(tput setaf 2)</span><span class="variable">$(tput bold)</span>DONE<span class="variable">$(tput sgr0)</span>"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">print_fail</span></span>()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$(tput setaf 1)</span><span class="variable">$(tput bold)</span>FAILED<span class="variable">$(tput sgr0)</span>"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">stop_service</span></span>()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">echo</span> <span class="string">"stoping <span class="variable">$NAME</span>..."</span></div><div class="line">    <span class="keyword">if</span> pgrep <span class="_">-f</span> <span class="variable">$APP_PATH</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></div><div class="line">        pkill <span class="_">-f</span> <span class="variable">$APP_PATH</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line">    print_succ</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_service</span></span>()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> pgrep <span class="_">-f</span> <span class="variable">$APP_PATH</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$NAME</span> service is already running."</span></div><div class="line">        <span class="built_in">return</span></div><div class="line">	<span class="keyword">else</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"starting <span class="variable">$NAME</span> service..."</span></div><div class="line">        nohup python <span class="variable">$APP_PATH</span> &gt;/dev/null 2&gt;&amp;1 &amp;</div><div class="line">	<span class="keyword">fi</span></div><div class="line">    sleep 3</div><div class="line">    <span class="keyword">if</span> pgrep <span class="_">-f</span> <span class="variable">$APP_PATH</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></div><div class="line">        print_succ</div><div class="line">    <span class="keyword">else</span></div><div class="line">        print_fail</div><div class="line">    <span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">stop_worker</span></span>()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">echo</span> <span class="string">"stoping celery worker..."</span></div><div class="line">    <span class="keyword">if</span> pgrep <span class="_">-f</span> celery &gt; /dev/null 2&gt;&amp;1;<span class="keyword">then</span></div><div class="line">        pkill <span class="_">-f</span> celery</div><div class="line">    <span class="keyword">fi</span></div><div class="line">    print_succ</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">start_worker</span></span>()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> pgrep <span class="_">-f</span> celery &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"celery is already running"</span></div><div class="line">        <span class="built_in">return</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"starting celery worker..."</span></div><div class="line">        celery -A async multi start writer <span class="built_in">caller</span> default  -Q:writer async_writer -Q:<span class="built_in">caller</span> async_caller -Q:default default -c 7 <span class="_">-l</span> INFO --workdir=<span class="variable">$APP_DIR</span> --logfile=<span class="variable">$CELERY_LOG_PATH</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line">    sleep 3</div><div class="line">    <span class="keyword">if</span> pgrep <span class="_">-f</span> celery &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></div><div class="line">        print_succ</div><div class="line">    <span class="keyword">else</span></div><div class="line">        print_fail</div><div class="line">    <span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">check_status</span></span>()</div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span> pgrep <span class="_">-f</span> <span class="variable">$APP_PATH</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></div><div class="line">       <span class="built_in">echo</span> <span class="string">"<span class="variable">$NAME</span> is running"</span></div><div class="line">   <span class="keyword">else</span></div><div class="line">       <span class="built_in">echo</span> <span class="string">"<span class="variable">$NAME</span> is not running"</span></div><div class="line">   <span class="keyword">fi</span></div><div class="line"></div><div class="line">   <span class="keyword">if</span> pgrep <span class="_">-f</span> celery &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></div><div class="line">       <span class="built_in">echo</span> <span class="string">"celery worker is running"</span></div><div class="line">   <span class="keyword">else</span></div><div class="line">       <span class="built_in">echo</span> <span class="string">"celery worker is not running"</span></div><div class="line">   <span class="keyword">fi</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">set</span> <span class="_">-e</span></div><div class="line"></div><div class="line">. /lib/lsb/init-functions</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line">	start)</div><div class="line">		<span class="built_in">echo</span> <span class="string">"Starting <span class="variable">$DESC</span>..."</span></div><div class="line">		start_service</div><div class="line">        start_worker</div><div class="line">		;;</div><div class="line">	stop)</div><div class="line">		<span class="built_in">echo</span> <span class="string">"Stopping <span class="variable">$DESC</span>..."</span></div><div class="line">		stop_service</div><div class="line">		stop_worker</div><div class="line">		;;</div><div class="line"></div><div class="line">	restart)</div><div class="line">		<span class="built_in">echo</span> <span class="string">"Restarting <span class="variable">$DESC</span>..."</span></div><div class="line">		stop_service</div><div class="line">		stop_worker</div><div class="line">        sleep 3</div><div class="line">		start_service</div><div class="line">        start_worker</div><div class="line">        <span class="built_in">echo</span> <span class="string">"Checking..."</span></div><div class="line">        check_status</div><div class="line">		;;</div><div class="line"></div><div class="line">	status)</div><div class="line">        check_status</div><div class="line">        ;;</div><div class="line">	*)</div><div class="line">		<span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$NAME</span> &#123;start|stop|restart|status&#125;"</span> &gt;&amp;2</div><div class="line">		<span class="built_in">exit</span> 1</div><div class="line">		;;</div><div class="line"><span class="keyword">esac</span></div><div class="line"></div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure></p>
<p>重点需要关注的是celery multi start的用法，注意start后面跟的是worker的名字（取数据的worker），也可以简单的写3，然后-Q:<em>worker_name</em> <em>queue_name</em>，最后-c是实际的worker（干活的worker）的数目，-Q是给队列指定worker。例子中的语句，意思是启动3个worker，分别命名为writer, caller和default，然后启动3个队列，名字分别是async_writer, async_caller和default，每个worker分配7个进程用来干活。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Prepare&quot;&gt;&lt;a href=&quot;#Prepare&quot; class=&quot;headerlink&quot; title=&quot;Prepare&quot;&gt;&lt;/a&gt;Prepare&lt;/h2&gt;&lt;p&gt;install:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table
    
    </summary>
    
    
      <category term="python" scheme="http://YiuTerran.github.io/tags/python/"/>
    
      <category term="celery" scheme="http://YiuTerran.github.io/tags/celery/"/>
    
      <category term="redis" scheme="http://YiuTerran.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>effective java 读书笔记</title>
    <link href="http://YiuTerran.github.io/2017/06/12/EffectiveJava/"/>
    <id>http://YiuTerran.github.io/2017/06/12/EffectiveJava/</id>
    <published>2017-06-12T15:47:02.000Z</published>
    <updated>2017-06-12T16:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><ol>
<li>用静态工厂方法代替构造器。这里的静态工厂方法不是factory mode，而是一种构造器的替代方法。本条款鼓励设计者在构建一个类时，优先考虑使用static factory method。后者有多个优势：更清晰，更简洁，在参数相同时不需要使用boolean或者enum来进行区分，可以通过register——get方法提供工厂特性（子类）。<br>不过，这种方法和普通的静态方法没有任何语法形式的区别，且静态方法不能被继承（C++中<code>virtual</code>与<code>static</code>不能共存）；</li>
<li>当构造参数非常多时，使用构建器(builder)。我们通常会使用默认构造函数，然后用<code>set</code>方法一一设置属性，如果让<code>set</code>返回<code>this</code>，就可以连续使用<code>set</code>，这就是<code>builder</code>。对于具有“具名参数”语法的语言（如python，C#）这种模式就不是很必要了，对于有<code>default value</code>（如C++）语法的语言，这种模式的使用频率也要低一些。</li>
<li>用私有构造器或枚举强化单例属性。这里给出了一个创建单例的建议：创建一个仅包含单元素的枚举类型，由于java语言特性，枚举直接免费提供了序列化、防止多次实例化等功能，因此可以简洁的解决很多问题。</li>
<li>如果一个类不可实例化，应该将其构造器私有化，这种类一般只是提供静态函数（类似C++中的函数）</li>
<li>尽量少创建新对象，而应该多复用已有对象。这条尤其对immuable的对象很重要，例如String。每次使用<code>new</code>时，对应该仔细考虑是否需要创建一个新的对象，而不是复用以前的对象。当然，对于小对象，这个不需要考虑。正如C++中的传值和传址的差别，小对象使用传值反而更好一些，可以避免许多不必要的麻烦。<br>另外，由于<code>autoboxing</code>的存在，基本类型与装箱基本类型之间会相互转化。但是需要记住，要优先使用基本类型。</li>
<li>消除过期的对象引用。这条主要针对“程序员自己管理内存/池化”的情景。在C++中，我们习惯在<code>free</code> or <code>delete</code>之后，将其置0(<code>nullptr</code>)，这样可以避免后续一些莫名其妙的Bug。java是GC机制的，因此一般不需要这么做。但是，如果自己池化了对象管理机制（例如创建某些数据结构时），就要注意这些问题了。<br>本条款给出的建议中，要注意缓存（比如建了一个全局list/map）中过期的东西记得删除。可以使用<code>WeakHashMap</code>自动管理(当内存中没有其引用对象时自动清除），或者<code>LinkedHashMap</code>的<code>removeEldestEntry</code>手动管理（每次添加新元素时）。对于更加复杂的场景，必须使用<code>java.lang.ref</code><a href="http://www.ibm.com/developerworks/cn/java/j-lo-langref/" target="_blank" rel="external">^1</a>.<br>此外，<strong>注册</strong>一个回调方法，但是没有显式取消它，会导致其不断被累积。因此在使用<code>addListener</code>创建函数对象时，请记得<code>removeListener</code>.</li>
<li>避免使用终结器(<code>finalizer</code>）。java使用GC来回收内存，因此终结器的用处不大，更重要的是，终结器的优先级很低，不能保证被及时执行，很容易造成性能bug。比较妥当的是提供显示的终结方法（如<code>close</code>），然后在<code>finally</code>中执行。注意终结方法不应该再抛出异常，而是应该捕获并打印日志。<br>但是用户可能忘记调用显示的终结方法，因此终结器还是可以充当最后的安全保证，当然，这其实是程序不得已使用的方法，应该在日志中使用警告。<br>另外需要注意的是，子类终结器必须显式调用父类的，这点和C++中的自动析构并不一样，请注意。可以考虑使用<code>finalize guard</code>来确保这一点。<h2 id="object通用方法"><a href="#object通用方法" class="headerlink" title="object通用方法"></a>object通用方法</h2></li>
<li><code>equals</code>方法。C++中，重载<code>==</code>操作符限定在同类之间， 其他的要通过类型转换来进行比较，因此存在非常复杂的显式/隐式类型转换。java中，<code>equals</code>方法的参数必须是<code>Object</code>类型，这意味着所有的对象之间都可以判断是否相等。<code>equals</code>方法的设计必须非常谨慎，要严格遵守自反性、对称性、一致性和传递性这几个特征。</li>
</ol>
<ul>
<li>自反性，意思是x=x恒成立；</li>
<li>对称性，意味着a=b，必须也要b=a. 但是由于参数是<code>Object</code>，很容易无意识的违反这点。一般判断步骤中，首先需要知道这个<code>Object</code>是不是属于这个类（使用<code>instanceof</code>）,严格认为不属于这个类的对象不可能相等（即使是value意义上的相等）。如果需要value意义上的相等，就写一个显式的类型转换方法。</li>
<li>传递性，意味着a=b, b=c则a=c成立。这条在设计类层次结构时很容易被违反。在多层类均可被实例化时，判断这些类之间的相等性往往会出现混乱。</li>
<li>一致性。即相等的永远都相等，不等的永远都不等。这里注意的是判断时不要依赖不可靠的资源；</li>
<li>非空性。这是额外的一个特性，任何对象在任何情况下都不应该与<code>null</code>相等——这是显然的。但是这一步不需要特别写出来，<code>instanceof</code>会替我们做这些的。<br>除了上面的款项以外，还有一些使用技巧：</li>
<li>如果比较流程复杂，可以先用<code>==</code>判断是否是同一个对象；</li>
<li>在比较时注意npt异常；</li>
<li>短路求值与比较顺序；</li>
<li>覆盖<code>hashcode</code>;</li>
</ul>
<ol>
<li><code>hashcode</code>方法。如果覆盖了<code>equals</code>，<strong>必须</strong>同时覆盖<code>hashcode</code>，这是因为相等的对象必须有相同的hash code. 这意味着我们必须为这个类提供一种hash算法，这个活并不简单，不过一般情况下可以这么做：<ol>
<li>选一个非0常数记为result，比如17；</li>
<li>对于<code>equals</code>中涉及的每一个域f(成员变量)，计算其hashcode：<ul>
<li>boolean -&gt; 1 or 0</li>
<li>byte, short, int -&gt; int(f)</li>
<li>long -&gt; int(f^(f&gt;&gt;32))</li>
<li>float -&gt; Float.floatToIntBits(f)</li>
<li>double -&gt; Double.doubleToLongBits(f) -&gt; 按着long计算</li>
<li>对象引用：null -&gt; 0，其他：递归调用hashcode方法</li>
<li>数组：把每个对象当作一个单独的域计算hashcode</li>
</ul>
</li>
<li>result=$31 * result + \Sigma_{i=1}^{\propto}f_i$<br>如果一个域的结果可以通过其他域计算出来，可以不必参与上面的计算过程。<br>如果hash计算非常复杂，可以考虑使用延迟初始化技术。定义一个<code>volatile int hashcode</code>，在对应的method里，先<code>if(hashcode==0)</code>，否则直接返回缓存的结果。</li>
</ol>
</li>
<li><code>toString</code>方法。同C#一样，一般推荐覆盖这个方法，这样<code>print</code>时，会方便很多。</li>
<li><code>clone</code>方法。很遗憾，java的<code>clone</code>不好用——很不好用，它的约定太弱。即使类implement了<code>Cloneable</code>接口，你也不能指望什么。最好的方法是别管这个东西，自己实现一个拷贝构造器，或者拷贝工厂。</li>
<li>考虑实现<code>Comparable</code>接口。这个接口唯一声明了<code>compareTo</code>方法，这是一个泛型方法。如果你需要排序，最好事先这个方法——正如C++中的重载<code>&lt;</code>操作符一样，这是泛型容器排序的基础。显然<code>compareTo</code>需要和<code>equals</code>在判断相等时保持一致。<br>比<code>equals</code>简单的是，<code>compareTo</code>的参数只能和自身类型一样，因为在implements泛型类时，填入的具体参数显然就是这个类自身。<h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2></li>
<li>使类和成员的可访问性最小化。本条和语言无关，所有面向对象设计中，<strong>信息隐藏</strong>的重要性都是一致的。切记尽量少暴露实现细节，保持对外开放性最小。这可以有效减少软件工程的复杂度。<br>有个细节的技巧：数组不可能是public final的， 因为数组本身是可变的。C++中有个蛋疼的<code>const int* const p</code>的问题，指的就是指针的可变性和内容的可变性问题。<br>此外，java默认访问类型是<code>package private</code>的，这和其他语言有区别。</li>
<li>使用<code>getter</code>,<code>setter</code>代替公有成员变量。这条其实并不是那么严格，至少C++中经常可以看到反例。因为写起来实在太麻烦，所以C#引入了属性这种语法糖。</li>
<li><p>设计不可变类。省事起见，如果对性能没有特别大的需求尽量设计不可变类，这种类的所有方法都会返回一个<code>new</code>对象，而不是直接修改对象本身。这种类的设计遵从如下原则：</p>
<ol>
<li>不提供mutator修改对象本身；</li>
<li>保证类不会被继承；</li>
<li>所有域都是不可变的（final）；</li>
<li>所有域都是私有的；</li>
<li>确保对于任何可变组件的互斥访问；</li>
</ol>
</li>
<li><p>复合优先于继承。这条是面向对象的泛用条款，从略；</p>
</li>
<li>要么为继承而设计，要么禁止继承。这条要求在设计一个类时，要明确它是否会被继承。这里强调了一个细节：构造器不可调用可被覆盖的方法。这和C++中<strong>构造函数和析构函数不应该调用虚函数</strong>本质上是一直的，因为对象是从基类到派生类逐级构造的，如果调用虚函数，动态绑定可能不会生效，从而产生undefined的后果；</li>
<li>接口优先于抽象类。显然，也是泛用条款。对于C++而言，没那么明显（因为没有接口），不过全是纯虚函数的类就是接口…</li>
<li>接口只用于定义类型。是的，只应该有public的method，而不要塞进去一堆常量。后者最好用枚举代替。</li>
<li>类层次优先于标签类。标签类就是在构造函数中传入flag，在方法中<code>switch...case</code>，在C语言中，这是常见的设计。但是在面向对象中，显然更适合使用继承来合理安排类结构。</li>
<li>用函数对象表示策略。由于C++11有了<code>std::function&lt;&gt;</code>和<code>lambda</code>，所以函数对象这种累赘的东西一般是用不上了，但是垂垂老矣的java中，还没有这些东西(java8引入lambda了，谢天谢地），一般是写一个接口，然后用匿名函数实现它。</li>
<li>优先考虑静态成员类。nested class最好设计成静态的，这是为了减少对象的数量——非静态类都必须与一个外围实例关联。nested class可以摆脱友元这种东西的困扰，访问所有的成员方法|变量（某种形式的闭包）。但是静态成员类和对象本身无关，所以就只能访问静态方法和静态成员了。</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在C++中，template和oo完全是两种不同的范式，因为C++并没有<code>all is object</code>这种思想，因此没人会觉得<code>vector&lt;basic_string&gt;</code>不是<code>vector&lt;string&gt;</code>的父类有啥问题。java其实也一样，<code>list&lt;string&gt;</code>和<code>list&lt;object&gt;</code>之间也不是继承的关系。泛型使java复杂化，并且失去了优雅。</p>
<ol>
<li>用泛型，不用原生态类型。java从1.5版本引入泛型，c#从1.2开始，C++则一直都有模板这种东西。没有泛型的语言一般都会引入一些很丑陋的类型转换，比如C中的<code>void *</code>。尽量使用泛型而非原生态的类型，如果需要指代任意类型而不关心具体类型，可以用<code>?</code>比如<code>set&lt;?&gt;</code>；此外，<code>instanceof</code>操作符后面必须跟着原生态类型；</li>
<li>消除<code>unchecked warning</code>，对于编译器的抱怨，要好好检查，如果确定没有问题，就使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>关闭这个提醒，受检警告仅存在在语言层面，并非是jvm虚拟机的特性；</li>
<li>优先使用List而不是Array。在C++中，array本质上是一个指针，因此效率比<code>std::vector&lt;&gt;</code>要高上不少；java中<code>Array</code>也比<code>list&lt;&gt;</code>要快一些，但是却更推荐使用后者。<br>java的泛型在运行时其元素类型是被擦除(erase<a href="http://www.infoq.com/cn/articles/cf-java-generics" target="_blank" rel="external">^2</a>)的，这点和C++完全不同（为了历史兼容性做出的妥协）。因此<strong>数组是运行时安全但编译时不安全的，泛型则相反</strong>。最后，最好不要同时使用泛型和数组，这会让你蛋疼无比——如果真的需要泛型数组，必须同时使用强制类型转换和<code>SuppressWarnings</code>技术。</li>
<li>优先考虑泛型和泛型方法。</li>
<li>使用<code>set&lt;? extends Object&gt;</code> or <code>set&lt;? super String&gt;</code>这种技巧来完成某些动作。助记符是<strong>PECS</strong>,就是说，把这个对象当生产者使用时，用<code>extends</code>，反之，用<code>super</code>。<br>在返回的时候，仍然使用普通类型，而不是通配符。<br>本条对于类库编写者比较重要。</li>
<li>优先使用类型安全的异构容器。本条通过一些奇技淫巧完成一个容器里面同时存放多种类型(异构，通过<code>class&lt;?&gt;</code>实现)，但是又能保证类型安全(通过<code>type.cast</code>实现)这一目标。</li>
</ol>
<p>##枚举与注解<br>java的枚举有点难用，不如C#那么强大，也不如C/C++那么简洁。简单来说，每一个枚举值都是该类（枚举）的一个实例，相当于一种工厂方法，因此枚举对象可以直接调用枚举类的方法。</p>
<ol>
<li>枚举的所有域都应该是私有final的（需要的时候提供公有的访问函数）；可以通过<code>values</code>方法访问所有的枚举值（依照声明顺序）。对于每一个枚举值在后面加上<code>{}</code>，里面是<strong>特定于常量的方法实现</strong>，可以通过在枚举类中声明一个抽象方法，在常量中再进行覆盖来实现对不同枚举值的特殊操作（<code>switch(this)</code>这种方法更适用于控制外部传入的不可控的变量的方法中）。<br>如果在枚举值后面加上初始化表达式，调用该常量时会自动使用该表达式调用构造函数（但是显然我们不能直接调用构造器），比如<code>MONDAY(&quot;mon&quot;)</code>这种.<br>PS: 这里给了一个有趣的技巧：使用<code>%n</code>保证换行符的跨平台性，有些类似python中的<code>os.linesep</code>.</li>
<li>如果不给枚举赋值，默认使用序列（0，1，2…），可以使用<code>ordinal</code>方法取得该序列的int值。当然，最好别依赖于这种自动生成的东西，而是明确赋值…</li>
<li>用<code>EnumSet</code>代替位域，主要使用<code>EnumSet.of</code>创建枚举set，用来取代依靠位运算得出的集合特性。不过，这种方法只是可读性好一些，如果需要做存储或者与提供API，还是希望使用int。</li>
<li>用<code>EnumMap</code>代替序数索引。可以将一个<code>enum</code>直接传入<code>EnumMap&lt;enum,Object&gt;</code>中，<code>enum</code>的所有常量值都会转化为<code>EnumMap</code>的<code>key</code>，这其实就是普通的<code>map</code>，但是做了优化。</li>
<li>枚举不是可扩展的，但是我们可以使用接口来变相实现这种可扩展性。简单来说，就是枚举实现接口，然后在需要的时候，使用接口来声明枚举而不是相反。</li>
<li>注解优先于命名模式。注解的声明需要导入<code>java.lang.annotation.*</code>，然后使用<strong>元注解</strong>来标明该注解的属性。例如<code>@Retention</code>, <code>@Target</code>，注解类的必须是<code>@interface</code>类型。如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public @interface Test&#123;</div><div class="line">    Class&lt;? extend Exception&gt;[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>使用时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Test(&#123;IndexOutOfBoundException.class, NullPointerException.class&#125;)</div><div class="line">public static void example()&#123;</div><div class="line">//...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试时:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if(m.isAnnotationPresent(Test.class)&#123;</div><div class="line">    test++;</div><div class="line">    try&#123;</div><div class="line">        m.invoke(null);</div><div class="line">    &#125;catch(Throwable wrappedExc)&#123;</div><div class="line">        Throwable exc = wrappedExc.getCause();</div><div class="line">        Class&lt;? extends Excetption&gt;[] excTypes=</div><div class="line">            m.getAnnotation(Test.class).value();</div><div class="line">    &#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>注解并不会改变代码原本的含义（和python的装饰器完全不同），但是可以使对象经过某些工具的特殊处理（用于反射）。<br>显然一般程序员是不需要自定义注解类型的，除了某些设计工具平台的人以外。</p>
<ol>
<li>坚持使用<code>Override</code>注解。这是一种良好的变成习惯，不再赘述。</li>
<li>用标记接口定义类型。标记接口很罕见，最常见的是<code>Serializable</code>，它只是一个接口，并没有规定任意方法。换言之，这只是一个空接口。</li>
</ol>
<p>##方法</p>
<ol>
<li>检查参数的有效性。即防御性编程，对于公有方法，应该在Javadoc中使用<code>@throws</code>标明在违反约定时会抛出什么异常；对于非导出方法，设计者自己知道会传入什么参数，因此应该使用<code>assert</code>来进行错误检测。</li>
<li>必要时使用保护性拷贝。java的对象本质上都是c++中的指针或引用，因此如果对象本身是可变的，即使参数是不可变的，也可能因为某些意外导致对象被修改。比较简单的方法是使用深拷贝（值拷贝）摆脱这种引用的关系，这在C++中是比较明显的：传值还是传址的问题，但是java中如果不留意很容易忘掉这一点。</li>
<li>谨慎设计方法签名。本条款说了一些设计方法的技巧和忌讳，包括：<ul>
<li>命名要谨慎</li>
<li>尽量保持接口最小，而不是提供很多快捷方式</li>
<li>避免过长的参数列表（4个以下）</li>
<li>如果上述条款不可避免，使用builder（参见前文）</li>
<li>参数类型优先使用接口</li>
<li>flag尽量使用enum而不是boolean</li>
</ul>
</li>
<li>慎用重载。有个原则是：永远不要导出两个具有相同<strong>参数数目</strong>的重载方法。如果方法使用可变参数，那么尽量不要重载它。如果违反上述两条规定，干脆给方法起不同的名字（如同在C语言中那样）。</li>
<li>慎用可变参数。和其他语言一样，可变参数为<code>printf</code>而生，但是实际上自己需要写的并不多，大部分情况下传入一个列表或者使用泛型可以解决应用问题。可变参数本身有一定的性能约束：传入可变参数隐式创建并初始化了一个数组。</li>
<li>返回0长度的数组或集合，而不是null。这是一条设计上的经验，在非C语言环境下，返回null往往得不偿失——需要单独写语句进行分析，而不能直接迭代。如果担心性能问题，可以使用<code>Collections.emptyList()</code>等方法返回不可变的空集，如果是数组，可以自己创建一个不可变的<code>static final</code>成员变量。</li>
<li>为所有的导出API写文档注释。尤其是在替别人写类库的时候，这条非常重要。必须明确标注哪些是可能会改变的，哪些是兼容的。</li>
</ol>
<h2 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h2><ol>
<li>使局部变量的作用域最小化。这点和C++、C#一致，C语言则是习惯把所有变量声明放在最前面（因为C只有基本数据和结构，且一般更习惯使用指针），python则不需要声明。</li>
<li>for-each优先于for。同所有语言一致，C++11中引入类似语法，C#和python用<code>in</code>关键字. 但是for-each是不能修改容器本身的，因此在必须要的时候还是要使用for。</li>
<li>了解和使用类库。应该熟悉<code>java.lang</code>和<code>java.util</code>中的内容。</li>
<li>不要使用<code>float</code>和<code>double</code>进行精确计算。如果需要精确的小数计算，应该使用<code>BigDecimal</code>，或者自己处理小数点，用<code>int</code>或<code>long</code>。</li>
<li>基本类型优先于装箱类型。由于装箱类型表示对象，因此用<code>==</code>判断两者之间的相等性总是错误的。当混合两者运算时，装箱类型就会自动拆箱。尽可能使用基本类型以避免不停的装箱、拆箱造成的性能损失。在如下场合必须使用装箱类型：<ul>
<li>集合的key和value；</li>
<li>泛型的参数；</li>
<li>进行反射方法调用时；</li>
</ul>
</li>
<li>如果其他类型更适合，不要使用字符串。例如，不要用”True”来代替<code>true</code>这种。</li>
<li>字符串连接问题。使用<code>StringBuilder</code>代替<code>String</code>，提高性能。</li>
<li>通过接口引用对象。这样更加灵活，但是必要的时候你可能需要进行类型转换。如果是基于类的框架，则使用基类更加合适。</li>
<li>接口优先于反射。反射的性能实际上是很差的，但是在必要的时候会非常有用。其中<code>Class a=Class.forname(&quot;xxx&quot;)</code>，然后使用<code>a.newInstance()</code>这种方法比较常见。</li>
<li>谨慎的使用native method. JNI允许java调用C/C++来访问特定的基于平台的sdk接口。但是，如果仅仅为了提高性能，并不提倡非要使用这种技术。</li>
<li>谨慎优化。写出好的程序，如果存在性能问题，则使用性能分析工具去分析它，再针对瓶颈进行优化。</li>
<li>遵守命名习惯。java的命名习惯和C#基本一致（而python和C++基本一致），java不喜欢下划线，而C++不喜欢驼峰。当然，一般常量还是都用全大写中间用下划线的表示方式。</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>java的异常分为<code>checked</code>和<code>unchecked</code>两类，后者是<code>RuntimeExcception</code>或者<code>Error</code>的子类，如果程序抛出这种异常，可以不加以捕获而编译通过。<br>通常情况下，应该使用标准异常。且，只在真正的异常情况下使用异常。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ol>
<li><code>synchronized</code>和<code>volatile</code>关键字的使用。前者类似C#中的<code>lock</code>，后者意思同C。C语言中虽然没有线程，但是有中断和信号。</li>
<li>避免过度同步。如果需要并发集合，那就使用语言内置的并发集合，而不要自己使用<code>synchronized</code>关键字加锁。<code>CopyOnWriteArrayList</code>是一种写时复制的并发容器，类似<code>ConcurrentArrayList</code>。如果类库使用者可以外部同步，那么设计类的时候就不要设计成内部同步的（这是C++的设计原则之一——效率最高）。如果修改了静态域，由于外部用户无法自己加锁，因此类的内部必须加锁。尽量不要从同步区域内部调用外来方法。</li>
<li><code>executor</code>和<code>task</code>优先于线程。这点类似于C#，尽量不要使用抽象程度较低的线程，而是更加漂亮简洁的其他高级类。在<code>java.lang.concurrent</code>里包含了已经封装好的比较通用的线程模型，尽量使用它们而不是自己去写。</li>
<li>并发工具优先于<code>wait</code>和<code>notify</code>。类似上一条，优先使用高级工具。</li>
<li>慎用延迟初始化。本条目给出了几个好的建议：<ol>
<li>正常初始化优先于延迟初始化；</li>
<li>使用同步方法；</li>
<li>如果需要性能优化，静态域延迟初始化使用一个static class作为holder，这样在第一次访问这个静态类时，所需要的域才会被初始化；</li>
<li>如果需要性能优化，实例域延迟初始化最好使用双重检查模式。这时候域必须被声明为<code>volatile</code>的，而且习惯上使用一个局部变量来优化对域的检查。</li>
</ol>
</li>
<li>不要使用<code>Thread.yield</code>，直接用<code>Thread.sleep(1)</code>就好。java的线程调度器不可靠，不要使用线程优先级来调度。</li>
<li>不要使用java线程组，这个技术已经过时了…</li>
</ol>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>所谓序列化，指的是将一个对象编码成字节流，一般用来持久化。</p>
<ol>
<li>谨慎实现<code>Serializable</code>接口。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建和销毁对象&quot;&gt;&lt;a href=&quot;#创建和销毁对象&quot; class=&quot;headerlink&quot; title=&quot;创建和销毁对象&quot;&gt;&lt;/a&gt;创建和销毁对象&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;用静态工厂方法代替构造器。这里的静态工厂方法不是factory mode，而是一种构造器
    
    </summary>
    
    
      <category term="java" scheme="http://YiuTerran.github.io/tags/java/"/>
    
      <category term="base" scheme="http://YiuTerran.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程实战读书笔记</title>
    <link href="http://YiuTerran.github.io/2017/06/12/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://YiuTerran.github.io/2017/06/12/java并发编程实战读书笔记/</id>
    <published>2017-06-12T15:46:57.000Z</published>
    <updated>2017-06-12T16:27:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发编程实际上极其复杂，有很多绝对值得去看的建议。</p>
<ol>
<li>不要在构造器里面调用可变函数（虚函数），这是所谓的安全构造需求；</li>
<li>最简单的线程安全类是不可变类，不可变类有如下硬性要求：<ul>
<li>对象创建以后就不能修改</li>
<li>对象所有域都是<code>final</code>的</li>
<li>对象是安全构造的</li>
</ul>
</li>
<li>所谓可见性指的是a线程修改了变量，b线程可以知道这种修改；所谓原子性指的是a线程在修改变量时，b线程不会干扰这种修改；</li>
<li>所谓安全发布，必须满足以下条件之一：<ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到<code>volatile</code>类型或者<code>AtomicReferance</code>对象之中</li>
<li>将对象的应用保存到某个正确构造对象的<code>final</code>域中</li>
<li>将对象引用保存到一个由锁保护的域中</li>
</ul>
</li>
<li><code>volatile</code>变量只能保证可见性，无法保证原子性；加锁则都可以保证（但是会繁琐一些）。</li>
<li>不要在构造器中调用新的线程，这会导致不安全发布；正确的做法是使用静态工厂函数，构造完毕后再启动线程（或者做其他发布）；</li>
<li>最简单维持线程安全的方法是使用局部变量（栈封闭），其次是使用原子类，包括现场本地存储类<code>ThreadLocal&lt;&gt;</code></li>
<li>大多数情况下，我们无须直接使用<code>Thread</code>这种基础类，java提供了很多适用范围广泛的组件，包括：</li>
<li>并发容器类，使用<code>java.util.concurrent</code>中定义的包括<code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code>，<code>ConcurrentLinkedQueue</code>和<code>BlockingQueue</code>（<code>BlockingDeque</code>),以及<code>ConcurrentSkipListMap</code>和<code>ConcurrentSkipListSet</code>（作为<code>SortedMap</code>和<code>SortedSet</code>的替代品）.<code>BlockingQueue</code>在<code>take</code>和<code>put</code>时，如果没有元素/空间就会阻塞；</li>
<li>如果线程被中断，会抛出<code>InterruptedException</code>如果是<code>Runnable</code>的对象，是不可以直接抛出这个异常的，必须捕获并使用<code>Thread.currentThread().interrupt()</code>恢复中断；其他类型的对象倒是无所谓，可以直接抛出或者捕获清理后重新抛出；</li>
<li>闭锁。<code>CountDownLatch</code>可以用来等待计数，<code>FutureTask</code>是一种<code>Callable</code>，可以通过<code>get</code>来获得结果（或者阻塞），<code>Semaphore</code>用来对资源进行限制计数，可以用来实现资源池，使用<code>acquire</code>获得一个资源，使用<code>release</code>释放一个资源，<code>Barrier</code>用来实现分段任务，当所有任务都到达Barrier时，任务继续，否则抛出<code>BrokenBarrierException</code>异常。本章给出了一个缓存的例子。</li>
<li>Executor框架。<code>Executor</code>是一个接口，只规定了<code>execute</code>一个接口（其参数是一个<code>Runnable</code> class）；<code>Executors</code>包含生产线程池的几个静态方法，如<code>newFixedThreadPool</code>（固定大小），<code>newCachedThreadPool</code>（无限增长）和<code>newSingleThreadExecutor</code>（单线程串行）,和<code>newScheduledThreadPool</code>（定时执行）。如果这些都不能满足需求，可以直接使用<code>ThreadPoolExecutor</code>自己灵活构造线程池</li>
<li><code>ExecutorService</code>接口在<code>Executor</code>接口的基础上增加了生命周期，可以使用<code>shutdown</code>，<code>shutdownNow</code>，<code>awaitTermination</code>等方法进行生命周期（运行、关闭和已终止）控制和感知。</li>
<li><code>ExecutorService</code>的<code>submit</code>方法用于提交一个任务并返回一个<code>Future</code>，使用这个结果可以控制任务的生命周期；</li>
<li>线程的超时：一般可以用重载的<code>get</code>，<code>await</code>等方法指定超时时间；</li>
<li>线程的取消：习惯上使用一个<code>volatile</code>变量作为取消标志，但是如果线程阻塞了，这个方法就不好用了。最佳方式是使用中断(<code>Future.cancel</code>)，注意需要处理好相关的异常；</li>
<li>可以通过继承<code>Thread</code>重载<code>interrupt</code>方法来将中断处理封闭在异常类中；可以通过使用<code>ThreadPoolExecutor</code>中的<code>newTaskFor</code>静态方法由<code>Callable</code>生产<code>RunnableFuture</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发编程实际上极其复杂，有很多绝对值得去看的建议。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不要在构造器里面调用可变函数（虚函数），这是所谓的安全构造需求；&lt;/li&gt;
&lt;li&gt;最简单的线程安全类是不可变类，不可变类有如下硬性要求：&lt;ul&gt;
&lt;li&gt;对象创建以后就不能修改&lt;/li&gt;
&lt;li
    
    </summary>
    
    
      <category term="java" scheme="http://YiuTerran.github.io/tags/java/"/>
    
      <category term="base" scheme="http://YiuTerran.github.io/tags/base/"/>
    
      <category term="concurrent" scheme="http://YiuTerran.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>重拾Haskell</title>
    <link href="http://YiuTerran.github.io/2017/06/12/%E9%87%8D%E6%8B%BEHaskell/"/>
    <id>http://YiuTerran.github.io/2017/06/12/重拾Haskell/</id>
    <published>2017-06-12T15:46:39.000Z</published>
    <updated>2017-06-12T16:21:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我打算学习但是最终没能完全理解的语言大概有三门：因为复杂性而放弃的Scala和Rust，因为难以理解而放弃的Haskell. 学习过C++以后，我对太过复杂的语言一项是敬而远之的，这一点暂时不会有变化，以后在工作中如果遇到必须使用Scala的时候我还是会认真学习。但是对于Haskell还是有些不甘心。虽然这是一门号称不看论文很难理解的语言，我还是想尽力学习一下。</p>
<p>Haskell相对于其他语言，变化的速度非常快，现在最新的平台是<code>stack</code>，连<code>Haskell Platform</code>也过时了（有种web前端的感觉），不过其核心理念还是比较稳定的，以前从<code>Haskell趣学指南</code>中学习的东西，现在也大多还能用。</p>
<p>在ubuntu中添加官方PPA, <code>sudo apt-get install stack</code>以后，使用<code>stack setup</code>安装环境，使用<code>stack ghci</code>打开交互式环境，然后就可以愉悦的学习了。目前最的版本是ghc-8.0.1；</p>
<h2 id="优化显示"><a href="#优化显示" class="headerlink" title="优化显示"></a>优化显示</h2><p>默认的stack使用起来不是很方便，有些地方可以优化一二。<br>首先编辑<code>~/.stack/config.yaml</code>，删掉空白的<code>{}</code>，加入以下内容：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">templates:</span></div><div class="line"><span class="attr">    params:</span></div><div class="line"><span class="attr">        author-email:</span> <span class="string">yaotairan@gmail.com</span></div><div class="line"><span class="attr">        author-name:</span> <span class="string">tryao</span></div><div class="line"><span class="attr">        category:</span> <span class="string">Personal</span></div><div class="line"><span class="attr">        copyright:</span> <span class="string">'Copyright (c) TairanYao'</span></div><div class="line"><span class="attr">        github-username:</span> <span class="string">YiuTerran</span></div><div class="line"><span class="attr">package-indices:</span></div><div class="line"><span class="attr">- name:</span> <span class="string">Tsinghua</span></div><div class="line"><span class="attr">  download-prefix:</span> <span class="attr">http://mirrors.tuna.tsinghua.edu.cn/hackage/package/</span></div><div class="line"><span class="attr">  http:</span> <span class="attr">http://mirrors.tuna.tsinghua.edu.cn/hackage/00-index.tar.gz</span></div></pre></td></tr></table></figure></p>
<p>上面的email和名字之类的需要换成自己的，后面加了清华的源，加快<code>cabal</code>的下载速度。</p>
<p>编辑<code>~/.ghci</code>加入以下内容：<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> IPPrint</div><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.Haskell.HsColour <span class="keyword">as</span> HsColour</div><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.Haskell.HsColour.Colourise <span class="keyword">as</span> HsColour</div><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.Haskell.HsColour.Output <span class="keyword">as</span> HsColour</div><div class="line"></div><div class="line"><span class="title">let</span> myColourPrefs = <span class="type">HsColour</span>.defaultColourPrefs &#123; <span class="type">HsColour</span>.conid = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Yellow</span>, <span class="type">HsColour</span>.<span class="type">Bold</span>], <span class="type">HsColour</span>.conop = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Yellow</span>], <span class="type">HsColour</span>.string = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Green</span>], <span class="type">HsColour</span>.char = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Cyan</span>], <span class="type">HsColour</span>.number = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Red</span>, <span class="type">HsColour</span>.<span class="type">Bold</span>], <span class="type">HsColour</span>.layout = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">White</span>], <span class="type">HsColour</span>.keyglyph = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">White</span>] &#125;</div><div class="line"></div><div class="line"><span class="title">let</span> myPrint = putStrLn . <span class="type">HsColour</span>.hscolour (<span class="type">HsColour</span>.<span class="type">TTYg</span> <span class="type">HsColour</span>.<span class="type">XTerm256Compatible</span>) myColourPrefs <span class="type">False</span> <span class="type">False</span> <span class="string">""</span> <span class="type">False</span> . <span class="type">IPPrint</span>.pshow</div><div class="line"></div><div class="line">:set -interactive-print=myPrint</div><div class="line">:set -<span class="type">XNoMonomorphismRestriction</span></div><div class="line">:set prompt <span class="string">"λ "</span></div></pre></td></tr></table></figure></p>
<p>然后在shell里运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libbz2-dev</div><div class="line">stack install ipprint hscolour</div></pre></td></tr></table></figure></p>
<p>执行stack安装依赖时，可能会报错，根据提示修正即可.<br>这是给<code>ghci</code>添加语法高亮.</p>
<p>最后，如果用zsh的话， 可以打开<code>stack</code>插件，方便自动完成. 也可以<code>alias ghci=&#39;stack ghci&#39;</code>. 另外，最好把<code>~/.local/bin</code>加到PATH里面去.</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>仍然从<a href="http://wiki.jikexueyuan.com/project/haskell-guide/introduction.html" target="_blank" rel="external">《Haskell趣学指南指南》</a>这本书开始是比较合适的，虽然内容有些过时，但是基础部分变动应该不大。上次看这本书的时候我还不会python呢，如今js我也驾轻就熟了，看起来应该简单很多了。完成后开始看<a href="http://cnhaskell.com/" target="_blank" rel="external">《Real World Haskell》</a>，后者相关习题的个人解答：<a href="https://github.com/YiuTerran/rwh-exercise" target="_blank" rel="external">https://github.com/YiuTerran/rwh-exercise</a></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>基本语法大体和普通语言（C系）相似，除了：</p>
<ul>
<li>不等于符号是 <code>/=</code>，和数学中的$\neq$长的很像</li>
<li><code>not</code>和python里面一样，但是<code>&amp;&amp;</code>, <code>||</code>和C语言一样</li>
<li>函数调用使用<strong>空格</strong>，且具有最高优先级</li>
<li>括号用来保持更高的优先级</li>
<li><code>if..then..else</code>句式中，<code>else</code>是不可省略的，类似python中的单句<code>if..else</code></li>
<li>函数不允许首字母大写，按规定，所有首字母大写的都是类型或者类型类</li>
<li>由于允许操作符重载（自定义），很多符号的定义在不同的包里有不同的意思。如<code>Data.Ratio</code>里面有一堆分数相关的操作，<code>Data.Bits</code>里面则定义了很多位操作</li>
<li>操作符重载只是一种C++的描述，其实在这里是一种函数（当然<br>在ghci中，使用<code>let</code>定义变量，在脚本中直接赋值即可，变量可以看作是没有参数的函数（名字）。</li>
</ul>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul>
<li><code>list</code>和python中的形式大体一致，除了一点：所有元素的类型必须相同。</li>
<li>将两个列表合并使用<code>++</code>(效率较低）,使用<code>:</code>将元素插入队首，本质上<code>[1, 2, 3]</code>就是<code>1: 2: 3: []</code></li>
<li>使用<code>!!</code>取下标，越界会报错</li>
<li>list中的list也必须是同样元素类别（但是不关心长度）</li>
<li><code>head</code>返回头部（<code>car</code>)，<code>tail</code>返回尾部(<code>cdr</code>)，<code>last</code>返回最后一个元素，<code>init</code>返回除了最后一个元素的列表</li>
<li>对空的list，以上函数都会报错</li>
<li>Haskell的string就是<code>[Char]</code></li>
<li>使用<code>length</code>函数返回list的长度</li>
<li>使用<code>null</code>函数检测是否为空</li>
<li>使用<code>reverse</code>函数进行反转</li>
<li>使用<code>take</code>函数取出队首任意多个元素，超过长度也不会报错，只是返回所有</li>
<li>使用 <code>drop</code>删除队首任意多个元素</li>
<li>使用<code>maximum</code>和<code>minimum</code>求出队列中的极值</li>
<li>使用<code>sum</code>和<code>product</code>求出队列的和,积</li>
<li>使用<code>elem</code>判断是否是元素，一般用中缀形式表达（类似python中的<code>in</code>）</li>
<li>range生成使用<code>..</code>，例如[1..20]， step可以在第二个元素中指定，如[10,8..0];字母也可以用；但是不要用浮点数；由于惰性的原因，可以是无限长的range;</li>
<li>repeat函数用于生成重复序列，类似python中的<code>*</code></li>
<li>大名鼎鼎的list comprehesion,和python中类似，不同的是形式更加数学化。比如生成1到10的平方，在python中是<code>[k^2 for k in range(1, 10)]</code>，在hs中则是<code>[k^2 | k &lt;- [1..10]]</code>，感觉有点像高中数学吧，哈。后面的条件用逗号隔开表示<code>&amp;&amp;</code></li>
</ul>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><ul>
<li>仍然类似python中的tuple，但是：不允许有仅含有一个元素的tuple</li>
<li>在模式匹配中被大量使用</li>
<li>tuple的大小是不可改变的，但是类型可以不同</li>
<li><code>fst</code>, <code>snd</code>分别返回tuple的第一项和第二项，显然仅对<code>pair</code>（二元组）有效；</li>
<li><code>zip</code>用于使list组成tuple对，类似python</li>
<li><code>map</code>也类似python</li>
</ul>
<h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><ul>
<li>类型推导最强的语言，显式类型声明<code>::</code>，如<code>a :: Char</code></li>
<li>在ghci中使用<code>:t</code>判断类型，使用<code>:info</code>查看具体相关</li>
<li>类型的首字母必须大写</li>
<li><code>Int</code>是有限的，<code>Integer</code>是无限的</li>
<li>类型无关的时候，使用小写字母代替，比如<code>[a]</code>表示任意元素组成的list</li>
<li>typeclass是预定义的类型接口，比如可以相等的类型，必定是<code>Eq</code>的一个实现</li>
<li>类型约束<code>=&gt;</code>，类似于接口中的<code>where</code>，可以是任意类型，但必须满足。例如 <code>(Eq a)=&gt; a -&gt; a</code></li>
</ul>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>对于Haskell的纯函数而言，其主要书写格式就是大名鼎鼎的模式匹配，<code>Rust</code>也学习了这套语法。模式匹配其实是将数学按照构造函数进行拆分，能够这么干的主要原因是Haskell是纯函数式语言，没有副作用，变量被赋值后不能够再次修改。</p>
<ul>
<li>最好自己写上函数的签名，方便在编译期查错</li>
<li>对于函数来说，从上到下匹配，允许递归</li>
<li>对于<code>switch...case</code>类型的句子，使用<code>Guard</code>(<code>|</code>)，如果条件需要计算，在后面使用<code>where</code>（允许多个变量，但是要垂直隔开）</li>
<li>也可以使用<code>let..in</code>表示中某个作用域中的变量声明</li>
<li><code>let</code>是一个表达式，而<code>where</code>是一个语法结构，表达式（类似<code>if..then..else</code>）可以放在各种位置</li>
<li>除了这些以外，<code>case</code>表达式本身也存在，其语法结构是<code>case xx of x -&gt; ...</code>，模式匹配本质上都是这个表达式的语法糖</li>
<li>使用<code>_</code>可以匹配任意情况</li>
<li>除了纯函数外，Haskell也有有副作用的函数比如IO，这种函数的书写格式更类似普通命令式语言。</li>
<li>函数的基本形式是<code>a-&gt;b-&gt;c</code>，箭头连接各个参数，由于函数是柯里化的，所以也可以看做<code>a-&gt;(b-&gt;c)</code>，每个部分是一个<strong>偏函数</strong>，整个被称为<strong>全函数</strong>。如果函数不返回任何东西（在某些语言中被称为过程），这个函数肯定是非纯函数，一般返回<code>()</code>【读作<code>unit</code>】，如<code>IO ()</code></li>
</ul>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>lambda表达式本来就源自FP(lisp)，所以很自然的：<code>\xs -&gt; length xs</code>，不过haskell中用lambda比其他语言应该少很多。</p>
<p>常用的一些函数：<br><code>fold</code>, <code>fold1</code>, <code>foldr</code>, scan家族类似<br><code>$</code> 符号同样也可以调用函数，但是与空格不同，他具有最低优先级，主要用来减少括号的数量；<br><code>.</code>符号表示右结合的函数，即先算最右边的，然后依次应用左边的函数，右边函数的返回值是左边函数的参数；<br>上面两个符号主要用来做函数组合，简化书写。。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>熟悉的import语句，不过和python的语法不太像，倒是有点像java.</p>
<ul>
<li><code>import Data.List</code> 会导入该模块下的所有函数；</li>
<li><code>import Data.List (nub, sort)</code>仅导入两个函数</li>
<li><code>import Data.list hiding (nub)</code> 导入除了nub之外的所有函数</li>
<li><code>import qualified Data.Map</code> 导入所有函数，但是如果和已加载模块冲突的话，必须使用全引用</li>
<li>可以在后面加上<code>as x</code>做别名</li>
</ul>
<h3 id="自定义结构"><a href="#自定义结构" class="headerlink" title="自定义结构"></a>自定义结构</h3><p>关键字： <code>data</code><br>和其他语言不一样，标准格式很奇怪<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">BookInfo</span> = <span class="type">Book</span> <span class="type">Int</span> <span class="type">String</span> [<span class="type">String</span>]</span></div><div class="line">                                <span class="keyword">deriving</span> (<span class="type">Show</span>)</div></pre></td></tr></table></figure></p>
<p>BookInfo就是类型的名字（类型构造器），Book是值构造器的名字，后面是成员；两者名字可以一致；</p>
<p>这样访问属性还要写专门的函数（模式匹配），很蛋疼，所以有个惯用法（标准称呼是<strong>记录</strong>）：<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">BookInfo</span> = <span class="type">BookInfo</span> &#123;</span></div><div class="line">    <span class="title">price</span>   :: <span class="type">Int</span>,</div><div class="line">    <span class="title">author</span>  :: <span class="type">String</span>,</div><div class="line">    <span class="title">buyer</span>   :: [<span class="type">String</span>]</div><div class="line">&#125; <span class="keyword">deriving</span> (<span class="title">show</span>)</div></pre></td></tr></table></figure></p>
<p>这些成员当然也可以是函数。</p>
<p>递归定义也是很常见的，比如一个二叉树：<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Node</span> a (<span class="type">Node</span> <span class="title">a</span>) (<span class="type">Node</span> <span class="title">a</span>)</span></div></pre></td></tr></table></figure></p>
<p>这里a是类型参数。</p>
<p>关键字<code>type</code>类似C++中的<code>typedef</code>，用于定义类型的别名。</p>
<p>此外<code>newtype</code>也可以自定结构，不过有很多约束。<code>newtype</code>关键字给现有类型一个不同的身份，因此只能有一个值构造器，并且这个构造器只能有一个字段。</p>
<p>由<code>data</code>关键字创建的类型在运行时有一个记录开销，如记录某个值是用哪个构造器创建的。而<code>newtype</code>只有一个构造器，所以不需要这个额外开销。这使得它在运行时更省时间和空间。由<code>newtype</code>的构造器只在编译时使用，运行时甚至不存在。</p>
<h3 id="typeclass"><a href="#typeclass" class="headerlink" title="typeclass"></a>typeclass</h3><p>就是其他语言中的类型类/接口/模板，语法是<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">BasicEq</span> a <span class="keyword">where</span></span></div><div class="line">    isEqual:: a -&gt; a -&gt; <span class="type">Bool</span></div></pre></td></tr></table></figure></p>
<p>实例是<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">BasicEq</span> bool <span class="keyword">where</span></span></div><div class="line">    isEqual <span class="type">True</span> <span class="type">True</span> = <span class="type">True</span></div><div class="line">    isEqual <span class="type">False</span> <span class="type">False</span> = <span class="type">True</span></div><div class="line">    isEqual _ _ = <span class="type">False</span></div></pre></td></tr></table></figure></p>
<ul>
<li>常见的Typeclass包括<code>Eq</code>, <code>Ord</code>(可比较), <code>Show</code>(可以转换为字符串), <code>Read</code>可以被<code>String</code>转换(可以用<code>::</code>显式指定类型)，<code>Enum</code>（可以被迭代)，<code>Bounded</code>(有上下限），<code>Num</code>(有数字特征，必须实现<code>Eq</code>和<code>Show</code>)，<code>Integral</code>, <code>Floating</code></li>
<li><code>fromIntegral</code>可以将整数转换成浮点数（根据后续操作转换）</li>
<li>默认情况下，Haskell不支持模板特化（重载）。可以通过语言扩展<code>FlexibleInstances</code>取消这个限制。</li>
<li>扩展<code>OverlappingInstances</code>可以允许重叠实例。</li>
<li>在文件最前面加上<code>{-# LANGUAGE TypeSynonymInstances, OverlappingInstances #-}</code>即可打开编译器扩展；</li>
<li>在<code>RWH</code>上面提到了单一同态错误问题，经过我的测试，在最新的(8.0.1)的GHC中这个问题已经不存在了；</li>
<li>同C++的模板一样，允许多参数类型类（MultiParamTypeClasses），多参数之间可以定义条件约束表明多个参数之间的关系</li>
<li>多参数类型类比较复杂，谨慎使用</li>
</ul>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>使用 error 函数输出错误<br>避免抛出错误，使用<code>Maybe</code>, <code>Just</code>和<code>Nothing</code></p>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><blockquote>
<p>Haskell 依据缩进来解析代码块。这种用排版来表达逻辑结构的方式通常被称作缩进规则。在源码文件开始的那一行，首个顶级声明或者定义可以从该行的任意一列开始，Haskell 编译器或解释器将记住这个缩进级别，并且随后出现的所有顶级声明也必须使用相同的缩进。<br>let 表达式和 where 从句的规则与此类似。一旦 Haskell 编译器或解释器遇到一个 let 或 where 关键字，就会记住接下来第一个标记（token）的缩进位置。然后如果紧跟着的行是空白行或向右缩进更深，则被视作是前一行的延续。而如果其缩进和前一行相同，则被视作是同一区块内的新的一行。</p>
</blockquote>
<p>也可以使用显式语法结构（使用花括弧代替缩进），不过一般不这么做</p>
<h3 id="节"><a href="#节" class="headerlink" title="节"></a>节</h3><p>节其实是高阶函数的一种形式（语法糖），如<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">test</span> = (+<span class="number">2</span>)</div><div class="line">// test <span class="number">3</span> = <span class="number">5</span></div></pre></td></tr></table></figure></p>
<h3 id="As模式"><a href="#As模式" class="headerlink" title="As模式"></a>As模式</h3><blockquote>
<p>模式 <code>xs@(_:xs&#39;)</code> 被称为 as-模式，它的意思是：如果输入值能匹配 @ 符号右边的模式（这里是 <code>(_:xs&#39;)</code> ），那么就将这个值绑定到 @ 符号左边的变量中（这里是 xs ）。</p>
</blockquote>
<p>除了增强可读性外，可以简化代码，减少内存分配</p>
<h3 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h3><ul>
<li><code>foldl</code>，接受一个初始值，一个步进函数，对一个列表进行迭代求职，显然<code>sum = foldl (+) 0</code></li>
<li><code>foldr</code>，格式同上，从右侧开始折叠。</li>
</ul>
<blockquote>
<p>一种思考 foldr 的方式是，将它看成是对输入列表的一种转换（transform）：它的第一个参数决定了该怎么处理列表的 head 和 tail 部分；而它的第二个参数则决定了，当遇到空列表时，该用什么值来代替这个空列表。</p>
</blockquote>
<ul>
<li>千万不要把 foldl 用在实际使用中，这是因为会发生内存泄露（因为惰性求值的关系</li>
<li>真正的情况使用的是<code>foldl&#39;</code>，<code>foldr&#39;</code> (Data.List)</li>
<li><code>foldl</code>的步进函数格式是 <code>step acc x</code>, <code>foldr</code>的则是<code>step x acc</code>，对于list <code>(x:xs)</code>而言，从左折叠第一个元素是<code>x</code>，从右折叠第一个元素是<code>[]</code>；</li>
</ul>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>module的规定类似java，名字必须和文件名一致，首字母必须大写；<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">module</span> SimpleJSON(</div><div class="line">    <span class="type">Xxxx</span>,   //导出部分，如果省略则全部导出</div><div class="line">) <span class="keyword">where</span></div></pre></td></tr></table></figure></p>
<p>显然入口模块应该是<code>Main.hs</code></p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>单文件可以用<code>runghc</code>命令运行，相当于脚本；也可以在ghci里面<code>:l</code>外部文件进行测试；<br>编译则需要使用<code>stack ghc</code>命令；</p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul>
<li>IO是有副作用的（非幂等的），因此Haskell中的IO和非IO函数一般严格分开。</li>
<li>IO动作可以被创建，赋值和传递到任何地方，但是仅能在另一个IO动作里被执行</li>
<li><code>&lt;-</code>运算符从I/O中抽出结果并保存到一个变量中</li>
<li>当有多个动作时，使用<code>do</code>引入代码块</li>
<li>在<code>do</code>中，使用命令式语言的语法完成一系列操作（赋值用<code>let</code>）</li>
<li><code>do</code> 代码块中的每一个声明，除了 <code>let</code> ，都要产生一个I/O操作，这个操作在将来被执行（惰性）</li>
<li>IO相关函数被定义在<code>System.IO</code>中</li>
<li><code>return</code>的作用和<code>&lt;-</code>相反，将一个纯值包装进IO，可以把IO想象成一个流。<code>return</code>入流后，将来可以通过<code>-&gt;</code>取出来赋值；</li>
<li>除了普通IO以外，haskell还有自己特色的惰性IO，<code>hGetContents</code>就是惰性的</li>
<li>除了<code>openFile</code>和<code>hClose</code>外，使用<code>readFile</code>也可以，同时可以避免忘记关掉<code>hClose</code>的问题</li>
<li>对于指定的模式，比如打开文件流，做一些变化，再输出到流，可以用<code>interact</code></li>
<li>IO与普通函数的联系通过<code>Monad</code>实现，或者说IO是一种Monad</li>
<li>命名习惯： <code>mapM</code>返回一个IO动作，<code>mapM_</code>完成IO，但是不返回任何值，<code>M</code>的后缀表示<code>Monad</code></li>
<li><code>map</code>不能执行操作（纯函数），这就是<code>mapM</code>存在的意义</li>
<li><code>forM</code>意思与<code>mapM</code>相反，第一个参数是列表，第二个是动作，存在的意义是更干净的代码</li>
<li><code>do</code>代码块实际上是把操作连接在一起的快捷记号，可以用<code>&gt;&gt;</code>和<code>&gt;&gt;=</code>代替</li>
<li><code>&gt;&gt;</code> 运算符把两个操作串联在一起：第一个操作先运行，然后是第二个，整个计算的结果是最后运算的结果</li>
<li><code>&gt;&gt;=</code> 运算符运行一个操作，然后把它的结果传递给一个返回操作的函数。类似linux 管道操作</li>
<li>类似地，还有<code>=&lt;&lt;</code>运算符，将右边的动作传递给左边</li>
<li>换句话说，<code>do</code>块的最后一个操作的值就是整个<code>do</code>的值。如果以<code>return</code>结尾，返回一个<code>Monad</code>，比如整个函数的返回值是<code>IO()</code>，最后多半就是以<code>return</code>结尾。这种函数的返回值只能在另一个Monad函数中重新读出，不能直接用于任何操作。</li>
<li>Haskell中的纯代码不能运行那些能触发副作用的命令。纯函数不能修改全局变量，请求I/O，或者运行一条关闭系统的命令</li>
</ul>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul>
<li>默认的String类型速度堪忧，可以用<code>bytestring</code>库代替。<code>Data.ByteString</code>和<code>Data.ByteString.Lazy</code>分别代表了惰性和普通模式的情况；</li>
<li>不要在类型定义上加类型约束，在需要它们的函数上加；</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>除了<code>List</code>和<code>Tuple</code>, Haskell自带了其他的一些常见的数据结构；</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li>关联列表也可以当作字典用，但是效率比较低。使用<code>lookup</code>可以在关联列表中查询数据；</li>
<li><code>Data.Map</code>，不同于大部分语言，这个<code>Map</code>是用平衡二叉树实现的，而不是哈希表。这和haskell的不可变性有关；</li>
<li>常用函数：<code>fromList</code>(通过关联列表转换)，<code>insert</code>（插入新值返回新的<code>Map</code>）</li>
<li>虽然是二叉树实现的，这个<code>Map</code>仍然是无序的（有点奇怪）</li>
</ul>
<h2 id="通用序列"><a href="#通用序列" class="headerlink" title="通用序列"></a>通用序列</h2><p><code>Data.Sequence</code>提供了比默认<code>list</code>更好的效率</p>
<ul>
<li>使用<code>fromList</code>创建，或者用<code>empty</code>和<code>singleton</code>函数创建</li>
<li>使用<code>|&gt;</code>, <code>&lt;|</code>和<code>&gt;&lt;</code> 添加元素，箭头指向被添加的元素</li>
<li>使用<code>Foldable.toList</code>将<code>Sequence</code>转回list</li>
</ul>
<h2 id="Functor（函子）"><a href="#Functor（函子）" class="headerlink" title="Functor（函子）"></a>Functor（函子）</h2><p>对于一个递归的数据结构，对于应用于其上的函数也很可能是同构递归的。书中的例子是将一棵字符串树转变为包含字符串长度的树，也就是说，树的结构不变，但是元素变成长度：</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">treeLengths</span>:: <span class="type">Tree</span> -&gt; <span class="type">Tree</span></div><div class="line"><span class="title">treeLengths</span> (<span class="type">Leaf</span> s) = <span class="type">Leaf</span> (treeLengths s)</div><div class="line"><span class="title">treeLengths</span> (<span class="type">Node</span> l r) = <span class="type">Node</span> (treeLengths l) (treeLengths r)</div></pre></td></tr></table></figure>
<p>这种能够同构映射的，满足类型类<code>Functor</code>，映射函数即<code>fmap</code>：</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></div><div class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</div></pre></td></tr></table></figure>
<p><code>Functor</code>是非常重要的一类class，有几个基本原则进行约束。首先，<code>fmap id</code>必须返回相同的值，其次，<code>Functor</code>必须是可组合的，换句话说，<code>fmap a . fmap b</code> == <code>fmap (a . b)</code>应该成立。</p>
<p>编译器不会检查这些规则，程序员需要自己保证这些规则成立。这些规则是函子在范畴论中的数学约束。</p>
<h2 id="幺半群"><a href="#幺半群" class="headerlink" title="幺半群"></a>幺半群</h2><p>在范畴论中，有一类简单的抽象结构被称为幺半群。许多数学结构都是幺半群，因为成为幺半群的要求非常低。 一个结构只要满足两个性质便可称为幺半群：</p>
<ul>
<li>一个满足结合律的二元操作符。我们称之为 <code>(*)</code>：表达式 <code>a * (b * c)</code> 和 <code>(a * b) * c</code> 结果必须相同。</li>
<li>一个单位元素。我们称之为 <code>e</code>，它必须遵守两条法则：<code>a * e == a</code> 和 <code>e * a == a</code>。</li>
</ul>
<p>即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Monoid a where</div><div class="line">    mempty  :: a                -- the identity</div><div class="line">    mappend :: a -&gt; a -&gt; a      -- associative binary operator</div></pre></td></tr></table></figure></p>
<p>如果我们真的需要在同一个类型上实现多个 Monoid 实例，我们可以用 newtype 创建不同的类型来达到目的。</p>
<h2 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h2><p><code>Monad</code>（单子）是Haskell最难理解的东西之一，这个概念和上文中的幺半群有关，<a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="external">这里</a>有一些辅助理解的漫画。</p>
<p>一个Monad由以下几个构造元素：</p>
<ul>
<li>一个类型构造器 m</li>
<li>一个用于把某个函数的输出串联到另外一个函数输入上的函数，它的类型是 <code>m a -&gt; (a -&gt; m b) -&gt; m b</code></li>
<li>一个类型为 <code>a -&gt; m a</code> 的函数，它把普通值注入到调用链里面，也就是说，它把类型 a 用类型构造器 m 包装起来。</li>
</ul>
<p>标准的monad定义为：<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span></div><div class="line">    <span class="comment">-- chain</span></div><div class="line">    (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</div><div class="line">    <span class="comment">-- inject</span></div><div class="line">    return :: a -&gt; m a</div></pre></td></tr></table></figure></p>
<p>显然<code>&gt;&gt;=</code>就是串联函数，<code>return</code>是注入函数（IO monad就是把普通值放入IO），类型构造器就是<code>m</code>本身。除此之外，还有<code>&gt;&gt;</code>函数用户忽略返回值的过程（即按步骤一步步来），以及<code>fail</code>函数接受一个错误消息让整个调用链失败（默认使用<code>error</code>函数）。</p>
<p>下面是具体的解析：</p>
<ul>
<li>如漫画里所述，单子、函子、态射都是对普通值一种包装(context)，由于haskell里值是不可变的，所以都可以重新用构造器进行匹配解析。</li>
<li>对于函子，是这样一种类型类（接口），存在<code>fmap</code>函数，可以让让普通函数与该类型类的实例进行运算，最简单的来讲<code>fmap (+3) (Just 5)</code>应该是<code>Just 8</code>；函子的中缀形式是<code>&lt;$&gt;</code>；</li>
<li>对于普通的函子，<code>fmap</code>仅能将函数应用于被包装的数据。对于<code>Applicative</code>这种，则可以将函数应用于被包装的函数。<code>import Control.Applicative</code>以后，可以使用<code>(Just (+3)) &lt;*&gt; (Just (+5))</code>，这将会生成一个<code>Just (+8)</code>的函数；这是因为函数也可以是函子的实例。因为函子的约束只有<code>可以应用fmap</code>这一个而已.</li>
<li>单子与上面的两个函子很类似，单子主要定义了<code>&gt;&gt;=</code>（bind）和<code>return</code>这两个函数，前者用于连接包装值和接受普通值作为参数的函数，该函数返回一个包装值。换句话说，Monad定义了一种行为，如何将包装值分解为普通值行为，最后再返回包装值。也就是<code>M a -&gt; (a -&gt; M b) -&gt; M b</code>.</li>
<li>单子的<code>return</code>其实就是将任意普通值包装起来；</li>
<li>有了上面两个性质，Monad就可以类似管道一样将普通函数串接起来使用了；</li>
</ul>
<hr>
<ul>
<li><p><code>Monad</code> class里面没有提供任何函数可以使一个<code>monadic</code>的值还原成一个普通值，这需要写代码的人自己定义。</p>
</li>
<li><p>我们经常需要将数据从<code>Monad</code>中取出来，然后使用纯函数进行计算，最后再用原来的类型构造器重新包围这个计算的结果,这种需求被称为<code>lifting</code>.对于<code>Monad</code>而言，已经定义了<code>&gt;&gt;=</code>和<code>return</code>，所以很容易得出：</p>
</li>
</ul>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">liftM</span> :: (<span class="type">Monad</span> m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b</div><div class="line"><span class="title">liftM</span> f m = m &gt;&gt;= \i -&gt;</div><div class="line">    return (f i)</div></pre></td></tr></table></figure>
<p>该函数被定义在<code>Control.Monad</code>中。比如我们要计算<code>Just (1 + 3)</code>，就可以用<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- Just 4</span></div><div class="line">( <span class="number">1</span> + ) `liftM` (<span class="type">Just</span> <span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p>这与 <code>Just 3 &gt;&gt;= \x -&gt; Just (x+1)</code>等价。</p>
<p>另外，从函子的角度，这个也可以写作<code>(1+) &lt;$&gt; (Just 3)</code></p>
<p>如果函数<code>f</code>有多余一个参数，<code>Control.Monad</code>中也有对应的<code>liftM2</code>~<code>liftM5</code></p>
<ul>
<li>在<code>Control.Monad</code>中定义<code>ap</code>函数，其签名为：<br><code>ap :: Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b</code><br>解读一下：第一个参数是一个被Monad包装的函数，第二个参数是一个普通的Monad值，这个值的类型与第一个参数中被包装的函数的参数相同（很拗口）。我们知道标准库总只定义了几个常见的<code>liftM</code>，如果我们需要大量链式调用，除了<code>&lt;*&gt;</code>外，还可以组合<code>liftM</code>和<code>ap</code>. 举个例子，定义</li>
</ul>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">fee</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></div><div class="line"><span class="title">fee</span> a b = a + b</div></pre></td></tr></table></figure>
<p>那么 <code>liftM fee</code>的类型为：</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Monad</span> m =&gt; m <span class="type">Int</span> -&gt; m (<span class="type">Int</span> -&gt; <span class="type">Int</span>)</div></pre></td></tr></table></figure>
<p>显然这个函数的返回值满足<code>ap</code>的参数需求， 所以以下两个表达式相等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fee `liftM` (Just 1) `ap` (Just 1)</div><div class="line">fee `liftM` (Just 1) &lt;*&gt; (Just 1)</div><div class="line">liftM2 fee (Just 1) (Just 1)</div></pre></td></tr></table></figure>
<ul>
<li><code>join</code>函数也很常用：</li>
</ul>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">join</span> :: <span class="type">Monad</span> m =&gt; m (m a) -&gt; m a</div><div class="line"><span class="title">join</span> x = x &gt;&gt;= id</div></pre></td></tr></table></figure>
<p>用来移除一层Monad，<code>join (Just (Just a))</code>就是<code>Just a</code></p>
<ul>
<li>Monad的三个约束（数学意义上），类似Functor，Monad也有一些潜在的约束：<ul>
<li><code>return x &gt;&gt;= f</code> == <code>f x</code></li>
<li><code>m &gt;&gt;= return</code> == <code>m</code></li>
<li><code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code> === <code>(m &gt;&gt;= f) &gt;&gt;= g</code></li>
</ul>
</li>
</ul>
<p>第三条是结合律，如果我们把一个大的action分解成一系列的子action，只要我们保证子action的顺序，把哪些子action提取出来组合成一个新action对求值结果是没有影响的。</p>
<ul>
<li><code>Control.Monad</code>里面定义了<code>MonadPlus</code>，这其实是短路求值。</li>
</ul>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadPlus</span> m <span class="keyword">where</span></span></div><div class="line">    mzero :: m a</div><div class="line">    mplus :: m a -&gt; m a -&gt; m a</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">MonadPlus</span> [] <span class="keyword">where</span></div><div class="line">    mzero = []</div><div class="line">    mplus = (++)</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">MonadPlus</span> <span class="type">Maybe</span> <span class="keyword">where</span></div><div class="line">    mzero = <span class="type">Nothing</span></div><div class="line">    <span class="type">Nothing</span> `mplus` ys = ys</div><div class="line">    xs `mplus` _ = xs</div></pre></td></tr></table></figure>
<ul>
<li><p>在<code>Control.Monad</code>中定义了标准函数<code>guard</code>：</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">guard</span> :: (<span class="type">MonadPlus</span> m) =&gt; <span class="type">Bool</span> -&gt; m()</div><div class="line"><span class="title">guard</span> <span class="type">True</span>  = return ()</div><div class="line"><span class="title">guard</span> <span class="type">False</span> = mzero</div></pre></td></tr></table></figure>
</li>
<li><p>在<code>Control.Arrow</code>中定义了函数<code>first</code>和<code>second</code>用于将普通函数应用到<code>Pair</code>中去</p>
</li>
</ul>
<h2 id="Monad变换器"><a href="#Monad变换器" class="headerlink" title="Monad变换器"></a>Monad变换器</h2><p>Monad变换器主要用来修改已经存在的Monad，以<code>T</code>结尾。大量Monad变换器进行叠加，就可以得到拥有多种功能的Monad.</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>讨论一些常用的haskell处理方式：<code>Maybe</code>, <code>Either</code>和<code>Exception</code>，一般都使用Monad配合。</p>
<p>再往后就是一些实际使用的例子了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我打算学习但是最终没能完全理解的语言大概有三门：因为复杂性而放弃的Scala和Rust，因为难以理解而放弃的Haskell. 学习过C++以后，我对太过复杂的语言一项是敬而远之的，这一点暂时不会有变化，以后在工作中如果遇到必须使用Scala的时候我还是会认真学习。但是对于H
    
    </summary>
    
    
      <category term="FP" scheme="http://YiuTerran.github.io/tags/FP/"/>
    
      <category term="Haskell" scheme="http://YiuTerran.github.io/tags/Haskell/"/>
    
  </entry>
  
</feed>
