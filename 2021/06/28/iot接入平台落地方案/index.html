<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiuterran.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.3.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="概述目前设计的物联网平台（以下简称平台）主要负责以下事宜：  设备管理。设备模型抽象、相关数据维护； 设备接入。即所有设备的连接工作； 设备事件上报。设备事件接收-&gt;清洗-&gt;进入MQ的通用流程； 平台命令下发。提供接口给应用平台，后者可以给设备下命令； 设备状态维护。在离线、活跃、不活跃等状态； [可选]规则引擎。提供通用抽象功能，允许应用平台创建规则触发某些预定义动作。比如温度&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="iot接入平台落地方案">
<meta property="og:url" content="http://yiuterran.github.io/2021/06/28/iot%E6%8E%A5%E5%85%A5%E5%B9%B3%E5%8F%B0%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88/index.html">
<meta property="og:site_name" content="无心呢喃">
<meta property="og:description" content="概述目前设计的物联网平台（以下简称平台）主要负责以下事宜：  设备管理。设备模型抽象、相关数据维护； 设备接入。即所有设备的连接工作； 设备事件上报。设备事件接收-&gt;清洗-&gt;进入MQ的通用流程； 平台命令下发。提供接口给应用平台，后者可以给设备下命令； 设备状态维护。在离线、活跃、不活跃等状态； [可选]规则引擎。提供通用抽象功能，允许应用平台创建规则触发某些预定义动作。比如温度&amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gs2bfhy91vj31gi0rejvv.jpg">
<meta property="article:published_time" content="2021-06-28T07:42:28.000Z">
<meta property="article:modified_time" content="2021-07-02T01:37:51.461Z">
<meta property="article:author" content="tryao">
<meta property="article:tag" content="iot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gs2bfhy91vj31gi0rejvv.jpg">


<link rel="canonical" href="http://yiuterran.github.io/2021/06/28/iot%E6%8E%A5%E5%85%A5%E5%B9%B3%E5%8F%B0%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>iot接入平台落地方案 | 无心呢喃</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="无心呢喃" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">无心呢喃</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">个人技术类文章博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E6%8A%BD%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">设备模型抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B%E7%AE%A1%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">设备类型管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%93%81%E7%89%8C%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">设备品牌管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%81%E7%89%8C%E5%9E%8B%E5%8F%B7%E7%AE%A1%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">品牌型号管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%8D%8F%E8%AE%AE%E7%AE%A1%E7%90%86"><span class="nav-number">2.4.</span> <span class="nav-text">连接协议管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%85%B3%E8%81%94%E7%AE%A1%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">协议关联管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%8F%82%E6%95%B0%E7%AE%A1%E7%90%86"><span class="nav-number">2.6.</span> <span class="nav-text">协议参数管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-number">2.7.</span> <span class="nav-text">设备事件管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86"><span class="nav-number">2.8.</span> <span class="nav-text">设备命令管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6-%E5%91%BD%E4%BB%A4%E5%85%B3%E8%81%94%E7%AE%A1%E7%90%86"><span class="nav-number">2.9.</span> <span class="nav-text">事件&#x2F;命令关联管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%BC%98%E7%BD%91%E5%85%B3%E7%AE%A1%E7%90%86"><span class="nav-number">2.10.</span> <span class="nav-text">边缘网关管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E4%BA%A7%E7%AE%A1%E7%90%86"><span class="nav-number">2.11.</span> <span class="nav-text">资产管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%85%A5"><span class="nav-number">3.</span> <span class="nav-text">设备接入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%85%A5%E6%A8%A1%E5%9D%97%E4%BD%9C%E4%B8%BA%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">3.1.</span> <span class="nav-text">接入模块作为客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="nav-number">4.</span> <span class="nav-text">数据交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E4%BA%8B%E4%BB%B6%E4%B8%8A%E6%8A%A5"><span class="nav-number">4.1.</span> <span class="nav-text">设备事件上报</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E7%BB%B4%E6%8A%A4"><span class="nav-number">4.2.</span> <span class="nav-text">设备连接状态维护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8B%E5%8F%91"><span class="nav-number">4.3.</span> <span class="nav-text">应用命令下发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4"><span class="nav-number">4.4.</span> <span class="nav-text">运行时配置变更</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="nav-number">4.5.</span> <span class="nav-text">边云数据同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB"><span class="nav-number">4.6.</span> <span class="nav-text">微服务设计汇总</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%B1%87%E6%80%BB"><span class="nav-number">4.7.</span> <span class="nav-text">组件使用汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kafka%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB"><span class="nav-number">4.7.1.</span> <span class="nav-text">kafka相关设计汇总</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB"><span class="nav-number">4.7.2.</span> <span class="nav-text">redis相关设计汇总</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mqtt%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB"><span class="nav-number">4.7.3.</span> <span class="nav-text">mqtt设计汇总</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E"><span class="nav-number">5.</span> <span class="nav-text">规则引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%B9%B3%E5%8F%B0"><span class="nav-number">6.</span> <span class="nav-text">其他相关平台</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tryao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/YiuTerran" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YiuTerran" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yaotairan@gmail.com" title="E-Mail → mailto:yaotairan@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yiuterran.github.io/2021/06/28/iot%E6%8E%A5%E5%85%A5%E5%B9%B3%E5%8F%B0%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tryao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无心呢喃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iot接入平台落地方案
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-28 15:42:28" itemprop="dateCreated datePublished" datetime="2021-06-28T15:42:28+08:00">2021-06-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-02 09:37:51" itemprop="dateModified" datetime="2021-07-02T09:37:51+08:00">2021-07-02</time>
      </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/06/28/iot%E6%8E%A5%E5%85%A5%E5%B9%B3%E5%8F%B0%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/06/28/iot接入平台落地方案/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>目前设计的物联网平台（以下简称平台）主要负责以下事宜：</p>
<ol>
<li>设备管理。设备模型抽象、相关数据维护；</li>
<li>设备接入。即所有设备的连接工作；</li>
<li>设备事件上报。设备事件接收-&gt;清洗-&gt;进入MQ的通用流程；</li>
<li>平台命令下发。提供接口给应用平台，后者可以给设备下命令；</li>
<li>设备状态维护。在离线、活跃、不活跃等状态；</li>
<li>[可选]规则引擎。提供通用抽象功能，允许应用平台创建规则触发某些预定义动作。比如温度&gt;37°自动打开喷淋开关并给用户推送高温预警。该功能亦可通过大数据平台实时流处理来实现。</li>
</ol>
<p>本设计稿参考了thingsboard、水务平台、阿里云物联网平台，并根据我个人以往设计经验总结。</p>
<h2 id="设备模型抽象"><a href="#设备模型抽象" class="headerlink" title="设备模型抽象"></a>设备模型抽象</h2><p>物联设备包括以下通用<strong>属性</strong>：</p>
<ul>
<li>ID，设备唯一标识；</li>
<li>名称(name)；</li>
<li>类型(type)。类型可以分级方便用户选择，比如智慧园区(region)-&gt;人员管理(category)-&gt;考勤设备(type)；</li>
<li>品牌(brand)。设备制造商的标示；</li>
<li>型号(model)。设备制造商给设备设计的型号；</li>
<li>序列号(serialNumber，简称sn)。设备制造商给设备分配的编号；</li>
<li>通信协议(protocol)。每个协议标识对应一个具体代码的通信模块。即使是同一件设备，不同固件的通信方式可能有所改变，比如v1和v2的接口可能不兼容；</li>
<li>协议配置(protocolParam)。某些协议可能会依赖其他的字段，比如第三方平台的账号密码等，如果没有的话无法正常建立通信。这里可以选择租户已经添加的配置；</li>
<li>其他<strong>扩展字段</strong>(extend)。比如设备通信地址（ip地址、蓝牙地址等），安装坐标；或者某类设备独有的属性，摄像头是球机和枪机、门禁是进还是出等等；允许自行添加kv字段，在数据库里可以用json/jsonb或者纵表；</li>
<li>支持事件(event)。同一类(type)设备往往支持类似的事件，如环境设备都支持上传环境数据，但是具体到设备上要看安装了多少传感器；</li>
<li>支持命令(command)。设备可执行的命令，同类(type)设备往往支持类似的命令，比如人脸识别设备一般支持远程开/关门；</li>
<li>租户(tenant)。理论上设备只能同时属于同一个租户，但是可以考虑设备属于多个租户的需求。比如一个设备归属方，其他的属于设备监管方，也有权查看设备数据。当然这个归属问题也可以在应用层来做，平台这边简单设计设备就只有一个租户；</li>
</ul>
<p>几个要点：</p>
<ul>
<li>设备ID应该由物联网平台生成，支持通过界面添加或者其他服务调用平台接口添加；</li>
<li>设备的brand-type-sn，应该构成唯一性，即同一品牌同一类型的设备序列号唯一；</li>
<li>protocol决定了设备通信的方式，添加设备时可以通过设备类型+设备品牌筛选protocol；</li>
<li>可用的protocol列表是与代码中的通信模块一一映射的，因此该列表由开发人员维护；</li>
<li>标准HTTP接口和标准MQTT接口是我方提供的两种通用的protocol，选择这两种接入时，服务端会自动生成访问密钥；</li>
<li>设备通过边缘网关接入和直连上云的唯一区别是协议参数需要选择对应的边缘网关，边缘网关和设备之间仍然使用协议模块通信，边缘网关和平台之间使用标准mqtt接口通信；</li>
<li>当设备/边缘网关采用标准HTTP接口通信时，仅当设备/边缘端有固定外网地址时，才能接受云端下发的命令。有时需要考虑内网穿透问题；</li>
<li>理论上，设备的brand-type-model-protocol决定了设备支持的事件和命令，以及事件/命令具体的参数；</li>
</ul>
<p>综上，需要设计以下表单/API进行设备数据录入(以下字段并非数据库中的字段，仅为示例)：</p>
<h3 id="设备类型管理"><a href="#设备类型管理" class="headerlink" title="设备类型管理"></a>设备类型管理</h3><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>类型码，枚举值，唯一标识，如200</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>中文名称，如：考勤设备</td>
</tr>
</tbody></table>
<p>为了避免各应用重复添加设备类型，该接口可以不开放，仅能通过界面手动添加。</p>
<p>如果需要<strong>级联</strong>的设备类型，则需要加入树结构管理，即parentId.</p>
<h3 id="设备品牌管理"><a href="#设备品牌管理" class="headerlink" title="设备品牌管理"></a>设备品牌管理</h3><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>唯一标识，可以用自增</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>如：海康</td>
</tr>
<tr>
<td>deviceTypes</td>
<td>[int]</td>
<td>该品牌涉及的设备类型，为了方便搜索</td>
</tr>
</tbody></table>
<h3 id="品牌型号管理"><a href="#品牌型号管理" class="headerlink" title="品牌型号管理"></a>品牌型号管理</h3><p>品牌型号的录入，只是为了细化设备对应的协议和支持事件/命令，其实也可以没有。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>唯一标识，自增</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>型号名称</td>
</tr>
<tr>
<td>brandId</td>
<td>int</td>
<td>品牌id</td>
</tr>
<tr>
<td>deviceType</td>
<td>int</td>
<td>设备类型</td>
</tr>
</tbody></table>
<h3 id="连接协议管理"><a href="#连接协议管理" class="headerlink" title="连接协议管理"></a>连接协议管理</h3><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>string</td>
<td>唯一标识，如std-mqtt</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>中文名称，如标准MQTT接口</td>
</tr>
<tr>
<td>deviceType</td>
<td>int</td>
<td>驱动对应的设备类型，默认0表示支持所有设备类型</td>
</tr>
<tr>
<td>connMode</td>
<td>int</td>
<td>0-我方服务端(默认)，1-我方客户端</td>
</tr>
<tr>
<td>netMode</td>
<td>int</td>
<td>0-可以外网访问(默认)，1-仅支持内网通信</td>
</tr>
<tr>
<td>params</td>
<td>json schema</td>
<td>该驱动参数的json schema描述（后端）</td>
</tr>
</tbody></table>
<p>该表<strong>由开发人员维护</strong>。在未正式接入实际项目之前，前期先实现<code>std-mqtt</code>和<code>std-http</code>两类协议。</p>
<p><a target="_blank" rel="noopener" href="https://json-schema.org/">json schema</a>是一种json数据结构自描述规范，前端需要据此动态渲染表格给用户展示，可以参考alibaba的<a target="_blank" rel="noopener" href="https://github.com/alibaba/x-render">x-render</a>项目(react)，或者<a target="_blank" rel="noopener" href="https://github.com/lljj-x/vue-json-schema-form">vue的版本</a>。</p>
<h3 id="协议关联管理"><a href="#协议关联管理" class="headerlink" title="协议关联管理"></a>协议关联管理</h3><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>brandId</td>
<td>int</td>
<td>品牌id</td>
</tr>
<tr>
<td>deviceType</td>
<td>int</td>
<td>设备类型</td>
</tr>
<tr>
<td>protocol</td>
<td>string</td>
<td>支持协议</td>
</tr>
</tbody></table>
<p><strong>该表用于用户添加设备时，选取可用协议。</strong></p>
<p>对于标准HTTP/MQTT接口，brandId设为0，表示该协议支持所有品牌。</p>
<p>之所以独立成表，是因为存在贴牌设备的问题，比如小米电视贴牌海信，实际通信协议是海信，即多对一可能。</p>
<p>也可以增加一个deviceModels字段，允许精确到设备型号进行筛选，不过维护列表的工作量较大。</p>
<h3 id="协议参数管理"><a href="#协议参数管理" class="headerlink" title="协议参数管理"></a>协议参数管理</h3><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>protocol</td>
<td>string</td>
<td>协议代码</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>该配置的名称</td>
</tr>
<tr>
<td>tenantId</td>
<td>string</td>
<td>租户id</td>
</tr>
<tr>
<td>gatewayId</td>
<td>int</td>
<td>0-云端直连，其他：边缘网关的id</td>
</tr>
<tr>
<td>data</td>
<td>json</td>
<td>对应protocol中的params</td>
</tr>
</tbody></table>
<p>gatewayId决定设备是直接上云，还是通过边缘网关上云。</p>
<p><strong>当设备仅支持局域网接入，而平台和设备无法在一个局域网时，只能通过边缘网关上云</strong>。如果设备可以使用第三方的边缘网关上云，则我方只需要对接该网关，此时视为<strong>直接上云</strong>，录入设备时协议选择对应硬件网关的协议即可；当平台和设备部署在同一个局域网时，也视为直接上云；<strong>仅当采用自研软边缘网关接入时</strong>，这里需要选择边缘网关的id。</p>
<p>data为一个动态表格，用户选择协议后填入依赖的参数。不同协议对应的字段需求不同，所以data内容不固定。对于前端，可以</p>
<p>由于协议依赖往往涉及到第三方的密码之类，所以必须进行数据隔离，加入tenantId字段。<strong>但是有时该协议参数为所有租户公用</strong>，此时可以设置tenantId为空，比如所有租户的视频都要接入我方租用的海康的ISC平台。当然</p>
<p>另外就是一些允许客户自定义的参数，如采集周期，限流设置等，也可以在协议参数里设置。</p>
<p>该表由运营人员或者售后人员维护，<strong>一般用户可能无法维护</strong>，涉及技术参数较多。</p>
<h3 id="设备事件管理"><a href="#设备事件管理" class="headerlink" title="设备事件管理"></a>设备事件管理</h3><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>string</td>
<td>事件唯一标示，如：EVENT_UPLOAD_ENV</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>事件中文名，如：环境数据上传</td>
</tr>
<tr>
<td>data</td>
<td>json schema</td>
<td>事件的json描述，通过该字段对接入数据进行validate和normalize</td>
</tr>
<tr>
<td>priority</td>
<td>int</td>
<td>事件优先级，不同优先级的消息将被push到不同的kafka topic</td>
</tr>
</tbody></table>
<p>data示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;title&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;personId&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;人员标识&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;一般是人员的身份证号&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;photo&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;图像&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;base64或者url&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;毫秒级时间戳&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;temperature&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;number&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;体温&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;保留一位小数&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;minimum&quot;</span>: <span class="number">30</span>,</span><br><span class="line">      <span class="attr">&quot;maximum&quot;</span>: <span class="number">45</span>,</span><br><span class="line">      <span class="attr">&quot;unit&quot;</span>: <span class="string">&quot;摄氏度&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;gender&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;性别&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;enum&quot;</span>: [</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;enumDesc&quot;</span>: <span class="string">&quot;女\n男&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;required&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;personId&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遵从json schema标准语法，也可以根据情况进行扩展。比如上文扩展了一个“unit”字段，表示标量值的单位。扩展字段需要单独出一套语法规范给对接人员参考。</p>
<p>即使是同一事件，不同设备的参数也可能不同。比如考勤上报时，有的设备有体温数据，有的没有。data一般为同一事件可能数据的<strong>并集</strong>。</p>
<h3 id="设备命令管理"><a href="#设备命令管理" class="headerlink" title="设备命令管理"></a>设备命令管理</h3><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>string</td>
<td>命令唯一标示，如：CMD_TOGGLE_SWITCH</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>命令中文名，如：切换开关状态</td>
</tr>
<tr>
<td>data</td>
<td>json schema</td>
<td>命令的json描述，表示下达命令时需要额外填入的字段，比如status: 1或者0表示切换开还是关</td>
</tr>
</tbody></table>
<p>显然命令和事件可以合并到一个表里，不过命令不支持优先级（除非设备本身支持）。</p>
<p>即使是同一命令，不同设备需要的参数也可能不同。比如开关可能支持定时参数，此时一般将命令<strong>拆分</strong>成多个。如这里可以拆分成即时开关和定时开关两个命令。</p>
<p>设备命令原则上不支持重试/上线重发机制，因为可能存在一定的危险性。即所有命令默认都是<strong>即时</strong>的，如果此时设备不在线，不会尝试在设备重新上线后再发送。</p>
<h3 id="事件-命令关联管理"><a href="#事件-命令关联管理" class="headerlink" title="事件/命令关联管理"></a>事件/命令关联管理</h3><p>即设备支持哪些命令和事件的关联。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>deviceType</td>
<td>int</td>
<td>设备类型，为0表示所有设备都支持</td>
</tr>
<tr>
<td>brandId</td>
<td>int</td>
<td>设备品牌</td>
</tr>
<tr>
<td>modelIds</td>
<td>[int]</td>
<td>设备型号列表</td>
</tr>
<tr>
<td>protocolIds</td>
<td>[int]</td>
<td>协议列表</td>
</tr>
<tr>
<td>events</td>
<td>[string]</td>
<td>支持事件列表</td>
</tr>
<tr>
<td>cmds</td>
<td>[string]</td>
<td>支持命令列表</td>
</tr>
</tbody></table>
<p>这里的设计比较粗犷，为了方便配置，这里在选择设备类型和品牌后，其他的都可以多选。如果要细化配置，可以针对每个type-brand-model指明事件参数，但是这样工作量较大，没有太大必要。</p>
<p>该关联对于规则引擎与用户交互，是必须的。对于应用层，也可以通过该关联直接判断设备是否支持某个命令。</p>
<h3 id="边缘网关管理"><a href="#边缘网关管理" class="headerlink" title="边缘网关管理"></a>边缘网关管理</h3><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>str</td>
<td>中文名称</td>
</tr>
<tr>
<td>tenantId</td>
<td>str</td>
<td>边缘网关对应的租户</td>
</tr>
</tbody></table>
<p>其实边缘网关就是一个特殊的设备，与平台采用标准MQTT通信，所以服务端也会自动生成访问的token。</p>
<h3 id="资产管理"><a href="#资产管理" class="headerlink" title="资产管理"></a>资产管理</h3><p>资产是设备的聚合，严格来说这并不是接入平台需要考虑的功能。产品可以根据需求自行发挥。</p>
<p>但是需要注意的是，某些设备之间是有关联的。比如视频设备和视频AI设备，可以在录入视频AI设备时，在扩展字段里选择关联设备。</p>
<h2 id="设备接入"><a href="#设备接入" class="headerlink" title="设备接入"></a>设备接入</h2><p>设备接入采用模块化设计，每个**模块(Module)<strong>对应一个上文中</strong>协议(Protocol)**。</p>
<p>可以将每个模块写在单独的jar包里，通过bean的生命周期启动(@PostConstruct)/停止(@PreDestroy)服务，最后部署的服务只需要引入实际设备对应模块就可以完成最小化部署。但是saas情况下不宜采用该方案，jar包会非常多；也可以全部写在一个服务里，然后通过<code>ConditionOnBean</code>之类的方式通过配置动态开关服务，唯一缺陷是最终的package体积可能会比较大；或者两种方法进行折中，根据某种方式（如设备品牌）聚合一下。</p>
<p>一个Module的设计如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IModule</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onInit</span><span class="params">()</span></span>; <span class="comment">//初始化时启动模块协议</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>; <span class="comment">//模块关闭时清理资源</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Command command)</span></span>; <span class="comment">//接受外部命令</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">//通用的命令，应用平台通过HTTP/RPC/Kafka发送过来</span></span><br><span class="line">    <span class="keyword">private</span> String code; <span class="comment">//对应上文中的设备命令，如CMD_TOGGLE_SWITCH</span></span><br><span class="line">    <span class="keyword">private</span> String reqId; <span class="comment">//请求的唯一ID，用于链路追踪</span></span><br><span class="line">    <span class="keyword">private</span> String reqSrc; <span class="comment">//请求来源服务的标示，如智慧工地/智慧园区的标示等</span></span><br><span class="line">    <span class="keyword">private</span> Device target; <span class="comment">//目标设备</span></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//请求的具体参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sync; <span class="comment">//同步命令还是异步命令，默认异步</span></span><br><span class="line">  	<span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> CompleteFuture&lt;String&gt; result; <span class="comment">//请求结果，非传入值。请求为同步命令时，用于将异步转化为同步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Integer type; <span class="comment">//设备类型</span></span><br><span class="line">    <span class="keyword">private</span> String sn; <span class="comment">//设备序列号</span></span><br><span class="line">    <span class="keyword">private</span> Long brandId; <span class="comment">//设备品牌ID</span></span><br><span class="line">    <span class="keyword">private</span> Long modelId; <span class="comment">//设备型号ID</span></span><br><span class="line">    <span class="keyword">private</span> String protocol; <span class="comment">//设备协议</span></span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Module一般是基于Netty编码，Bean的名字就是protocol的名字。</p>
<p>有一个专门的module负责处理与应用平台通信，接收到平台命令时，通过target的protocol找到对应的通信模块，调用<code>call</code>将命令转发过去即可。Netty一般在自己的线程里处理命令，需要同步返回结果的，将结果放入result字段；异步返回结果的，也可以通过reqId+reqSrc实现。</p>
<p>事件上报同样由专门的模块实现，其他模块调用该模块的<code>call</code>来上报事件。为了防止数据丢失，必须保证数据放入kafka(ack all)后，再对设备端发ack. 当然设备端必须有重发机制，否则无论如何设备数据都可能丢失。</p>
<p>如果简化设计，可以使用kafka全异步通信，将所有Event和Command都是通过kafka来传递。<strong>以下会按全异步设计来写具体方案</strong>，同步设计只需要用上面的<code>result</code>进行转换，也可以在平台外面wrap一层同步的HTTP/RPC接口。</p>
<p>接入层架构图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs2bfhy91vj31gi0rejvv.jpg"></p>
<p>这里标准MQTT还是选择用emqx作为broker，thingsboard内置的mqtt服务与thingsboard平台深度绑定，且不支持共享订阅，不建议使用。边缘端设备接入可以用emqx-edge（即设备本身就是用mqtt协议，且接入层部署在边缘端时）。</p>
<p>按着saas的设计，接入层全部在云端部署，此时接入集群共同订阅kafka的Command即可；还有一种方案是接入层整体部署在用户的本地（上面虚框部分），此时<strong>接入层整体视为一个边缘网关</strong>，云端只需要部署标准MQTT集群，该集群会将命令通过MQTT下发给接入层集群。接入层集群使用MQTT的<strong>共享订阅</strong>功能完成负载均衡。</p>
<p>如果用户有多个园区/工地/社区要管理，那么在园区/工地/社区本地部署接入层，在用户机房部署其他部分，这种设计可以派上用场。如果仅仅是单独的园区/工地/社区，那么全部部署在本地，此时设备全部视为直接上云。</p>
<p>接入层可以任意水平扩展，但是如果设备与服务端使用的是长连接，此时如果想要给设备发送命令，就必须知道设备实际连接到哪个结点了。下文会在<strong>设备状态维护</strong>里谈到该问题的解决方案。</p>
<h3 id="接入模块作为客户端"><a href="#接入模块作为客户端" class="headerlink" title="接入模块作为客户端"></a>接入模块作为客户端</h3><p>理想情况下，接入模块应该是作为服务端，设备主动向平台发送数据。但是实际上设备很多时候连接了厂商的中控平台或者云平台。此时连接模块只能作为客户端，主动向中间平台请求数据。</p>
<p>该场景下仍然可以用netty来写模块，但是存在一个额外的问题。即<strong>多服务结点时，如何进行通信任务的分发</strong>。</p>
<p>这里需要一个额外的服务来完成该工作，假设名为scanner。当租户添加的协议参数同时满足：</p>
<ol>
<li>这是一个客户端模式的协议；</li>
<li>该协议为云端接入（非边缘模式）；</li>
</ol>
<p>则将该协议视为一个待分发的客户端。scanner定期扫描所有待分发的客户端，将其push到kafka Command topic里，视为一种特殊的Command。获取到Command的接入层结点call协议对应的接入模块，模块则根据协议参数增加定时任务或者建立长连接等。</p>
<p>模块接受Command之后，要标记该客户端为已分发（比如采用redis kv标记）；在该服务节点关闭前，需要清除该标记，以便scanner重新分发该客户端。</p>
<p>边缘网关采用的是硬分配原则，所以边缘端从本地数据库扫描到客户端模式的协议配置后，直接启动服务即可。参考<strong>边云数据同步</strong>部分设计。</p>
<h2 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h2><h3 id="设备事件上报"><a href="#设备事件上报" class="headerlink" title="设备事件上报"></a>设备事件上报</h3><p>上文已经写了上报的大致流程，上报到kafka的数据结构大致如下(json格式)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: <span class="string">&quot;EVENT_UPLOAD_DATA&quot;</span>, <span class="comment">//事件编码</span></span><br><span class="line">  <span class="string">&quot;ts&quot;</span>: <span class="number">1234567890</span>, <span class="comment">//毫秒级Unix时间戳</span></span><br><span class="line">  <span class="string">&quot;deviceId&quot;</span>: <span class="number">12345</span>, <span class="comment">//设备id</span></span><br><span class="line">  <span class="string">&quot;tenantId&quot;</span>: <span class="string">&quot;abc&quot;</span>, <span class="comment">//设备此时的租户id</span></span><br><span class="line">  <span class="string">&quot;data&quot;</span>:&#123; <span class="comment">//具体的事件数据</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据事件的优先级投递到不同的topic. 在投递之前可以根据event的schema进行校验和规格化（也可以不处理，后续再进行流式处理）。</p>
<p>kafka后接不同消费者组，再对数据进行进一步处理，本平台会实现数据落库以及推送到规则引擎。大数据组或者应用组也可以订阅该数据做进一步处理，如推送给大屏/客户端等。</p>
<h3 id="设备连接状态维护"><a href="#设备连接状态维护" class="headerlink" title="设备连接状态维护"></a>设备连接状态维护</h3><p>设备连接状态的变化其实就是一类特殊的事件，比如可以命名为<code>EVENT_DEVICE_TOGGLE_ONLINE</code>.</p>
<p>设备在线一般是通过应用层心跳来维持的，如果采用长连接，可以用netty的<code>IdleStateHandler</code>来设置最小活跃周期（通过读取协议参数）；但是如果是HTTP短链接的话，每次请求可能router到不同接入层结点上，因此不能在内存中维持。此外如果有查询平台/租户所有在线设备等统计需求，也不能只将连接状态维护在内存里。</p>
<p>这里设计一个简单的解决方案：使用lua脚本，将设备最近一次心跳时间记录在redis zset里（可以根据最小活跃周期设置多个zset）。然后定时（周期比最小活跃周期小即可）扫描这些zset，确定心跳过期后认为设备离线。</p>
<p>设置设备在线示例代码如下，假设记录的key为<code>iot:device:heartbeat:120</code>，其中120表示心跳过期时间为120秒：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- argv[1]: 设备id, argv[2]: 心跳时间戳</span></span><br><span class="line"><span class="comment">-- ret[1]: 是否由离线变为在线</span></span><br><span class="line"><span class="keyword">local</span> old_ts = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;zrank&#x27;</span>, KEYS[<span class="number">1</span>], argv[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">local</span> update_ts = <span class="built_in">tonumber</span>(argv[<span class="number">2</span>])</span><br><span class="line"><span class="comment">-- 如果原来的值不存在，直接更新；或者时间戳更新</span></span><br><span class="line"><span class="keyword">if</span> old_ts == <span class="literal">nil</span> <span class="keyword">or</span> old_ts &lt; update_ts <span class="keyword">then</span></span><br><span class="line">  redis.call(<span class="string">&#x27;zadd&#x27;</span>, KEYS[<span class="number">1</span>], update_ts)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> old_ts == <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Redis6.2之后可以直接用<code>GT</code>选项完成上述功能，不再需要lua.</p>
</blockquote>
<p>离线扫描直接用<code>ZRANGE</code>配合<code>ZREMRANGEBYSCORE</code>即可完成，也是使用lua脚本保证原子性。</p>
<p>当然也可以用其他方案来完成该任务，比如<code>etcd</code>的<code>watch</code>等，可以根据平台选型来实现。上述方案是个单点方案，有更好的方案欢迎提出。</p>
<p>对于长连接，当连接建立时，需要在redis中记录设备和服务结点的<strong>双向映射</strong>。这样当Command的消费者结点接收到命令但是发现设备连接在另一个结点时，可以将命令转发到另一个结点。</p>
<p>当服务结点关闭时，长连接模块的清理方法需要将所有关联结点设置为离线，然后逐个断开连接并关闭服务。</p>
<p><strong>注意</strong>：一般不考虑服务端宕机或者网络断开问题，否则要处理的边界条件会大幅增加。</p>
<h3 id="应用命令下发"><a href="#应用命令下发" class="headerlink" title="应用命令下发"></a>应用命令下发</h3><p>如上文所述，平台可以提供HTTP/RPC/Kafka等多种通信方式供其他平台下发命令，但是考虑到某些命令的执行周期会很长（如向人脸识别设备下发1w个人员信息），全部设计为异步接口更加泛用。</p>
<p>假设这里使用Kafka通信，所有接入层结点对Command成为一个消费者组。接入层结点有一个专门的模块，假设为<code>module-command</code>,订阅该topic，接收到Command之后查找Module，调用<code>call</code>发送命令. 如果是长连接模块（短链接模块直接执行命令即可），该模块要检查连接是否在本结点，如果是的话直接执行就行；不是的话要考虑转发或者返回”目标不在线”的错误信息。</p>
<p>注意上面未考虑接入层服务拆分问题。如果拆分的话，还需要一个protocol到服务节点的映射。比如<code>std-mqtt</code>和<code>std-http</code>是两个独立的服务，组成一个Command Topic的消费组，前者拿到命令发现设备实际使用后者通信，那么需要一个机制找到后者服务节点，然后转发命令。</p>
<p>理论上所有的命令都一个返回值，由于是全异步通信，<code>Command</code>类中就不再需要<code>result</code>字段。netty线程中执行完命令后，直接调用<code>module-command</code>的<code>call</code>，后者将数据push到kafka中专门应答的topic中即可。</p>
<p>设计数据结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">//通用的命令，应用平台通过HTTP/RPC/Kafka发送过来</span></span><br><span class="line">    <span class="keyword">private</span> String code; <span class="comment">//对应上文中的设备命令，如CMD_TOGGLE_SWITCH</span></span><br><span class="line">    <span class="keyword">private</span> String reqId; <span class="comment">//请求的唯一ID，用于链路追踪</span></span><br><span class="line">    <span class="keyword">private</span> String reqSrc; <span class="comment">//请求来源服务的标示，如智慧工地/智慧园区的标示等</span></span><br><span class="line">    <span class="keyword">private</span> Device target; <span class="comment">//目标设备</span></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//请求的具体参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  	<span class="keyword">private</span> String cmd; <span class="comment">//对应请求中的code</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">int</span> status; <span class="comment">//状态码</span></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//应答描述，一般是错误信息</span></span><br><span class="line">    <span class="keyword">private</span> String reqId;</span><br><span class="line">    <span class="keyword">private</span> String reqSrc;</span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//具体数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用层订阅该应答的topic，即可获取命令执行的最终结果。可以按reqSrc分为不同业务的topic，避免数据混乱。</p>
<h3 id="运行时配置变更"><a href="#运行时配置变更" class="headerlink" title="运行时配置变更"></a>运行时配置变更</h3><p>显然，在接入层通信过程中，应用平台依然可以修改设备信息、协议参数等关键配置，这些配置变更必须立刻通知到接入层。</p>
<p>一个方案是使用maxwell/canon等组件订阅mysql binlog，发现对应表格数据变化后，向kafka Command Topic中push一条特殊的命令。订阅端清除redis中相关的缓存，并通知对应的模块断开原来的连接等。</p>
<p>如果不想引入额外的组件，也可以在变更save到db之后，手动执行该操作。</p>
<h3 id="边云数据同步"><a href="#边云数据同步" class="headerlink" title="边云数据同步"></a>边云数据同步</h3><p>当接入层在边缘侧时，需要考虑的问题要更加复杂一些。</p>
<p>边缘网关启动后，需要定时拉取该网关关联的设备列表和对应的协议参数，并将其save到本地数据库（以保证边云连接断开时，边缘端仍可正常运行）。可以根据数据最后更新的时间(update_time)，决定本地对应条目是否需要更新；或者通过update_time进行筛选增量拉取；</p>
<p>当配置参数变更时，消费端发现该设备/协议项是通过边缘端接入的，则会直接向mqtt broker publish qos为0对应的信息，边缘端也可以根据该消息进行即时处理。</p>
<p>但是由于边缘端和云端的连接无法保证稳定性，边缘端简单设计的话，<strong>仅进行定时拉取即可</strong>。</p>
<p>对于一般的Command，消费者模块发现protocol配置为边缘接入时，也可以直接publish到边缘网关对应订阅的topic，qos也应该为0。</p>
<h3 id="微服务设计汇总"><a href="#微服务设计汇总" class="headerlink" title="微服务设计汇总"></a>微服务设计汇总</h3><ul>
<li>接入层。接入层整体作为一个集群，可以全部写在一起，也可以根据需求进行拆分。比如std-mqtt和std-http都作为单独服务。拆分后注意接入层内部需要转发平台的命令；</li>
<li>单实例的scanner服务（负责客户端模式下的任务的分发），和心跳检测服务，可以写在一起。可以考虑其他方案；</li>
<li>web服务。基本的API供其他服务调用（根据技术选型，也可能是rpc服务）；如果平台需要做一个界面，相关接口也写在这里；</li>
<li>物联数据落库服务。订阅kafka数据流并落入时序数据库；</li>
<li>规则引擎服务。设计见下文；</li>
</ul>
<h3 id="组件使用汇总"><a href="#组件使用汇总" class="headerlink" title="组件使用汇总"></a>组件使用汇总</h3><h4 id="kafka相关设计汇总"><a href="#kafka相关设计汇总" class="headerlink" title="kafka相关设计汇总"></a>kafka相关设计汇总</h4><p>综上所述，kafka至少设计以下topic：</p>
<ul>
<li>事件上报的topic. 根据优先级可以分为多个；如果有些数据需要经过kafka stream处理后再落库，可以单独划一个优先级；</li>
<li>命令下发的topic. 所有接入层服务结点组成一个消费者组；运行时配置变更可以作为特殊的Command，比如code为<code>CONF_</code>前缀；</li>
</ul>
<h4 id="redis相关设计汇总"><a href="#redis相关设计汇总" class="headerlink" title="redis相关设计汇总"></a>redis相关设计汇总</h4><ul>
<li>设备配置信息会缓存在redis中，避免与设备通信时频繁查库。当收到配置变更Command时清除缓存；</li>
<li>设备连接状态会缓存在redis中，可以查询到在线设备id；</li>
<li>设备与服务结点的长连接映射会存储在redis中，可以查找到设备连接在哪个服务节点上，也可以查找服务节点上具体连接了哪些设备；</li>
</ul>
<p>部分功能可以使用别的组件来实现，redis只是说能做。</p>
<h4 id="mqtt设计汇总"><a href="#mqtt设计汇总" class="headerlink" title="mqtt设计汇总"></a>mqtt设计汇总</h4><ul>
<li>注意使用emqx的共享订阅，保证服务节点之间的负载均衡；</li>
<li>标准MQTT接入只有事件上报的topic和命令下发的topic；</li>
<li>边缘网关使用mqtt通信，必须设置非内存的store，保证qos&gt;0的数据不会遗失；</li>
<li>边缘网关应用层心跳使用qos为0的通信，其他信息使用qos为1的信息；</li>
<li>边缘网关只关心自己负责设备相关的配置的变更，所以推送的topic中应含有边缘网关的id，如<code>iot/edge/1/device/update</code>，表示给ID为1的边缘网关推送设备信息变更，<code>iot/edge/2/protocol/create</code>给ID为2的边缘网关推送新增的协议信息；当然<strong>如果采取定时拉取的方案，不必设计这块的东西</strong>；</li>
</ul>
<h2 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h2><p>规则引擎的设计较为复杂，需要进一步调研，thingsboard的规则引擎其实是一个数据流处理器（类似flink）。</p>
<p>这里给出原来的设计方案以供参考，该方案较为简单，但是可以满足一般的设备联动和自定义告警需求。</p>
<p>通过设备模型抽象，上文中已经明确了设备支持的事件和命令。规则引擎本质上就是when <em>event</em> happens，if match some <em>condition</em>, then do <em>actions</em>.</p>
<p>我们已经有了event和action，以及他们的参数。那么前端就可以根据这些参数，通过一门DSL，就可以组合出<code>condition</code>。简单的DSL可以直接使用json.</p>
<p>比如condition这里使用mongo query表达式，例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>:&#123;<span class="string">&quot;$lt&quot;</span>: <span class="number">8</span>&#125;, <span class="comment">//key1小于8; $lt(&lt;), $gt(&gt;), $le(&lt;=), $ge(&gt;=), $ne(!=), $eq(=)</span></span><br><span class="line">    <span class="string">&quot;key2&quot;</span>:&#123;<span class="string">&quot;$ge&quot;</span>: <span class="string">&quot;37.3&quot;</span>&#125;, <span class="comment">//key2大于等于37.3</span></span><br><span class="line">    <span class="string">&quot;$or&quot;</span>:[&#123;<span class="string">&quot;key3&quot;</span>:&#123;<span class="string">&quot;$regex&quot;</span>: <span class="string">&quot;\d&#123;3&#125;&quot;</span>&#125;&#125;,&#123;<span class="string">&quot;key4&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;], <span class="comment">//key3满足正则，或者key4=3，使用$like表示字符串包含</span></span><br><span class="line">    <span class="string">&quot;key4&quot;</span>:&#123;<span class="string">&quot;$in&quot;</span>:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;, <span class="comment">//key4=1或2或3</span></span><br><span class="line">    <span class="string">&quot;key6.0&quot;</span>: <span class="number">10</span>, <span class="comment">//数组第一个元素是10</span></span><br><span class="line">    <span class="string">&quot;key7.subKey1&quot;</span>:&#123;<span class="string">&quot;$lt&quot;</span>: <span class="number">10</span>&#125;, <span class="comment">//object的子元素小于10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端根据用户选择拼凑出条件，就是规则引擎的可视化。</p>
<p>我们定义一个命令(deviceType=0)，比如叫<code>SYSTEM_NOTIFY</code>，表示系统通知。参数是通知方式（短信、微信、电话等），通知频率等。用户设置condition，并选择该命令，这就完成了通用的告警配置。</p>
<p>用户也可以配置condition之后，选择一个设备，配置action，就可以完成设备联动。比如当环境监测仪上报的光照度&lt; nLux之后，就打开某个路灯的照明开关。</p>
<p>复杂的规则引擎支持规则链，或者等待多个条件等等。可以考虑借鉴工作流来实现。</p>
<h2 id="其他相关平台"><a href="#其他相关平台" class="headerlink" title="其他相关平台"></a>其他相关平台</h2><ul>
<li>鉴权服务。该平台不开放给普通用户使用，因此本设计方案里不涉及用户和权限部分。可以与其他内部平台共享同一套鉴权系统；另外需要注意，上文设计时仅考虑了单业务系统，如果是多业务系统租户id可能重复的时候，还要加上一个业务系统ID字段；</li>
<li>数据分析服务。接入平台只负责将物联数据写入到TSDB，数据分析需要独立的服务；</li>
<li>大数据流处理。原始的物联数据可能无法满足业务层的需要，一个典型的例子是人脸识别只能上报人员身份标示（如身份证号），该数据需要和业务系统中人员数据关联起来，才能被业务使用。此时就需要使用kafka streams等技术进行二次加工数据；</li>
<li>全平台日志审计。关键业务数据的增删改需要记录操作日志，以免出现问题时无法溯源；</li>
<li>推送系统（实时/离线，多渠道）。某些物联数据可能需要实时推送给客户端；规则引擎的告警也需要实时推送。显然应该有一个公用的推送系统；</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iot/" rel="tag"># iot</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/23/gradle%E9%80%9F%E6%88%90/" rel="prev" title="gradle速成">
                  <i class="fa fa-chevron-left"></i> gradle速成
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/01/springcloud-alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="springcloud-alibaba学习笔记">
                  springcloud-alibaba学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tryao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://yiuterran.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yiuterran.github.io/2021/06/28/iot%E6%8E%A5%E5%85%A5%E5%B9%B3%E5%8F%B0%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88/";
    this.page.identifier = "2021/06/28/iot接入平台落地方案/";
    this.page.title = "iot接入平台落地方案";
    };
  NexT.utils.loadComments('#disqus_thread', () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://yiuterran.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
