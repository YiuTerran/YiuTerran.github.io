<!DOCTYPE html>
<html>
<head>
    

    

    



    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    
    
    <title>读书笔记-数据密集型应用设计 | 无心呢喃 | 个人技术类文章博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="database,note">
    <meta name="description" content="本书原著为英文，即《Designing Data-Intensive Applications》，主要讲述数据库底层原理和设计思路，读来受益颇多。 基本原则我们期望数据系统可靠、可扩展、可维护，但是由于 CAP 原理的限制，我们无法完全做到这些，因此在设计分布式数据库系统时，必然存在各种考量与限制。这里的数据库，指的不是狭义的关系型数据库，或者非关系型数据库。而是一种广泛的Data System，">
<meta name="keywords" content="database,note">
<meta property="og:type" content="article">
<meta property="og:title" content="读书笔记-数据密集型应用设计">
<meta property="og:url" content="http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/index.html">
<meta property="og:site_name" content="无心呢喃">
<meta property="og:description" content="本书原著为英文，即《Designing Data-Intensive Applications》，主要讲述数据库底层原理和设计思路，读来受益颇多。 基本原则我们期望数据系统可靠、可扩展、可维护，但是由于 CAP 原理的限制，我们无法完全做到这些，因此在设计分布式数据库系统时，必然存在各种考量与限制。这里的数据库，指的不是狭义的关系型数据库，或者非关系型数据库。而是一种广泛的Data System，">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-19T01:03:46.489Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记-数据密集型应用设计">
<meta name="twitter:description" content="本书原著为英文，即《Designing Data-Intensive Applications》，主要讲述数据库底层原理和设计思路，读来受益颇多。 基本原则我们期望数据系统可靠、可扩展、可维护，但是由于 CAP 原理的限制，我们无法完全做到这些，因此在设计分布式数据库系统时，必然存在各种考量与限制。这里的数据库，指的不是狭义的关系型数据库，或者非关系型数据库。而是一种广泛的Data System，">
    
        <link rel="alternate" type="application/atom+xml" title="无心呢喃" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">tryao</h5>
          <a href="mailto:yaotairan@gmail.com" title="yaotairan@gmail.com" class="mail">yaotairan@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/YiuTerran" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">读书笔记-数据密集型应用设计</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">读书笔记-数据密集型应用设计</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-02-16T01:49:36.000Z" itemprop="datePublished" class="page-time">
  2018-02-16
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#基本原则"><span class="post-toc-number">1.</span> <span class="post-toc-text">基本原则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可靠性"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">可靠性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可扩展性"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">可扩展性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可维护性"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">可维护性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据模型和查询语言"><span class="post-toc-number">2.</span> <span class="post-toc-text">数据模型和查询语言</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#关系型数据模型"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">关系型数据模型</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#存储和取回"><span class="post-toc-number">3.</span> <span class="post-toc-text">存储和取回</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SSTABLE-和-LSM-TREE"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">SSTABLE 和 LSM-TREE</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-TREE"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">B-TREE</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多列索引"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">多列索引</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#全文索引"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">全文索引</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内存数据库"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">内存数据库</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OLTP-与-OLAP"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">OLTP 与 OLAP</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#编码与迭代"><span class="post-toc-number">4.</span> <span class="post-toc-text">编码与迭代</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二进制序列化"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">二进制序列化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JSON-XML-和二进制编码"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">JSON, XML 和二进制编码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HTTP-RPC-MQ"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">HTTP, RPC, MQ</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#副本集"><span class="post-toc-number">5.</span> <span class="post-toc-text">副本集</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主从模式"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">主从模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#副本-log-的实现原理"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">副本 log 的实现原理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#副本-log-的问题"><span class="post-toc-number">5.1.2.</span> <span class="post-toc-text">副本 log 的问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多-leader-模式"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">多 leader 模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#leaderless-模式"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">leaderless 模式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#分片"><span class="post-toc-number">6.</span> <span class="post-toc-text">分片</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#路由"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">路由</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#事务"><span class="post-toc-number">7.</span> <span class="post-toc-text">事务</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原子性"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">原子性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#隔离性"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">隔离性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Read-Commited"><span class="post-toc-number">7.2.1.</span> <span class="post-toc-text">Read Commited</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#分布式系统的问题"><span class="post-toc-number">8.</span> <span class="post-toc-text">分布式系统的问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#局部失败"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">局部失败</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#时序问题"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">时序问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#系统阻塞"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">系统阻塞</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#共识和一致性"><span class="post-toc-number">9.</span> <span class="post-toc-text">共识和一致性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#严格一致性-strict-consistency"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">严格一致性(strict consistency)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#顺序一致性-sequential-consistency"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">顺序一致性(sequential consistency)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#因果一致性-causal-consistency"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">因果一致性(causal consistency)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线性一致性-Linearizability"><span class="post-toc-number">9.4.</span> <span class="post-toc-text">线性一致性(Linearizability)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#弱一致性-weak-consistency"><span class="post-toc-number">9.5.</span> <span class="post-toc-text">弱一致性(weak consistency)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CAP-理论"><span class="post-toc-number">9.6.</span> <span class="post-toc-text">CAP 理论</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#全序广播"><span class="post-toc-number">9.7.</span> <span class="post-toc-text">全序广播</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二阶段提交"><span class="post-toc-number">9.8.</span> <span class="post-toc-text">二阶段提交</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三阶段提交"><span class="post-toc-number">9.9.</span> <span class="post-toc-text">三阶段提交</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#paxos-算法"><span class="post-toc-number">9.10.</span> <span class="post-toc-text">paxos 算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Phase-1"><span class="post-toc-number">9.10.1.</span> <span class="post-toc-text">Phase 1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Phase-2"><span class="post-toc-number">9.10.2.</span> <span class="post-toc-text">Phase 2</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-读书笔记-数据密集型应用设计"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">读书笔记-数据密集型应用设计</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-02-16 08:49:36" datetime="2018-02-16T01:49:36.000Z"  itemprop="datePublished">2018-02-16</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>本书原著为英文，即《Designing Data-Intensive Applications》，主要讲述数据库底层原理和设计思路，读来受益颇多。</p>
<h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><p>我们期望数据系统可靠、可扩展、可维护，但是由于 CAP 原理的限制，我们无法完全做到这些，因此在设计分布式数据库系统时，必然存在各种考量与限制。这里的数据库，指的不是狭义的关系型数据库，或者非关系型数据库。而是一种广泛的<code>Data System</code>，包括消息队列、DBMS, NOSQL, 以及图数据库、列式数据库等等负责存储数据的组件。</p>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>考量以下几点：</p>
<ol>
<li>提供正常正确的功能；</li>
<li>错误容忍性；</li>
<li>性能；</li>
<li>安全认证；</li>
</ol>
<p>其中错误容忍性又分为硬件错误（如断电、内存不足、磁盘不足、网络断开等）和软件错误（各种软件 bug 等），以及人工错误（操作错误、输入错误等）</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>当组件性能、容量无法满足需求时，组件能够通过扩展的方式满足需求，这就是所谓的可扩展性。</p>
<p>书中举了 Twitter 的 timeline 设计作为例子，我们知道 timeline 展示的是 follower 的发布的状态，那么不考虑任何优化的情况下，设计如下：如果用关系型来描述的话，需要一个 user 表，一个用户 follow 关系表，一个 tweets 表，对于 user id 为 1 的用户，其首页的 timeline 生成是</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.* <span class="keyword">from</span> tweets t <span class="keyword">join</span> follow f <span class="keyword">on</span> f.follower_id=t.user_id <span class="keyword">where</span> f.user_id=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> t.created_at <span class="keyword">limit</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>显然 tweets 表会迅速膨胀成一个超大的表，这种设计不能满足性能的需求。于是这里使用了一种优化结构：将每个用户的 timeline 独立存储，用户新的 post 插入 tweets 表后，还要将这个 tweet 插入用户的 timeline 缓存中。除了这个方案以外，还有很多其他的方法，比如使用消息队列。用户 ins/del po, follow/unfollow some one 触发事件，需要对 timeline 进行重新生成。</p>
<p>性能描述的常用指标包括：延迟、吞吐量、响应时间等。平均响应时间有时候并不能很好的描述性能，中位数响应时间更合适（一半的请求小于该时间，另一半的大于该时间）。中位数响应时间即 50%分位响应时间，如果要求的更严格，可能需要使用 95%分位响应时间等，甚至 99.9%分位。99%分位以上的又被称为尾部延迟。</p>
<p>一般将可扩展性分为水平扩展和垂直扩展，两者可以结合起来。如果系统具有自动根据负载进行扩展的能力，这种系统是所谓的“弹性系统”。</p>
<h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>这里主要指的是系统本身简单可维护，且代码清晰易改动。可维护性显然不仅仅是架构的问题，涉及到方方面面吧，比如：</p>
<ol>
<li>系统健康监控</li>
<li>错误跟踪系统</li>
<li>自动化部署</li>
<li>完善的文档系统</li>
<li>优雅的抽象，模块化</li>
<li>持续迭代</li>
</ol>
<p>显然这些其实项目管理的内容。</p>
<h2 id="数据模型和查询语言"><a href="#数据模型和查询语言" class="headerlink" title="数据模型和查询语言"></a>数据模型和查询语言</h2><p>常见的数据模型包括关系型数据模型，文档性数据模型，网络数据模型和图数据模型</p>
<h3 id="关系型数据模型"><a href="#关系型数据模型" class="headerlink" title="关系型数据模型"></a>关系型数据模型</h3><p>关系型数据库是最经典的数据库，也是最常用的模型。在 1 对多环境下，文档性数据模型（一般是类 JSON 格式）可以很好的描述数据关系；但是多对多就比较麻烦了。而且现在已有的文档型数据库中，大部分是不支持不同表格之前关联查询的。</p>
<p>随着技术的进步，关系型数据库和文档型数据库产生了一些融合，现在关系型数据库一般也支持 JSON 字段了，虽然这种有效的融合本质上是反模式的。</p>
<p>关系型数据库统一使用 sql 语言操作，sql 是一种 DML，类似 CSS。文档型、图数据库的查询语言不通用由各个实现自己定义。当然随着分布式关系型数据库的发展，sql 仍然是最重要的数据操纵语言。</p>
<p>图数据模型比较复杂，按着一般图的概念，结点和关系构成了整张图。属性图模型的设计如下：</p>
<ol>
<li>一个图中会记录节点和关系</li>
<li>关系可以用来关联两个节点</li>
<li>节点和关系都可以拥有自己的属性</li>
<li>可以赋予节点多个标签(类别)</li>
</ol>
<p>在某些应用场景里（如社交网络），图数据库在描述关系上具有无与伦比的优势，可以大幅简化查询设计。除了属性图外，还有其他图数据模型实现，如 Triple-Stores，将数据存为主谓宾三元组，一般是使用 SPARQL 进行查询；然后还有 RDF 数据模型，一般使用 XML 语言描述</p>
<h2 id="存储和取回"><a href="#存储和取回" class="headerlink" title="存储和取回"></a>存储和取回</h2><p>本章阐述了数据库底层存储和查询的原理。文中先举例了一个 KV 数据库最简单的实现，将数据存在文件中，写入就直接写在文件尾部，读取则用 tail 值（逆序查找即可）。这种直接写到文件尾部的只读文件，本质上是一种 log.</p>
<p>当然这个实现有个很明显的问题：写入很快，但是查找很慢。如果 key 根本不存在，需要遍历整个文件，因此需要引入索引(index)的实现。比如这里将所有的 key 存入一个红黑树或者哈希表，然后存放对应的偏移量作为值，即成为一个索引。</p>
<p>由于数据存入文件是 append only 的，很容易导致磁盘空间耗尽，因此需要周期性的对文件进行压缩。对于 KV 数据库而言，每个 key 值最后对应的 value 是唯一的，所谓的压缩其实就是将对同一个 key 的赋值仅保留最后一个。显然这个过程可以分片同步进行（类似归并排序的流程），也可以放在后台进行，不影响前台正常的读写。</p>
<p>哈希索引是最快的查询索引，仅需要 O(1)时间，但是问题是哈希表必须存入内存之中，一般多用在内存数据库中。而对于存储在磁盘上的数据，一般使用 b-tree 来存放。</p>
<h3 id="SSTABLE-和-LSM-TREE"><a href="#SSTABLE-和-LSM-TREE" class="headerlink" title="SSTABLE 和 LSM-TREE"></a>SSTABLE 和 LSM-TREE</h3><p>如果将上述实现的 KV 数据库中的 KEY 排序，得到的表就是所谓 SSTABLE(SORTED STRING TABLE)，这种表格归并和查找的速度都明显超过普通的文件，这样就不再需要额外的完整索引来进行查找加速（但是可能需要稀疏索引来加速搜索）。</p>
<p>SSTABLE 的存储可以使用各种平衡二叉树，比如红黑树或者 AVL 树。为了性能考虑，先把数据写入内存表（即缓存），然后等到内存中的数据达到一定的阈值后，再序列化写入硬盘，写入硬盘的部分也可以分片。最后，周期性运行数据压缩，消除冗余 key 值。</p>
<p>SSTABLE 的设计比较完善，考虑到掉电问题，还需要对内存表的操作保留一份日志，以便进行错误恢复。可以使用 WAL（WRITE AHEAD LOG)日志来记录。</p>
<p>以上思路，就是所谓的 LOG STRUCTURED MERGE-TREE, 即 LSM-TREE，Lucence 这个搜索引擎在底层即使用了这种数据结构，然后 Level DB 等数据库也使用了这种数据结构，Level 指的是数据归并压缩时使用的策略。将 key 根据范围划分为不同的 Level，从而用来加速归并和压缩的速度。</p>
<p>可以使用<code>Bloom filters</code>算法加速搜索，确认 key 不存在。</p>
<h3 id="B-TREE"><a href="#B-TREE" class="headerlink" title="B-TREE"></a>B-TREE</h3><p>b-tree 是磁盘存储数据时最常用的索引结构，这是一种自平衡多路查找树，特点是能够保持较低的高度。</p>
<p>b-tree 将数据抽象成固定大小的 block 或者说 page，一般是 4Kb 每页（机器硬盘），每次读写一页。每个 page 里面是数据和指向其他 page 的指针，这棵树也有一个根节点，是每次搜索的开始。每页包含指向子叶的指针数，即所谓的“分支因子”（一般是几百个）。page 里面是索引列的有序键值，但是这个键值是稀疏的排序，树的高度被保证为较小的值，这样通过 3~4 层的搜索能够找到大部分 key 值。</p>
<p>还有一些常见的其他的优化措施，如 WAL 啊，多线程保护（latch）啊，写时复制啊，或者使用变体的分型树、<code>b+</code>树、<code>b*</code>树等.</p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>简单的实现是直接将多列拼接成同一个 key，复杂情况使用其他优化的数据结构。</p>
<p>GIS 中的地理位置索引，包含经度和纬度，一般使用 R-TREE 来实现。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>对于搜索引擎，需要的是进行模糊查询，一般的索引技术不能满足需求。数据结构以外，还需要结合分词技术、机器学习等其他技术才能满足各种需求。</p>
<h3 id="内存数据库"><a href="#内存数据库" class="headerlink" title="内存数据库"></a>内存数据库</h3><p>随着内存价格的降低和容量的增加，全内存型数据库也开始涌现。对于 IO 性能要求较高的场合，大量使用内存数据库（如游戏）。关系型内存数据库常见的如 voltdb，KV 型的如 redis 等。</p>
<p>内存数据库速度快的原因不是把所有数据都放在内存里，因为传统关系型数据库也有 cache，这个优势并没有想象的那么大。内存数据库避免了序列化/反序列化的额外负担，同时还可以实现一些无法在磁盘中实现的功能，如 Redis 中的 set, zset 等。</p>
<p>内存数据库可以存放超过内存大小的数据，简单来说就是将最近未使用的数据写入磁盘，需要的时候再重载入内存，类似操作系统的虚拟内存技术。随着非易失性内存技术的发展，最终硬盘和内存将会殊途同归，也就不用再考虑这些问题了。</p>
<h3 id="OLTP-与-OLAP"><a href="#OLTP-与-OLAP" class="headerlink" title="OLTP 与 OLAP"></a>OLTP 与 OLAP</h3><p>前者用于大量写入，对事务的性能要求较高，后者用于数据分析。</p>
<p>刚开始的时候都用普通 db，随着量级的发展，OLAP 一般使用独立的数仓来完成。数仓将 OLTP 数据库中的数据进行 ETL，存入专门用来数据分析的 db. OLAP 数据库和 OLTP 使用不同的优化方式，前者使用了一些其他的索引技术。</p>
<p>OLAP 一般使用星型模型/雪花模型，将多维度数据聚合到事实表中，从而避免大量 join 查询。此外，OLAP 会使用列式数据库，列式可以更方便的进行数据压缩，对查询进行更好的优化。</p>
<p>列式数据库的写入很麻烦，一般使用 LSM-TREE 进行优化，先写入内存，异步写入文件。</p>
<p>除了这些技术以外，还有很多其他辅助手段用来提升 OLAP 的查询速度，如物化视图。</p>
<h2 id="编码与迭代"><a href="#编码与迭代" class="headerlink" title="编码与迭代"></a>编码与迭代</h2><p>本章主要讨论消息序列化的编码结构（不是字符编码），以及这些编码形式如何应对字段变更、滚动升级等需求。</p>
<h3 id="二进制序列化"><a href="#二进制序列化" class="headerlink" title="二进制序列化"></a>二进制序列化</h3><p>各个语言有自己的二进制序列化机制，但是一般并不推荐使用，其兼容性、适用性和安全性都有一些问题。不过二进制序列化速度一般比纯文本格式要快一些。</p>
<h3 id="JSON-XML-和二进制编码"><a href="#JSON-XML-和二进制编码" class="headerlink" title="JSON, XML 和二进制编码"></a>JSON, XML 和二进制编码</h3><p>一般情况下，JSON 和 XML 足够用了，除了一些缺点。JSON 的问题是只支持浮点数，且无法指定精度，有溢出风险。XML 的话就是有点过于笨重，但是支持 XPATH 这种高级检索语言。基于 JSON 和 XML 也有一些二进制编码。</p>
<p>如果使用 RPC 通信，可以考虑使用二进制编码，例如 Thift 或者 Protobuf，此外还有 Avro 等.</p>
<p>显然 JSON 是通过字段的 key 值来保持兼容性的，而 XML 则使用属性。而 Thift 和 Protobuf 则使用的是字段的 tag，旧的代码读到不认识的 tag，就会忽略掉对应的字段，从而保持兼容性。当然，这里有个问题，新增的字段不可定义为<code>required</code>，就如同给关系型数据库新增字段不能为 NOT NULL 且没有 DEFAULT 值一样。如果是移除字段，也只能移除<code>optional</code>的，且该字段的 tag 将来一定不能被重复使用。如果想要修改字段类型，就有一定的风险，需要视字段间的兼容性和精度而定。</p>
<p>对于 Avro，其 IDL 里面根本没有 tag，读方的 schema 和写方的 schema 可以不一致，avro 会自动处理兼容的字段，忽略不兼容的字段（或者赋默认值）。Avro 是为了给 Hadoop 使用的，这种设计的目的是为了关系型数据库增减字段时不需要人工手动修改 IDL 的 schema.</p>
<h3 id="HTTP-RPC-MQ"><a href="#HTTP-RPC-MQ" class="headerlink" title="HTTP, RPC, MQ"></a>HTTP, RPC, MQ</h3><p>基于不同传输协议的数据封装讨论，都是一些开发者耳熟能详的知识点，不再赘述。</p>
<h2 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h2><p>副本集一般有三种架构：single leader，multi leader， no leader</p>
<h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>即单主模式，写到 leader，leader 通过 log 或者 Stream 同步到 follower，读的时候可以从从库读，也可以从主库读（即读写分离）。</p>
<p>主库到从库的同步可能是同步或异步的，后者会出现读出的数据是 old data 的情况。</p>
<p>故障恢复：如果从库 down 了，重启后通过日志重新同步即可；但是如果主库 down 了，就需要重新选举一个 leader，否则整个服务就不可用了。选举的过程包括：</p>
<ol>
<li>认定 leader down，一般使用 timeout</li>
<li>选举新的 leader</li>
<li>使用选举出来的新 leader</li>
</ol>
<p>需要解决的问题：</p>
<ol>
<li>如果 follower 与 leader 之间的数据同步是异步进行的，old leader down 之前可能还没来得及将数据同步给其他 follower，那么新的 leader 就有丢失一部分数据。old leader 恢复后，需要成为 follower，并丢弃这部分未同步的内容；这种丢弃是很危险的，有可能出现各种问题；</li>
<li>可能会出现两个节点都以为自己是 leader 的问题，即所谓的脑裂问题；</li>
<li>判定服务 down 的 timeout 确定；</li>
</ol>
<h4 id="副本-log-的实现原理"><a href="#副本-log-的实现原理" class="headerlink" title="副本 log 的实现原理"></a>副本 log 的实现原理</h4><p>对于关系型数据库而言，一种显而易见的实现方式是将所有写语句(CREATE, UPDATE, DELETE, ALTER)都记录到日志里，follower 依序重复执行这些语句。但是这里可能有一些问题：</p>
<ol>
<li>有些函数是不可能重复执行的，如 RAND(), NOW()之类的；</li>
<li>如果依赖已经存在的数据，必须保证执行顺序，这意味着不能并发执行 log 中的语句；</li>
<li>有副作用的语句在各个副本集中造成的副作用可能不一致；</li>
</ol>
<p>这些问题可以通过将非确定性的语句修改为确定性的（即将 NOW()的结果记录）来解决，MySQL 则直接使用了 ROW-BASED 将行数据覆盖的方法（又称为 logic log）来解决。还可以使用 WAL 这种直接修改字节的方法来进行，这种方法最大的问题是要求所有的 follower 必须和 leader 保持同样的二进制结构（如存储引擎），这会导致无法平滑升级服务。</p>
<h4 id="副本-log-的问题"><a href="#副本-log-的问题" class="headerlink" title="副本 log 的问题"></a>副本 log 的问题</h4><ol>
<li>读写一致性问题。用户写完以后立刻读，必须保证读到的是刚写的数据，但是由于从库的同步是异步的，所以可能会出问题；</li>
<li>数据时序性问题。如果用户使用了一系列的读（落到不同的 follower 上），可能由于同步进度的问题，导致部分读到的是新数据，部分是旧数据；</li>
</ol>
<h3 id="多-leader-模式"><a href="#多-leader-模式" class="headerlink" title="多 leader 模式"></a>多 leader 模式</h3><p>如果存在多个数据中心（异地），所有的写都发往单一 leader 显然有效率问题，这时候各个 data center 各有一个 leader 是更合适的，所有的写发往 local 的 leader，然后由 leader 之间相互同步。显然，多 leader 之间的数据同步会引发各种问题。</p>
<p>还有一种特殊的多 leader 模式：如果应用需要能够离线工作（如日历），但是设备没有连接上英特网，那么此时设备本地的 db 就是 leader. 其实也可以联想多人使用 svn/git 等版本控制系统共同编辑同一个文件，然后再 commit 到服务器时出现的各种问题，其中最麻烦的就是：conflict，数据之间的冲突问题（除非对文件加锁）。</p>
<p>解决方案：</p>
<ol>
<li>避免这种情况，根据用户的 ip 地址就近选择数据中心，一般都是这样解决的。但是如果用户换了地方，原来账号的体验就会比较差了。</li>
<li>自动解决冲突：数据加入时间戳（自增 ID），使用最新的值解决冲突；或者允许用户自定义冲突解决代码，当发现冲突时自动调用这段代码；</li>
<li>手动解决冲突：数据库记录下所有冲突，当该值被阅读时，返回所有值，提示用户手动解决冲突，CouchDB 使用该方案；</li>
</ol>
<p>多 leader 之间同步拓扑：</p>
<ol>
<li>环形拓扑：每个 leader 只同步给另外一个 leader，这里要注意单节点挂掉的问题；</li>
<li>星形拓扑：使用一个 root 节点，其他所有节点与该节点进行同步，root 节点可能挂掉；</li>
<li>all to all，每个节点和其他所有节点拓扑，这时要注意时序问题；</li>
</ol>
<h3 id="leaderless-模式"><a href="#leaderless-模式" class="headerlink" title="leaderless 模式"></a>leaderless 模式</h3><p>这种模式没有主从，客户端的读写同时发送给所有的结点。如果有节点 down 掉，写请求会忽略挂掉的结点；当结点恢复后，会出现数据不一致的问题，客户端从多份节点数据中选取时，选取 version number 较大的数据，作为准确的数据返回。</p>
<p>上面这种宕机情况，数据修复方案：</p>
<ol>
<li>客户端修复，客户端发现某个节点的数据版本落后于其他节点，那么就将最新版本的数据写入其他节点；这个的问题就是有些数据可能不怎么会被读到，数据长时间存在不一致的问题；</li>
<li>多节点之间自动同步，异步，无特定拓扑顺序，所以可能滞后很多；</li>
</ol>
<p>多节点同时读取还有读取/写入数量，以及可信度的问题。一般而言，一共有 n 个结点，至少写入 w 个节点保证写成功，至少读取 r 个节点保证读成功，则必须有<code>w+r&gt;n</code>才能保证系统的可靠性。一般情况下，n 是一个奇数，<code>w=r=(n+1)/2</code>. 当然可以根据实际需要调整 w 和 r，以协调自己所需的性能和可靠性。</p>
<p>显然 leaderless 模式会遇到和 multi-leader 类似的问题：时序问题、冲突问题，解决方案也类似。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>数据分片与副本集不同，是将数据进行垂直切分，也就是所谓的 sharding 技术，经常与副本技术配合使用。对于 KV 型数据库，常见的分区策略包括：</p>
<ol>
<li>按 key 值范围，缺点是分区可能不均匀；</li>
<li>按 key 值的 hash 值范围，解决不均匀问题。此时要注意 hash 值必须唯一，如 md5。这会引入一个新问题：无法范围查询 key 值，因为他们不再毗邻。Cassandra 的解决方案是用联合主键，如果第一位确认，后面的还能保证都在一个 partition 上，如(user_id, timestamp)；</li>
<li>即使使用了 hash，有时候也会遇到单点过热问题，如社交网络上某个名人的行为总会引起大的数据波动，这个只能在应用层解决了；</li>
</ol>
<p>对于 RDBMS，除了主键，一般还有其他索引，如果访问需要通过多个索引字段进行，分片的方式就需要斟酌了。如果涉及不当，请求只能发给所有分片，然后再归并查询结果，严重影响效率。</p>
<p>除了根据某个字段分区，还可以使用多个字段分区，如先根据 kay range，再根据另一个 key 的 hash 值，这样就可以避免单 key 热点造成的负载不均衡；</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>客户端如何知道将请求发送到哪个 shard 上才是最重要的问题，这涉及到“服务发现”技术。一般有以下几种方案：</p>
<ol>
<li>客户端随便连到一个 shard，该分片会自动将请求发送到对应的分片上。使用<code>gossip protocol</code>之类的技术可以实现该功能；</li>
<li>使用外部配置管理器，如 zookeeper；客户端从该管理器中获得对应的分片信息；</li>
<li>静态配置。如果是简单的 mod shard，可以使用该方案；</li>
</ol>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>关系型数据库一般都有 ACID 特性，其中 A 指的是原子性，即一件事要么发生，要么不发生，即使这件事里面包含多个动作；I 指的是隔离性，不同事务之间不相互影响，不会出现脏读等问题；D 指的是持久化能力；而 C 指的是一致性，这个其实无法由数据库来保证，在分布式系统里，最终一致性需要很多条件才能保证。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一般数据库都能保证单对象写入的原子性，但是只有少部分数据库能保证多对象写入的原子性。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>最强的隔离性是将并行操作串行化（使用悲观锁），但是这样有很严重的性能问题。那么根据不同的隔离级别，有以下几种弱隔离性实现：</p>
<h4 id="Read-Commited"><a href="#Read-Commited" class="headerlink" title="Read Commited"></a>Read Commited</h4><ol>
<li>只能读到已提交的事务（无脏读）</li>
<li>只能对已提交事务的值进行改写（无脏写）</li>
</ol>
<p>数据库一般默认使用 MVCC 技术完成 2。该等级下数据库会出现 nonrepeatable read 问题，该问题一般情况下没啥影响，但是如果数据库同时在进行备份，可能中间状态就丢了。使用 MVCC 将隔离级别上升为<code>snapshot iso‐ lation</code>，此时当事务开始时，会获得一个事务全局递增的唯一事务编号，而更新将会被拆分成删除+创建。这样，一个更新操作实际上产生了两个版本的数据。当一个事务开始时，做如下判定：</p>
<ol>
<li>首先确定当前正在进行但还未提交的事务，使用这些事务开始前的数据版本；</li>
<li>已经 rollback 的事务，其数据修改被直接废弃；</li>
<li>事务 ID 号大于当前事务的提交，不管事务有没有提交，忽略其提交结果；</li>
<li>除了上诉情况以外，其他的写入可以被当前事务感知到；</li>
</ol>
<p>这种实现对索引的使用：多个版本同个字段使用索引，使用 B 树时，update 不是直接修改 page，而是产生一个新 page，也就是<code>copy-on-write</code>。</p>
<p>写丢失：两个事务同时写，一个的写入可能会丢失。解决方案：原子写入，或者使用悲观锁。此外部分 db（不含 mysql）实现了 lost update detection，可以自动侦测到该问题。</p>
<p><code>snapshot isolation</code>会导致在一个先读后写的事务里，会导致幻读。如果想要解决这个问题，只能使用<code>serializable isolation</code>，这种隔离的实现方案包括：</p>
<ol>
<li>单线程执行所有事务，这样就自动串行化了。如 Redis、VoltDB（使用存储过程，将读写都写在一起，优化方案）；</li>
<li>2PL，即两阶段锁（悲观锁）。比读写锁更加严格，一旦某个事务想要写入，进入排他状态，禁止其他事务的读写；如果只是读取，需要<code>shared mode</code>，即申请共享锁；</li>
</ol>
<p>将<code>snapshot isolation</code>与<code>serializable</code>结合起来，就是所谓的<code>serializable snapshot isolation</code>，即 SSI，这是一个新算法（2008 年提出），在 PostgreSQL 9.1 以后使用，较有潜力。</p>
<h2 id="分布式系统的问题"><a href="#分布式系统的问题" class="headerlink" title="分布式系统的问题"></a>分布式系统的问题</h2><h3 id="局部失败"><a href="#局部失败" class="headerlink" title="局部失败"></a>局部失败</h3><p>分布式系统某个节点挂掉引起的一系列问题。</p>
<ol>
<li>如果是单主集群，需要重新选举；</li>
<li>需要考虑节点恢复后如何重新纳入集群；</li>
<li>需要考虑如何判定节点挂掉，一般是用网络超时，但是这个值比较难以假定；</li>
<li>考虑单节点阻塞导致的丢包问题；</li>
</ol>
<h3 id="时序问题"><a href="#时序问题" class="headerlink" title="时序问题"></a>时序问题</h3><p>分布式系统不同节点之间的时钟同步。</p>
<ol>
<li>依赖时序策略的影响，如 LWW（可以使用逻辑时钟代替墙上时钟）；</li>
<li>NTP 同步的精确度，NTP 本身的延迟，NTP 服务本身的不可靠性；</li>
<li>Google spanner 的时钟策略，返回一个[least, most]的时钟范围，保证准确的时间落在该范围之内；</li>
</ol>
<h3 id="系统阻塞"><a href="#系统阻塞" class="headerlink" title="系统阻塞"></a>系统阻塞</h3><ol>
<li>GC 引起的 stop the world</li>
<li>单线程阻塞</li>
</ol>
<p>其他原因造成的系统结点卡顿，以至于其他结点访问超时，误以为该节点挂了。</p>
<h2 id="共识和一致性"><a href="#共识和一致性" class="headerlink" title="共识和一致性"></a>共识和一致性</h2><h3 id="严格一致性-strict-consistency"><a href="#严格一致性-strict-consistency" class="headerlink" title="严格一致性(strict consistency)"></a>严格一致性(strict consistency)</h3><p>对于数据项 x 的任何读操作将返回最近一次对 x 进行的写操作的结果所对应的值。</p>
<p>严格一致性中存在的问题是它依赖于绝对的全局时间。对于所有的进程来说，所有写操作都是瞬间可见的，系统维持着一个绝对的全局时间顺序。如果一个数据项被改变了，那么无论数据项改变之后多久执行读操作，无论哪些进程执行读操作，无论这些进程的位置如何，所有在该数据项上执行的后续读操作都将得到新数值。</p>
<h3 id="顺序一致性-sequential-consistency"><a href="#顺序一致性-sequential-consistency" class="headerlink" title="顺序一致性(sequential consistency)"></a>顺序一致性(sequential consistency)</h3><p>任何执行结果都是相同的，就好像所有进程对数据存储的读、写操作是按某种序列顺序执行的，并且每个进程的操作按照程序所指定的顺序出现在这个序列中。</p>
<h3 id="因果一致性-causal-consistency"><a href="#因果一致性-causal-consistency" class="headerlink" title="因果一致性(causal consistency)"></a>因果一致性(causal consistency)</h3><p>当一个读操作后面跟着一个写操作时，这两个事件就具有潜在的因果关系，同样，读操作也与为读操作提供数据的写操作因果相关。没有因果关系的操作被称为并发的。</p>
<p>所有进程必须以相同的顺序看到具有潜在因果关系的写操作，不同机器上的进程可以以不同的顺序被看到并发的写操作。</p>
<p>实现因果一致性要求跟踪哪些进程看到了哪些写操作。这就意味着必须构建和维护一张记录哪些操作依赖于哪些操作的依赖关系图。一种实现方法是版本（向量）时间戳。</p>
<p>几乎所有的分布式系统都支持因果一致性。前面讨论的事务追踪数据过期抛出失败，也就是保证了因果一致性。</p>
<p>使用 Lamport 时间戳可以保证因果一致性，其实现原理如下：</p>
<ol>
<li>不同的结点各有自己的编号 n；</li>
<li>每个结点使用自己的计数器 c；</li>
<li>使用(c, n)表示 lamport 时间戳；</li>
<li>客户端/node 跟踪 c 值，当 node 发现客户端请求的 c 值大于自身 c 值时，立刻将自身 c 值设为请求的 c 值（对客户端亦然）；</li>
<li>定义当 n 相等时 c 值较小的逻辑时间较小；否则 n 值较小的逻辑时间较小；</li>
</ol>
<p>显然 lamport 时间戳定义了一个全序的操作序列。问题在于这个顺序必须在动作执行完成后（即 node 返回后）才能确定下来，这对于某些场合不够用（比如唯一约束）。</p>
<h3 id="线性一致性-Linearizability"><a href="#线性一致性-Linearizability" class="headerlink" title="线性一致性(Linearizability)"></a>线性一致性(Linearizability)</h3><p>所谓线性一致性，指的是对于一个分布式系统的多个副本集，读出的结果永远都是一致的（就好像从唯一一个副本集中读出的一样）。该一致性模型是我们能实现的最强一致性模型，所以又被称为 strong consistency.这种模型假设操作具有一个全局有效时钟的时间戳，但是这个时钟仅具有有限的精确度。要求时间戳在前的进程先执行，换句话说，所有的操作都不是并发的，而是有严格的顺序的（全序）。</p>
<p>单 leader 的副本集群，理论上可以做到线性一致，但是在节点故障的时候可能出现脑裂等问题，此时就会违反线性一致性；而多 leader 节点一定不会是线性一致的，无 leader 集群则不一定，取决于配置（只有 read repair 策略下或许可行，但是这个效率很低。故一般认为不保证。）。另外 LWW 策略必然是非线性的（依赖时钟）。</p>
<p>在某些场景下，只允许线性一致性，比如 leader 选举等。该一致性的性能是最差的。</p>
<h3 id="弱一致性-weak-consistency"><a href="#弱一致性-weak-consistency" class="headerlink" title="弱一致性(weak consistency)"></a>弱一致性(weak consistency)</h3><p>引入同步变量 S，其仅有一个关联操作 synchronize(S)，该操作同步数据存储的所有本地拷贝。</p>
<p>使用同步变量来部分地定义一致性就得到称为弱一致性模型，其具有三个属性：</p>
<ul>
<li>对数据存储所关联的同步变量的访问是顺序一致的；</li>
<li>每个拷贝完成所有先前执行的写操作之前，不允许对同步变量进行任何操作；</li>
<li>所有先前对同步变量执行的操作都执行完毕之前，不允许对数据项进行任何读或写操作。</li>
</ul>
<h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>在网络分区的情况下，一致性和高可用性只能取其一，即所谓 CAP 理论。CAP 理论在最开始时(2000 年)对分布式系统的设计起到了很重要的指导作用，但是现在要考虑的情况要复杂的多，因此一般不再提起该理论。</p>
<h3 id="全序广播"><a href="#全序广播" class="headerlink" title="全序广播"></a>全序广播</h3><p>通过单 Leader 多 Follower 机制，在 Leader 节点上对所有操作进行排序，从而决定了整个操作顺序，并将操作顺序进行广播。</p>
<p>全序广播要求满足如下两个属性总是被满足：</p>
<ul>
<li>可靠的交付,没有消息丢失：</li>
<li>如果消息被传递到一个节点，它将被传递给所有节点。完全有序传递，消息以相同的顺序传递给每个节点。</li>
</ul>
<p>全序广播是异步的：消息保证以固定的顺序可靠地传递，但不能保证何时传递消息（因此存在节点可能落后于其他节点）。而线性化一致性能够保证：每次读操作能够读到最新值的写入。我们可以依托于全序广播，在存储上实现线性化一致性。</p>
<h3 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h3><p>当客户端准备提交事务时，协调者（事务管理器）开始阶段 1：所有参与者进行预提交，根据响应，分为两种情况：</p>
<ol>
<li>所有节点准备完毕（使用 transaction id，完成相关写入）。进入阶段 2，开始真正的 commit；</li>
<li>任一节点未正确响应，进入 abort;</li>
</ol>
<p>二阶段提交无法解决同步阻塞、协调者单点、以及网络故障导致的数据不一致问题。</p>
<h3 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h3><p>改进的二阶段提交，加入了询问机制。</p>
<h3 id="paxos-算法"><a href="#paxos-算法" class="headerlink" title="paxos 算法"></a>paxos 算法</h3><p>paxos 算法是分布式系统实现最终共识的唯一正确算法，raft 等算法只是其变种。他解决的是最终一致性（共识）问题，这个前面提的一致性不是一个概念。其流程如下：</p>
<h4 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h4><ol>
<li><p>A proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors.</p>
</li>
<li><p>If an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.</p>
</li>
</ol>
<h4 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h4><ol>
<li>If the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered nwith a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.</li>
<li>If an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n.</li>
</ol>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-03-19T01:03:46.489Z" itemprop="dateUpdated">2018-03-19 08:03:46</time>
</span><br>


        
        <a href="/2018/02/16/读书笔记-数据密集型应用设计/" target="_blank" rel="external">http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/</a>
        
    </div>
    <footer>
        <a href="http://YiuTerran.github.io">
            <img src="/img/avatar.png" alt="tryao">
            tryao
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/database/">database</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/note/">note</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/&title=《读书笔记-数据密集型应用设计》 — 无心呢喃&pic=http://YiuTerran.github.io/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/&title=《读书笔记-数据密集型应用设计》 — 无心呢喃&source=个人技术类感悟、笔记等，非技术类见微信公众号“叶囊”" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《读书笔记-数据密集型应用设计》 — 无心呢喃&url=http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/&via=http://YiuTerran.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/03/28/kotlin-web开发/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">kotlin web开发</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/01/25/面试复习/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">面试复习纪要.md</h4>
      </a>
    </div>
  
</nav>



    




<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'yiuterran';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <ul class="reward-items">
        
        <li>
            <img src="/img/wechat.png" title="微信打赏二维码" alt="微信打赏二维码">
            <p>微信</p>
        </li>
        

        
        <li>
            <img src="/img/alipay.png" title="支付宝打赏二维码" alt="支付宝打赏二维码">
            <p>支付宝</p>
        </li>
        
    </ul>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
            <span>tryao &copy; 2017 - 2019</span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/&title=《读书笔记-数据密集型应用设计》 — 无心呢喃&pic=http://YiuTerran.github.io/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/&title=《读书笔记-数据密集型应用设计》 — 无心呢喃&source=个人技术类感悟、笔记等，非技术类见微信公众号“叶囊”" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《读书笔记-数据密集型应用设计》 — 无心呢喃&url=http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/&via=http://YiuTerran.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://YiuTerran.github.io/2018/02/16/读书笔记-数据密集型应用设计/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACtElEQVR42u3aMXLjQAwEQP3/077kgkvEmwF2ZQXNyKWiSPaqigsP8HrFx88/x/Mn7777fLXnOybnrw48PDy8xaO/u1x+mxb8fP7zmdES4OHh4V3jzR7ieTmez2+3gdkmhIeHh/cNvLYsnm0hp8p3PDw8vG/g5a/15ysn20n+DHh4eHif5yVhxOZbP8GR5LEXsxY8PDy8+XVes03ik39f6e/h4eHhrbvqbXGctMra7Wf2nH+vg4eHh3eBl79w88dtx63yc4bPiYeHh3eB17adTkUAs6bXbMnw8PDwTvHygYCW1Da32rC43gbw8PDwjvI2pLMFcfJUxWaDh4eHd43XUtuCexgclFtIPWuAh4eHd5SXDw0kC5SU17NoOOrv4eHh4V3gtbnvbCGS4YA88I3ugoeHh3eNtwlS65d1XFLnY1XRvoeHh4d3lLeKShfxazTLELfBhmkHHh4eXsnbl62bELZ+0Y8CCzw8PLyzvDwCmIUF+XjBZhOqfzE8PDy8C7ykQbVpiW2GCYqRAjw8PLwLvFNx7as82sGsNqR4u0ng4eHhHeVtXvSz4YP27vn5eHh4eL/Fa2OCdgg1j27bIhsPDw/vM7x8yGkfSTyfczbwxcPDwzvLmxWseXPr1HjrMCLBw8PDu8Db99nbK+SfbCISPDw8vNu8trRNCuIkxp0V3/UC4eHh4V3j7cvcJITdBLjDjQcPDw/vMq8NTHNGHhy/1gceHh7ePd5PebQNsPxVno8jFMNYeHh4eBd47as2Z+fDAUkjrS2v8fDw8G7z2kBhswHky9RuDP/p7OHh4eFd4LWhQz4aNSvWTwUTeHh4eN/ASwruPBQ4NTrw9nM8PDy8L+O1S5B8az+ggIeHh/cZ3mzE6rkIzgvuPG6o62c8PDy8C7zZf/Sb8YJZEHwsnsDDw8Ob8/4ABGV9gmVk/tEAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };



</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '赶紧回来啊~';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎光临惹!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>
