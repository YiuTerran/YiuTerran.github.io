<!DOCTYPE html>
<html>
<head>
    

    

    



    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    
    
    <title>effective java 读书笔记 | 无心呢喃 | 个人技术类文章博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="java,base">
    <meta name="description" content="创建和销毁对象 用静态工厂方法代替构造器。这里的静态工厂方法不是factory mode，而是一种构造器的替代方法。本条款鼓励设计者在构建一个类时，优先考虑使用static factory method。后者有多个优势：更清晰，更简洁，在参数相同时不需要使用boolean或者enum来进行区分，可以通过register——get方法提供工厂特性（子类）。不过，这种方法和普通的静态方法没有任何语法形">
<meta name="keywords" content="java,base">
<meta property="og:type" content="article">
<meta property="og:title" content="effective java 读书笔记">
<meta property="og:url" content="http://YiuTerran.github.io/2017/06/12/EffectiveJava/index.html">
<meta property="og:site_name" content="无心呢喃">
<meta property="og:description" content="创建和销毁对象 用静态工厂方法代替构造器。这里的静态工厂方法不是factory mode，而是一种构造器的替代方法。本条款鼓励设计者在构建一个类时，优先考虑使用static factory method。后者有多个优势：更清晰，更简洁，在参数相同时不需要使用boolean或者enum来进行区分，可以通过register——get方法提供工厂特性（子类）。不过，这种方法和普通的静态方法没有任何语法形">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-03-31T11:28:49.205Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="effective java 读书笔记">
<meta name="twitter:description" content="创建和销毁对象 用静态工厂方法代替构造器。这里的静态工厂方法不是factory mode，而是一种构造器的替代方法。本条款鼓励设计者在构建一个类时，优先考虑使用static factory method。后者有多个优势：更清晰，更简洁，在参数相同时不需要使用boolean或者enum来进行区分，可以通过register——get方法提供工厂特性（子类）。不过，这种方法和普通的静态方法没有任何语法形">
    
        <link rel="alternate" type="application/atom+xml" title="无心呢喃" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">tryao</h5>
          <a href="mailto:yaotairan@gmail.com" title="yaotairan@gmail.com" class="mail">yaotairan@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/YiuTerran" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">effective java 读书笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">effective java 读书笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-06-12T15:47:02.000Z" itemprop="datePublished" class="page-time">
  2017-06-12
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#创建和销毁对象"><span class="post-toc-number">1.</span> <span class="post-toc-text">创建和销毁对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#object通用方法"><span class="post-toc-number">2.</span> <span class="post-toc-text">object通用方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类和接口"><span class="post-toc-number">3.</span> <span class="post-toc-text">类和接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#泛型"><span class="post-toc-number">4.</span> <span class="post-toc-text">泛型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#枚举与注解"><span class="post-toc-number">5.</span> <span class="post-toc-text">枚举与注解</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#方法"><span class="post-toc-number">6.</span> <span class="post-toc-text">方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#通用程序设计"><span class="post-toc-number">7.</span> <span class="post-toc-text">通用程序设计</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#异常"><span class="post-toc-number">8.</span> <span class="post-toc-text">异常</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#并发"><span class="post-toc-number">9.</span> <span class="post-toc-text">并发</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#序列化"><span class="post-toc-number">10.</span> <span class="post-toc-text">序列化</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-EffectiveJava"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">effective java 读书笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-06-12 23:47:02" datetime="2017-06-12T15:47:02.000Z"  itemprop="datePublished">2017-06-12</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><ol>
<li>用静态工厂方法代替构造器。这里的静态工厂方法不是factory mode，而是一种构造器的替代方法。本条款鼓励设计者在构建一个类时，优先考虑使用static factory method。后者有多个优势：更清晰，更简洁，在参数相同时不需要使用boolean或者enum来进行区分，可以通过register——get方法提供工厂特性（子类）。不过，这种方法和普通的静态方法没有任何语法形式的区别，且静态方法不能被继承（C++中<code>virtual</code>与<code>static</code>不能共存）；</li>
<li>当构造参数非常多时，使用构建器(builder)。我们通常会使用默认构造函数，然后用<code>set</code>方法一一设置属性，如果让<code>set</code>返回<code>this</code>，就可以连续使用<code>set</code>，这就是<code>builder</code>。对于具有“具名参数”语法的语言（如python，C#）这种模式就不是很必要了，对于有<code>default value</code>（如C++）语法的语言，这种模式的使用频率也要低一些。</li>
<li>用私有构造器或枚举强化单例属性。这里给出了一个创建单例的建议：创建一个仅包含单元素的枚举类型，由于java语言特性，枚举直接免费提供了序列化、防止多次实例化等功能，因此可以简洁的解决很多问题。</li>
<li>如果一个类不可实例化，应该将其构造器私有化，这种类一般只是提供静态函数（类似C++中的函数）</li>
<li>尽量少创建新对象，而应该多复用已有对象。这条尤其对immuable的对象很重要，例如String。每次使用<code>new</code>时，对应该仔细考虑是否需要创建一个新的对象，而不是复用以前的对象。当然，对于小对象，这个不需要考虑。正如C++中的传值和传址的差别，小对象使用传值反而更好一些，可以避免许多不必要的麻烦。<br>另外，由于<code>autoboxing</code>的存在，基本类型与装箱基本类型之间会相互转化。但是需要记住，要优先使用基本类型。</li>
<li>消除过期的对象引用。这条主要针对“程序员自己管理内存/池化”的情景。在C++中，我们习惯在<code>free</code> or <code>delete</code>之后，将其置0(<code>nullptr</code>)，这样可以避免后续一些莫名其妙的Bug。java是GC机制的，因此一般不需要这么做。但是，如果自己池化了对象管理机制（例如创建某些数据结构时），就要注意这些问题了。<br>本条款给出的建议中，要注意缓存（比如建了一个全局list/map）中过期的东西记得删除。可以使用<code>WeakHashMap</code>自动管理(当内存中没有其引用对象时自动清除），或者<code>LinkedHashMap</code>的<code>removeEldestEntry</code>手动管理（每次添加新元素时）。对于更加复杂的场景，必须使用<code>java.lang.ref</code><a href="http://www.ibm.com/developerworks/cn/java/j-lo-langref/" target="_blank" rel="noopener">^1</a>.<br>此外，<strong>注册</strong>一个回调方法，但是没有显式取消它，会导致其不断被累积。因此在使用<code>addListener</code>创建函数对象时，请记得<code>removeListener</code>.</li>
<li>避免使用终结器(<code>finalizer</code>）。java使用GC来回收内存，因此终结器的用处不大，更重要的是，终结器的优先级很低，不能保证被及时执行，很容易造成性能bug。比较妥当的是提供显示的终结方法（如<code>close</code>），然后在<code>finally</code>中执行。注意终结方法不应该再抛出异常，而是应该捕获并打印日志。<br>但是用户可能忘记调用显示的终结方法，因此终结器还是可以充当最后的安全保证，当然，这其实是程序不得已使用的方法，应该在日志中使用警告。<br>另外需要注意的是，子类终结器必须显式调用父类的，这点和C++中的自动析构并不一样，请注意。可以考虑使用<code>finalize guard</code>来确保这一点。</li>
</ol>
<h2 id="object通用方法"><a href="#object通用方法" class="headerlink" title="object通用方法"></a>object通用方法</h2><ol>
<li><code>equals</code>方法。C++中，重载<code>==</code>操作符限定在同类之间， 其他的要通过类型转换来进行比较，因此存在非常复杂的显式/隐式类型转换。java中，<code>equals</code>方法的参数必须是<code>Object</code>类型，这意味着所有的对象之间都可以判断是否相等。<code>equals</code>方法的设计必须非常谨慎，要严格遵守自反性、对称性、一致性和传递性这几个特征。</li>
</ol>
<ul>
<li>自反性，意思是x=x恒成立；</li>
<li>对称性，意味着a=b，必须也要b=a. 但是由于参数是<code>Object</code>，很容易无意识的违反这点。一般判断步骤中，首先需要知道这个<code>Object</code>是不是属于这个类（使用<code>instanceof</code>）,严格认为不属于这个类的对象不可能相等（即使是value意义上的相等）。如果需要value意义上的相等，就写一个显式的类型转换方法。</li>
<li>传递性，意味着a=b, b=c则a=c成立。这条在设计类层次结构时很容易被违反。在多层类均可被实例化时，判断这些类之间的相等性往往会出现混乱。</li>
<li>一致性。即相等的永远都相等，不等的永远都不等。这里注意的是判断时不要依赖不可靠的资源；</li>
<li>非空性。这是额外的一个特性，任何对象在任何情况下都不应该与<code>null</code>相等——这是显然的。但是这一步不需要特别写出来，<code>instanceof</code>会替我们做这些的。<br>除了上面的款项以外，还有一些使用技巧：</li>
<li>如果比较流程复杂，可以先用<code>==</code>判断是否是同一个对象；</li>
<li>在比较时注意npt异常；</li>
<li>短路求值与比较顺序；</li>
<li>覆盖<code>hashcode</code>;</li>
</ul>
<ol>
<li><code>hashcode</code>方法。如果覆盖了<code>equals</code>，<strong>必须</strong>同时覆盖<code>hashcode</code>，这是因为相等的对象必须有相同的hash code. 这意味着我们必须为这个类提供一种hash算法，这个活并不简单，不过一般情况下可以这么做：<ol>
<li>选一个非0常数记为result，比如17；</li>
<li>对于<code>equals</code>中涉及的每一个域f(成员变量)，计算其hashcode：<ul>
<li>boolean -&gt; 1 or 0</li>
<li>byte, short, int -&gt; int(f)</li>
<li>long -&gt; int(f^(f&gt;&gt;32))</li>
<li>float -&gt; Float.floatToIntBits(f)</li>
<li>double -&gt; Double.doubleToLongBits(f) -&gt; 按着long计算</li>
<li>对象引用：null -&gt; 0，其他：递归调用hashcode方法</li>
<li>数组：把每个对象当作一个单独的域计算hashcode</li>
</ul>
</li>
<li>result=$31 * result + \Sigma_{i=1}^{\propto}f_i$<br>如果一个域的结果可以通过其他域计算出来，可以不必参与上面的计算过程。<br>如果hash计算非常复杂，可以考虑使用延迟初始化技术。定义一个<code>volatile int hashcode</code>，在对应的method里，先<code>if(hashcode==0)</code>，否则直接返回缓存的结果。</li>
</ol>
</li>
<li><code>toString</code>方法。同C#一样，一般推荐覆盖这个方法，这样<code>print</code>时，会方便很多。</li>
<li><code>clone</code>方法。很遗憾，java的<code>clone</code>不好用——很不好用，它的约定太弱。即使类implement了<code>Cloneable</code>接口，你也不能指望什么。最好的方法是别管这个东西，自己实现一个拷贝构造器，或者拷贝工厂。</li>
<li>考虑实现<code>Comparable</code>接口。这个接口唯一声明了<code>compareTo</code>方法，这是一个泛型方法。如果你需要排序，最好事先这个方法——正如C++中的重载<code>&lt;</code>操作符一样，这是泛型容器排序的基础。显然<code>compareTo</code>需要和<code>equals</code>在判断相等时保持一致。<br>比<code>equals</code>简单的是，<code>compareTo</code>的参数只能和自身类型一样，因为在implements泛型类时，填入的具体参数显然就是这个类自身。</li>
</ol>
<h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><ol>
<li>使类和成员的可访问性最小化。本条和语言无关，所有面向对象设计中，<strong>信息隐藏</strong>的重要性都是一致的。切记尽量少暴露实现细节，保持对外开放性最小。这可以有效减少软件工程的复杂度。<br>有个细节的技巧：数组不可能是public final的， 因为数组本身是可变的。C++中有个蛋疼的<code>const int* const p</code>的问题，指的就是指针的可变性和内容的可变性问题。<br>此外，java默认访问类型是<code>package private</code>的，这和其他语言有区别。</li>
<li>使用<code>getter</code>,<code>setter</code>代替公有成员变量。这条其实并不是那么严格，至少C++中经常可以看到反例。因为写起来实在太麻烦，所以C#引入了属性这种语法糖。</li>
<li><p>设计不可变类。省事起见，如果对性能没有特别大的需求尽量设计不可变类，这种类的所有方法都会返回一个<code>new</code>对象，而不是直接修改对象本身。这种类的设计遵从如下原则：</p>
<ol>
<li>不提供mutator修改对象本身；</li>
<li>保证类不会被继承；</li>
<li>所有域都是不可变的（final）；</li>
<li>所有域都是私有的；</li>
<li>确保对于任何可变组件的互斥访问；</li>
</ol>
</li>
<li><p>复合优先于继承。这条是面向对象的泛用条款，从略；</p>
</li>
<li>要么为继承而设计，要么禁止继承。这条要求在设计一个类时，要明确它是否会被继承。这里强调了一个细节：构造器不可调用可被覆盖的方法。这和C++中<strong>构造函数和析构函数不应该调用虚函数</strong>本质上是一直的，因为对象是从基类到派生类逐级构造的，如果调用虚函数，动态绑定可能不会生效，从而产生undefined的后果；</li>
<li>接口优先于抽象类。显然，也是泛用条款。对于C++而言，没那么明显（因为没有接口），不过全是纯虚函数的类就是接口…</li>
<li>接口只用于定义类型。是的，只应该有public的method，而不要塞进去一堆常量。后者最好用枚举代替。</li>
<li>类层次优先于标签类。标签类就是在构造函数中传入flag，在方法中<code>switch...case</code>，在C语言中，这是常见的设计。但是在面向对象中，显然更适合使用继承来合理安排类结构。</li>
<li>用函数对象表示策略。由于C++11有了<code>std::function&lt;&gt;</code>和<code>lambda</code>，所以函数对象这种累赘的东西一般是用不上了，但是垂垂老矣的java中，还没有这些东西(java8引入lambda了，谢天谢地），一般是写一个接口，然后用匿名函数实现它。</li>
<li>优先考虑静态成员类。nested class最好设计成静态的，这是为了减少对象的数量——非静态类都必须与一个外围实例关联。nested class可以摆脱友元这种东西的困扰，访问所有的成员方法|变量（某种形式的闭包）。但是静态成员类和对象本身无关，所以就只能访问静态方法和静态成员了。</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在C++中，template和oo完全是两种不同的范式，因为C++并没有<code>all is object</code>这种思想，因此没人会觉得<code>vector&lt;basic_string&gt;</code>不是<code>vector&lt;string&gt;</code>的父类有啥问题。java其实也一样，<code>list&lt;string&gt;</code>和<code>list&lt;object&gt;</code>之间也不是继承的关系。泛型使java复杂化，并且失去了优雅。</p>
<ol>
<li>用泛型，不用原生态类型。java从1.5版本引入泛型，c#从1.2开始，C++则一直都有模板这种东西。没有泛型的语言一般都会引入一些很丑陋的类型转换，比如C中的<code>void *</code>。尽量使用泛型而非原生态的类型，如果需要指代任意类型而不关心具体类型，可以用<code>?</code>比如<code>set&lt;?&gt;</code>；此外，<code>instanceof</code>操作符后面必须跟着原生态类型；</li>
<li>消除<code>unchecked warning</code>，对于编译器的抱怨，要好好检查，如果确定没有问题，就使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>关闭这个提醒，受检警告仅存在在语言层面，并非是jvm虚拟机的特性；</li>
<li>优先使用List而不是Array。在C++中，array本质上是一个指针，因此效率比<code>std::vector&lt;&gt;</code>要高上不少；java中<code>Array</code>也比<code>list&lt;&gt;</code>要快一些，但是却更推荐使用后者。<br>java的泛型在运行时其元素类型是被擦除(erase<a href="http://www.infoq.com/cn/articles/cf-java-generics" target="_blank" rel="noopener">^2</a>)的，这点和C++完全不同（为了历史兼容性做出的妥协）。因此<strong>数组是运行时安全但编译时不安全的，泛型则相反</strong>。最后，最好不要同时使用泛型和数组，这会让你蛋疼无比——如果真的需要泛型数组，必须同时使用强制类型转换和<code>SuppressWarnings</code>技术。</li>
<li>优先考虑泛型和泛型方法。</li>
<li>使用<code>set&lt;? extends Object&gt;</code> or <code>set&lt;? super String&gt;</code>这种技巧来完成某些动作。助记符是<strong>PECS</strong>,就是说，把这个对象当生产者使用时，用<code>extends</code>，反之，用<code>super</code>。<br>在返回的时候，仍然使用普通类型，而不是通配符。<br>本条对于类库编写者比较重要。</li>
<li>优先使用类型安全的异构容器。本条通过一些奇技淫巧完成一个容器里面同时存放多种类型(异构，通过<code>class&lt;?&gt;</code>实现)，但是又能保证类型安全(通过<code>type.cast</code>实现)这一目标。</li>
</ol>
<h2 id="枚举与注解"><a href="#枚举与注解" class="headerlink" title="枚举与注解"></a>枚举与注解</h2><p>java的枚举有点难用，不如C#那么强大，也不如C/C++那么简洁。简单来说，每一个枚举值都是该类（枚举）的一个实例，相当于一种工厂方法，因此枚举对象可以直接调用枚举类的方法。</p>
<ol>
<li>枚举的所有域都应该是私有final的（需要的时候提供公有的访问函数）；可以通过<code>values</code>方法访问所有的枚举值（依照声明顺序）。对于每一个枚举值在后面加上<code>{}</code>，里面是<strong>特定于常量的方法实现</strong>，可以通过在枚举类中声明一个抽象方法，在常量中再进行覆盖来实现对不同枚举值的特殊操作（<code>switch(this)</code>这种方法更适用于控制外部传入的不可控的变量的方法中）。<br>如果在枚举值后面加上初始化表达式，调用该常量时会自动使用该表达式调用构造函数（但是显然我们不能直接调用构造器），比如<code>MONDAY(&quot;mon&quot;)</code>这种.<br>PS: 这里给了一个有趣的技巧：使用<code>%n</code>保证换行符的跨平台性，有些类似python中的<code>os.linesep</code>.</li>
<li>如果不给枚举赋值，默认使用序列（0，1，2…），可以使用<code>ordinal</code>方法取得该序列的int值。当然，最好别依赖于这种自动生成的东西，而是明确赋值…</li>
<li>用<code>EnumSet</code>代替位域，主要使用<code>EnumSet.of</code>创建枚举set，用来取代依靠位运算得出的集合特性。不过，这种方法只是可读性好一些，如果需要做存储或者与提供API，还是希望使用int。</li>
<li>用<code>EnumMap</code>代替序数索引。可以将一个<code>enum</code>直接传入<code>EnumMap&lt;enum,Object&gt;</code>中，<code>enum</code>的所有常量值都会转化为<code>EnumMap</code>的<code>key</code>，这其实就是普通的<code>map</code>，但是做了优化。</li>
<li>枚举不是可扩展的，但是我们可以使用接口来变相实现这种可扩展性。简单来说，就是枚举实现接口，然后在需要的时候，使用接口来声明枚举而不是相反。</li>
<li>注解优先于命名模式。注解的声明需要导入<code>java.lang.annotation.*</code>，然后使用<strong>元注解</strong>来标明该注解的属性。例如<code>@Retention</code>, <code>@Target</code>，注解类的必须是<code>@interface</code>类型。如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public @interface Test&#123;</span><br><span class="line">    Class&lt;? extend Exception&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test(&#123;IndexOutOfBoundException.class, NullPointerException.class&#125;)</span><br><span class="line">public static void example()&#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试时:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(m.isAnnotationPresent(Test.class)&#123;</span><br><span class="line">    test++;</span><br><span class="line">    try&#123;</span><br><span class="line">        m.invoke(null);</span><br><span class="line">    &#125;catch(Throwable wrappedExc)&#123;</span><br><span class="line">        Throwable exc = wrappedExc.getCause();</span><br><span class="line">        Class&lt;? extends Excetption&gt;[] excTypes=</span><br><span class="line">            m.getAnnotation(Test.class).value();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>注解并不会改变代码原本的含义（和python的装饰器完全不同），但是可以使对象经过某些工具的特殊处理（用于反射）。<br>显然一般程序员是不需要自定义注解类型的，除了某些设计工具平台的人以外。</p>
<ol>
<li>坚持使用<code>Override</code>注解。这是一种良好的变成习惯，不再赘述。</li>
<li>用标记接口定义类型。标记接口很罕见，最常见的是<code>Serializable</code>，它只是一个接口，并没有规定任意方法。换言之，这只是一个空接口。</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>检查参数的有效性。即防御性编程，对于公有方法，应该在Javadoc中使用<code>@throws</code>标明在违反约定时会抛出什么异常；对于非导出方法，设计者自己知道会传入什么参数，因此应该使用<code>assert</code>来进行错误检测。</li>
<li>必要时使用保护性拷贝。java的对象本质上都是c++中的指针或引用，因此如果对象本身是可变的，即使参数是不可变的，也可能因为某些意外导致对象被修改。比较简单的方法是使用深拷贝（值拷贝）摆脱这种引用的关系，这在C++中是比较明显的：传值还是传址的问题，但是java中如果不留意很容易忘掉这一点。</li>
<li>谨慎设计方法签名。本条款说了一些设计方法的技巧和忌讳，包括：<ul>
<li>命名要谨慎</li>
<li>尽量保持接口最小，而不是提供很多快捷方式</li>
<li>避免过长的参数列表（4个以下）</li>
<li>如果上述条款不可避免，使用builder（参见前文）</li>
<li>参数类型优先使用接口</li>
<li>flag尽量使用enum而不是boolean</li>
</ul>
</li>
<li>慎用重载。有个原则是：永远不要导出两个具有相同<strong>参数数目</strong>的重载方法。如果方法使用可变参数，那么尽量不要重载它。如果违反上述两条规定，干脆给方法起不同的名字（如同在C语言中那样）。</li>
<li>慎用可变参数。和其他语言一样，可变参数为<code>printf</code>而生，但是实际上自己需要写的并不多，大部分情况下传入一个列表或者使用泛型可以解决应用问题。可变参数本身有一定的性能约束：传入可变参数隐式创建并初始化了一个数组。</li>
<li>返回0长度的数组或集合，而不是null。这是一条设计上的经验，在非C语言环境下，返回null往往得不偿失——需要单独写语句进行分析，而不能直接迭代。如果担心性能问题，可以使用<code>Collections.emptyList()</code>等方法返回不可变的空集，如果是数组，可以自己创建一个不可变的<code>static final</code>成员变量。</li>
<li>为所有的导出API写文档注释。尤其是在替别人写类库的时候，这条非常重要。必须明确标注哪些是可能会改变的，哪些是兼容的。</li>
</ol>
<h2 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h2><ol>
<li>使局部变量的作用域最小化。这点和C++、C#一致，C语言则是习惯把所有变量声明放在最前面（因为C只有基本数据和结构，且一般更习惯使用指针），python则不需要声明。</li>
<li>for-each优先于for。同所有语言一致，C++11中引入类似语法，C#和python用<code>in</code>关键字. 但是for-each是不能修改容器本身的，因此在必须要的时候还是要使用for。</li>
<li>了解和使用类库。应该熟悉<code>java.lang</code>和<code>java.util</code>中的内容。</li>
<li>不要使用<code>float</code>和<code>double</code>进行精确计算。如果需要精确的小数计算，应该使用<code>BigDecimal</code>，或者自己处理小数点，用<code>int</code>或<code>long</code>。</li>
<li>基本类型优先于装箱类型。由于装箱类型表示对象，因此用<code>==</code>判断两者之间的相等性总是错误的。当混合两者运算时，装箱类型就会自动拆箱。尽可能使用基本类型以避免不停的装箱、拆箱造成的性能损失。在如下场合必须使用装箱类型：<ul>
<li>集合的key和value；</li>
<li>泛型的参数；</li>
<li>进行反射方法调用时；</li>
</ul>
</li>
<li>如果其他类型更适合，不要使用字符串。例如，不要用”True”来代替<code>true</code>这种。</li>
<li>字符串连接问题。使用<code>StringBuilder</code>代替<code>String</code>，提高性能。</li>
<li>通过接口引用对象。这样更加灵活，但是必要的时候你可能需要进行类型转换。如果是基于类的框架，则使用基类更加合适。</li>
<li>接口优先于反射。反射的性能实际上是很差的，但是在必要的时候会非常有用。其中<code>Class a=Class.forname(&quot;xxx&quot;)</code>，然后使用<code>a.newInstance()</code>这种方法比较常见。</li>
<li>谨慎的使用native method. JNI允许java调用C/C++来访问特定的基于平台的sdk接口。但是，如果仅仅为了提高性能，并不提倡非要使用这种技术。</li>
<li>谨慎优化。写出好的程序，如果存在性能问题，则使用性能分析工具去分析它，再针对瓶颈进行优化。</li>
<li>遵守命名习惯。java的命名习惯和C#基本一致（而python和C++基本一致），java不喜欢下划线，而C++不喜欢驼峰。当然，一般常量还是都用全大写中间用下划线的表示方式。</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>java的异常分为<code>checked</code>和<code>unchecked</code>两类，后者是<code>RuntimeExcception</code>或者<code>Error</code>的子类，如果程序抛出这种异常，可以不加以捕获而编译通过。<br>通常情况下，应该使用标准异常。且，只在真正的异常情况下使用异常。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ol>
<li><code>synchronized</code>和<code>volatile</code>关键字的使用。前者类似C#中的<code>lock</code>，后者意思同C。C语言中虽然没有线程，但是有中断和信号。</li>
<li>避免过度同步。如果需要并发集合，那就使用语言内置的并发集合，而不要自己使用<code>synchronized</code>关键字加锁。<code>CopyOnWriteArrayList</code>是一种写时复制的并发容器，类似<code>ConcurrentArrayList</code>。如果类库使用者可以外部同步，那么设计类的时候就不要设计成内部同步的（这是C++的设计原则之一——效率最高）。如果修改了静态域，由于外部用户无法自己加锁，因此类的内部必须加锁。尽量不要从同步区域内部调用外来方法。</li>
<li><code>executor</code>和<code>task</code>优先于线程。这点类似于C#，尽量不要使用抽象程度较低的线程，而是更加漂亮简洁的其他高级类。在<code>java.lang.concurrent</code>里包含了已经封装好的比较通用的线程模型，尽量使用它们而不是自己去写。</li>
<li>并发工具优先于<code>wait</code>和<code>notify</code>。类似上一条，优先使用高级工具。</li>
<li>慎用延迟初始化。本条目给出了几个好的建议：<ol>
<li>正常初始化优先于延迟初始化；</li>
<li>使用同步方法；</li>
<li>如果需要性能优化，静态域延迟初始化使用一个static class作为holder，这样在第一次访问这个静态类时，所需要的域才会被初始化；</li>
<li>如果需要性能优化，实例域延迟初始化最好使用双重检查模式。这时候域必须被声明为<code>volatile</code>的，而且习惯上使用一个局部变量来优化对域的检查。</li>
</ol>
</li>
<li>不要使用<code>Thread.yield</code>，直接用<code>Thread.sleep(1)</code>就好。java的线程调度器不可靠，不要使用线程优先级来调度。</li>
<li>不要使用java线程组，这个技术已经过时了…</li>
</ol>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>所谓序列化，指的是将一个对象编码成字节流，一般用来持久化。</p>
<ol>
<li>谨慎实现<code>Serializable</code>接口。</li>
</ol>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-03-31T11:28:49.205Z" itemprop="dateUpdated">2019-03-31 19:28:49</time>
</span><br>


        
        <a href="/2017/06/12/EffectiveJava/" target="_blank" rel="external">http://YiuTerran.github.io/2017/06/12/EffectiveJava/</a>
        
    </div>
    <footer>
        <a href="http://YiuTerran.github.io">
            <img src="/img/avatar.png" alt="tryao">
            tryao
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/base/">base</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://YiuTerran.github.io/2017/06/12/EffectiveJava/&title=《effective java 读书笔记》 — 无心呢喃&pic=http://YiuTerran.github.io/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://YiuTerran.github.io/2017/06/12/EffectiveJava/&title=《effective java 读书笔记》 — 无心呢喃&source=个人技术类感悟、笔记等，非技术类见微信公众号“叶囊”" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://YiuTerran.github.io/2017/06/12/EffectiveJava/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《effective java 读书笔记》 — 无心呢喃&url=http://YiuTerran.github.io/2017/06/12/EffectiveJava/&via=http://YiuTerran.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://YiuTerran.github.io/2017/06/12/EffectiveJava/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/06/12/python celery组件使用/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">python celery组件使用</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/06/12/java并发编程实战读书笔记/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">java并发编程实战读书笔记</h4>
      </a>
    </div>
  
</nav>



    




<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'yiuterran';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <ul class="reward-items">
        
        <li>
            <img src="/img/wechat.png" title="微信打赏二维码" alt="微信打赏二维码">
            <p>微信</p>
        </li>
        

        
        <li>
            <img src="/img/alipay.png" title="支付宝打赏二维码" alt="支付宝打赏二维码">
            <p>支付宝</p>
        </li>
        
    </ul>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
            <span>tryao &copy; 2017 - 2020</span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://YiuTerran.github.io/2017/06/12/EffectiveJava/&title=《effective java 读书笔记》 — 无心呢喃&pic=http://YiuTerran.github.io/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://YiuTerran.github.io/2017/06/12/EffectiveJava/&title=《effective java 读书笔记》 — 无心呢喃&source=个人技术类感悟、笔记等，非技术类见微信公众号“叶囊”" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://YiuTerran.github.io/2017/06/12/EffectiveJava/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《effective java 读书笔记》 — 无心呢喃&url=http://YiuTerran.github.io/2017/06/12/EffectiveJava/&via=http://YiuTerran.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://YiuTerran.github.io/2017/06/12/EffectiveJava/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMklEQVR42u3aQW4DMQgF0Nz/0um2UjvJByatbD+vqmiS8fOCYuDxiNfzx/r++evnr568+uTqN29YGBgYyzKeL1fyzGtMchBX4MIbMTAwDmAkm7jrW69Dah7QMTAwMJKfSzbXC7IYGBgYE0aSuuWA6tUXAwPjZEayobzGlZfq/uEujoGBsSAjr7r//d8f6W9gYGAsxXgW16S4Vg3ZhV1hYGBszcgDXJ44VtuZOfhNgQ8DA2NrRl5QS4a6qtvKr6835LAYGBjLMpKN5oxeYJ2Mi2FgYOzNqAbESao3aRu8ia4YGBhbM6qF+F6InATcQsqIgYGxNSPfbq/R2NtiEnabp46BgbEso5fqTWpfvZbDm6PEwMDYjpEPQPRaAnmboRemMTAwTmD0SmyfGCPrheZCmoiBgbEso5rk5ZfYamCtJpTll2FgYGzBqA5b9Ep4SSAeDVtgYGAcwOhh8nDcG7konBAGBsYxjGraN+9L5OngZU8DAwNjU8akPlcN1r3jKLQEMDAwDmAkQw/VUFsdqsjD/S/vwsDAOIAxT9p6IxGTgTAMDIzTGJNLbJVUfePo/wYGBsbijPmY113X4F4IfuQnhIGBsSyjNypRDZRJwpdst5p0YmBg7MTIy23VhC85udsGLzAwMA5gFG69xWZkNZiO7uIYGBgYccm+Gljz528LuBgYGAcwkpTurpJZdAQYGBgHMCYX0d5Ft3plva3choGBsSBjdHUslvvz1mZvJxgYGNsxvgBCyGqYpqACGQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };



</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '赶紧回来啊~';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎光临惹!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>
