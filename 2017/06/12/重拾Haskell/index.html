<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>重拾Haskell | 无心呢喃 | 个人技术类文章博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="FP,Haskell">
    <meta name="description" content="我打算学习但是最终没能完全理解的语言大概有三门：因为复杂性而放弃的Scala和Rust，因为难以理解而放弃的Haskell. 学习过C++以后，我对太过复杂的语言一项是敬而远之的，这一点暂时不会有变化，以后在工作中如果遇到必须使用Scala的时候我还是会认真学习。但是对于Haskell还是有些不甘心。虽然这是一门号称不看论文很难理解的语言，我还是想尽力学习一下。 Haskell相对于其他语言，变化">
<meta name="keywords" content="FP,Haskell">
<meta property="og:type" content="article">
<meta property="og:title" content="重拾Haskell">
<meta property="og:url" content="http://YiuTerran.github.io/2017/06/12/重拾Haskell/index.html">
<meta property="og:site_name" content="无心呢喃">
<meta property="og:description" content="我打算学习但是最终没能完全理解的语言大概有三门：因为复杂性而放弃的Scala和Rust，因为难以理解而放弃的Haskell. 学习过C++以后，我对太过复杂的语言一项是敬而远之的，这一点暂时不会有变化，以后在工作中如果遇到必须使用Scala的时候我还是会认真学习。但是对于Haskell还是有些不甘心。虽然这是一门号称不看论文很难理解的语言，我还是想尽力学习一下。 Haskell相对于其他语言，变化">
<meta property="og:updated_time" content="2017-06-12T16:21:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="重拾Haskell">
<meta name="twitter:description" content="我打算学习但是最终没能完全理解的语言大概有三门：因为复杂性而放弃的Scala和Rust，因为难以理解而放弃的Haskell. 学习过C++以后，我对太过复杂的语言一项是敬而远之的，这一点暂时不会有变化，以后在工作中如果遇到必须使用Scala的时候我还是会认真学习。但是对于Haskell还是有些不甘心。虽然这是一门号称不看论文很难理解的语言，我还是想尽力学习一下。 Haskell相对于其他语言，变化">
    
        <link rel="alternate" type="application/atom+xml" title="无心呢喃" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">tryao</h5>
          <a href="mailto:yaotairan@gmail.com" title="yaotairan@gmail.com" class="mail">yaotairan@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/YiuTerran" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">重拾Haskell</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">重拾Haskell</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-06-12T15:46:39.000Z" itemprop="datePublished" class="page-time">
  2017-06-12
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#优化显示"><span class="post-toc-number">1.</span> <span class="post-toc-text">优化显示</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#基础"><span class="post-toc-number">2.</span> <span class="post-toc-text">基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#语法"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">语法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#list"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">list</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#tuple"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">tuple</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#types"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">types</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#function"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">function</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#lambda"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">lambda</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#模块"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">模块</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#自定义结构"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">自定义结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#typeclass"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">typeclass</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#错误"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">错误</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#缩进"><span class="post-toc-number">2.10.</span> <span class="post-toc-text">缩进</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#节"><span class="post-toc-number">2.11.</span> <span class="post-toc-text">节</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#As模式"><span class="post-toc-number">2.12.</span> <span class="post-toc-text">As模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#折叠"><span class="post-toc-number">2.13.</span> <span class="post-toc-text">折叠</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#module"><span class="post-toc-number">2.14.</span> <span class="post-toc-text">module</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#build"><span class="post-toc-number">2.15.</span> <span class="post-toc-text">build</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#IO"><span class="post-toc-number">3.</span> <span class="post-toc-text">IO</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#技巧"><span class="post-toc-number">4.</span> <span class="post-toc-text">技巧</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据结构"><span class="post-toc-number">5.</span> <span class="post-toc-text">数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字典"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">字典</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#通用序列"><span class="post-toc-number">6.</span> <span class="post-toc-text">通用序列</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Functor（函子）"><span class="post-toc-number">7.</span> <span class="post-toc-text">Functor（函子）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#幺半群"><span class="post-toc-number">8.</span> <span class="post-toc-text">幺半群</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Monads"><span class="post-toc-number">9.</span> <span class="post-toc-text">Monads</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Monad变换器"><span class="post-toc-number">10.</span> <span class="post-toc-text">Monad变换器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#错误处理"><span class="post-toc-number">11.</span> <span class="post-toc-text">错误处理</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-重拾Haskell"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">重拾Haskell</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-06-12 23:46:39" datetime="2017-06-12T15:46:39.000Z"  itemprop="datePublished">2017-06-12</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>我打算学习但是最终没能完全理解的语言大概有三门：因为复杂性而放弃的Scala和Rust，因为难以理解而放弃的Haskell. 学习过C++以后，我对太过复杂的语言一项是敬而远之的，这一点暂时不会有变化，以后在工作中如果遇到必须使用Scala的时候我还是会认真学习。但是对于Haskell还是有些不甘心。虽然这是一门号称不看论文很难理解的语言，我还是想尽力学习一下。</p>
<p>Haskell相对于其他语言，变化的速度非常快，现在最新的平台是<code>stack</code>，连<code>Haskell Platform</code>也过时了（有种web前端的感觉），不过其核心理念还是比较稳定的，以前从<code>Haskell趣学指南</code>中学习的东西，现在也大多还能用。</p>
<p>在ubuntu中添加官方PPA, <code>sudo apt-get install stack</code>以后，使用<code>stack setup</code>安装环境，使用<code>stack ghci</code>打开交互式环境，然后就可以愉悦的学习了。目前最的版本是ghc-8.0.1；</p>
<h2 id="优化显示"><a href="#优化显示" class="headerlink" title="优化显示"></a>优化显示</h2><p>默认的stack使用起来不是很方便，有些地方可以优化一二。<br>首先编辑<code>~/.stack/config.yaml</code>，删掉空白的<code>{}</code>，加入以下内容：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">templates:</span></div><div class="line"><span class="attr">    params:</span></div><div class="line"><span class="attr">        author-email:</span> <span class="string">yaotairan@gmail.com</span></div><div class="line"><span class="attr">        author-name:</span> <span class="string">tryao</span></div><div class="line"><span class="attr">        category:</span> <span class="string">Personal</span></div><div class="line"><span class="attr">        copyright:</span> <span class="string">'Copyright (c) TairanYao'</span></div><div class="line"><span class="attr">        github-username:</span> <span class="string">YiuTerran</span></div><div class="line"><span class="attr">package-indices:</span></div><div class="line"><span class="attr">- name:</span> <span class="string">Tsinghua</span></div><div class="line"><span class="attr">  download-prefix:</span> <span class="attr">http://mirrors.tuna.tsinghua.edu.cn/hackage/package/</span></div><div class="line"><span class="attr">  http:</span> <span class="attr">http://mirrors.tuna.tsinghua.edu.cn/hackage/00-index.tar.gz</span></div></pre></td></tr></table></figure></p>
<p>上面的email和名字之类的需要换成自己的，后面加了清华的源，加快<code>cabal</code>的下载速度。</p>
<p>编辑<code>~/.ghci</code>加入以下内容：<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> IPPrint</div><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.Haskell.HsColour <span class="keyword">as</span> HsColour</div><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.Haskell.HsColour.Colourise <span class="keyword">as</span> HsColour</div><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.Haskell.HsColour.Output <span class="keyword">as</span> HsColour</div><div class="line"></div><div class="line"><span class="title">let</span> myColourPrefs = <span class="type">HsColour</span>.defaultColourPrefs &#123; <span class="type">HsColour</span>.conid = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Yellow</span>, <span class="type">HsColour</span>.<span class="type">Bold</span>], <span class="type">HsColour</span>.conop = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Yellow</span>], <span class="type">HsColour</span>.string = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Green</span>], <span class="type">HsColour</span>.char = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Cyan</span>], <span class="type">HsColour</span>.number = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">Red</span>, <span class="type">HsColour</span>.<span class="type">Bold</span>], <span class="type">HsColour</span>.layout = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">White</span>], <span class="type">HsColour</span>.keyglyph = [<span class="type">HsColour</span>.<span class="type">Foreground</span> <span class="type">HsColour</span>.<span class="type">White</span>] &#125;</div><div class="line"></div><div class="line"><span class="title">let</span> myPrint = putStrLn . <span class="type">HsColour</span>.hscolour (<span class="type">HsColour</span>.<span class="type">TTYg</span> <span class="type">HsColour</span>.<span class="type">XTerm256Compatible</span>) myColourPrefs <span class="type">False</span> <span class="type">False</span> <span class="string">""</span> <span class="type">False</span> . <span class="type">IPPrint</span>.pshow</div><div class="line"></div><div class="line">:set -interactive-print=myPrint</div><div class="line">:set -<span class="type">XNoMonomorphismRestriction</span></div><div class="line">:set prompt <span class="string">"λ "</span></div></pre></td></tr></table></figure></p>
<p>然后在shell里运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libbz2-dev</div><div class="line">stack install ipprint hscolour</div></pre></td></tr></table></figure></p>
<p>执行stack安装依赖时，可能会报错，根据提示修正即可.<br>这是给<code>ghci</code>添加语法高亮.</p>
<p>最后，如果用zsh的话， 可以打开<code>stack</code>插件，方便自动完成. 也可以<code>alias ghci=&#39;stack ghci&#39;</code>. 另外，最好把<code>~/.local/bin</code>加到PATH里面去.</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>仍然从<a href="http://wiki.jikexueyuan.com/project/haskell-guide/introduction.html" target="_blank" rel="external">《Haskell趣学指南指南》</a>这本书开始是比较合适的，虽然内容有些过时，但是基础部分变动应该不大。上次看这本书的时候我还不会python呢，如今js我也驾轻就熟了，看起来应该简单很多了。完成后开始看<a href="http://cnhaskell.com/" target="_blank" rel="external">《Real World Haskell》</a>，后者相关习题的个人解答：<a href="https://github.com/YiuTerran/rwh-exercise" target="_blank" rel="external">https://github.com/YiuTerran/rwh-exercise</a></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>基本语法大体和普通语言（C系）相似，除了：</p>
<ul>
<li>不等于符号是 <code>/=</code>，和数学中的$\neq$长的很像</li>
<li><code>not</code>和python里面一样，但是<code>&amp;&amp;</code>, <code>||</code>和C语言一样</li>
<li>函数调用使用<strong>空格</strong>，且具有最高优先级</li>
<li>括号用来保持更高的优先级</li>
<li><code>if..then..else</code>句式中，<code>else</code>是不可省略的，类似python中的单句<code>if..else</code></li>
<li>函数不允许首字母大写，按规定，所有首字母大写的都是类型或者类型类</li>
<li>由于允许操作符重载（自定义），很多符号的定义在不同的包里有不同的意思。如<code>Data.Ratio</code>里面有一堆分数相关的操作，<code>Data.Bits</code>里面则定义了很多位操作</li>
<li>操作符重载只是一种C++的描述，其实在这里是一种函数（当然<br>在ghci中，使用<code>let</code>定义变量，在脚本中直接赋值即可，变量可以看作是没有参数的函数（名字）。</li>
</ul>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul>
<li><code>list</code>和python中的形式大体一致，除了一点：所有元素的类型必须相同。</li>
<li>将两个列表合并使用<code>++</code>(效率较低）,使用<code>:</code>将元素插入队首，本质上<code>[1, 2, 3]</code>就是<code>1: 2: 3: []</code></li>
<li>使用<code>!!</code>取下标，越界会报错</li>
<li>list中的list也必须是同样元素类别（但是不关心长度）</li>
<li><code>head</code>返回头部（<code>car</code>)，<code>tail</code>返回尾部(<code>cdr</code>)，<code>last</code>返回最后一个元素，<code>init</code>返回除了最后一个元素的列表</li>
<li>对空的list，以上函数都会报错</li>
<li>Haskell的string就是<code>[Char]</code></li>
<li>使用<code>length</code>函数返回list的长度</li>
<li>使用<code>null</code>函数检测是否为空</li>
<li>使用<code>reverse</code>函数进行反转</li>
<li>使用<code>take</code>函数取出队首任意多个元素，超过长度也不会报错，只是返回所有</li>
<li>使用 <code>drop</code>删除队首任意多个元素</li>
<li>使用<code>maximum</code>和<code>minimum</code>求出队列中的极值</li>
<li>使用<code>sum</code>和<code>product</code>求出队列的和,积</li>
<li>使用<code>elem</code>判断是否是元素，一般用中缀形式表达（类似python中的<code>in</code>）</li>
<li>range生成使用<code>..</code>，例如[1..20]， step可以在第二个元素中指定，如[10,8..0];字母也可以用；但是不要用浮点数；由于惰性的原因，可以是无限长的range;</li>
<li>repeat函数用于生成重复序列，类似python中的<code>*</code></li>
<li>大名鼎鼎的list comprehesion,和python中类似，不同的是形式更加数学化。比如生成1到10的平方，在python中是<code>[k^2 for k in range(1, 10)]</code>，在hs中则是<code>[k^2 | k &lt;- [1..10]]</code>，感觉有点像高中数学吧，哈。后面的条件用逗号隔开表示<code>&amp;&amp;</code></li>
</ul>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><ul>
<li>仍然类似python中的tuple，但是：不允许有仅含有一个元素的tuple</li>
<li>在模式匹配中被大量使用</li>
<li>tuple的大小是不可改变的，但是类型可以不同</li>
<li><code>fst</code>, <code>snd</code>分别返回tuple的第一项和第二项，显然仅对<code>pair</code>（二元组）有效；</li>
<li><code>zip</code>用于使list组成tuple对，类似python</li>
<li><code>map</code>也类似python</li>
</ul>
<h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><ul>
<li>类型推导最强的语言，显式类型声明<code>::</code>，如<code>a :: Char</code></li>
<li>在ghci中使用<code>:t</code>判断类型，使用<code>:info</code>查看具体相关</li>
<li>类型的首字母必须大写</li>
<li><code>Int</code>是有限的，<code>Integer</code>是无限的</li>
<li>类型无关的时候，使用小写字母代替，比如<code>[a]</code>表示任意元素组成的list</li>
<li>typeclass是预定义的类型接口，比如可以相等的类型，必定是<code>Eq</code>的一个实现</li>
<li>类型约束<code>=&gt;</code>，类似于接口中的<code>where</code>，可以是任意类型，但必须满足。例如 <code>(Eq a)=&gt; a -&gt; a</code></li>
</ul>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>对于Haskell的纯函数而言，其主要书写格式就是大名鼎鼎的模式匹配，<code>Rust</code>也学习了这套语法。模式匹配其实是将数学按照构造函数进行拆分，能够这么干的主要原因是Haskell是纯函数式语言，没有副作用，变量被赋值后不能够再次修改。</p>
<ul>
<li>最好自己写上函数的签名，方便在编译期查错</li>
<li>对于函数来说，从上到下匹配，允许递归</li>
<li>对于<code>switch...case</code>类型的句子，使用<code>Guard</code>(<code>|</code>)，如果条件需要计算，在后面使用<code>where</code>（允许多个变量，但是要垂直隔开）</li>
<li>也可以使用<code>let..in</code>表示中某个作用域中的变量声明</li>
<li><code>let</code>是一个表达式，而<code>where</code>是一个语法结构，表达式（类似<code>if..then..else</code>）可以放在各种位置</li>
<li>除了这些以外，<code>case</code>表达式本身也存在，其语法结构是<code>case xx of x -&gt; ...</code>，模式匹配本质上都是这个表达式的语法糖</li>
<li>使用<code>_</code>可以匹配任意情况</li>
<li>除了纯函数外，Haskell也有有副作用的函数比如IO，这种函数的书写格式更类似普通命令式语言。</li>
<li>函数的基本形式是<code>a-&gt;b-&gt;c</code>，箭头连接各个参数，由于函数是柯里化的，所以也可以看做<code>a-&gt;(b-&gt;c)</code>，每个部分是一个<strong>偏函数</strong>，整个被称为<strong>全函数</strong>。如果函数不返回任何东西（在某些语言中被称为过程），这个函数肯定是非纯函数，一般返回<code>()</code>【读作<code>unit</code>】，如<code>IO ()</code></li>
</ul>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>lambda表达式本来就源自FP(lisp)，所以很自然的：<code>\xs -&gt; length xs</code>，不过haskell中用lambda比其他语言应该少很多。</p>
<p>常用的一些函数：<br><code>fold</code>, <code>fold1</code>, <code>foldr</code>, scan家族类似<br><code>$</code> 符号同样也可以调用函数，但是与空格不同，他具有最低优先级，主要用来减少括号的数量；<br><code>.</code>符号表示右结合的函数，即先算最右边的，然后依次应用左边的函数，右边函数的返回值是左边函数的参数；<br>上面两个符号主要用来做函数组合，简化书写。。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>熟悉的import语句，不过和python的语法不太像，倒是有点像java.</p>
<ul>
<li><code>import Data.List</code> 会导入该模块下的所有函数；</li>
<li><code>import Data.List (nub, sort)</code>仅导入两个函数</li>
<li><code>import Data.list hiding (nub)</code> 导入除了nub之外的所有函数</li>
<li><code>import qualified Data.Map</code> 导入所有函数，但是如果和已加载模块冲突的话，必须使用全引用</li>
<li>可以在后面加上<code>as x</code>做别名</li>
</ul>
<h3 id="自定义结构"><a href="#自定义结构" class="headerlink" title="自定义结构"></a>自定义结构</h3><p>关键字： <code>data</code><br>和其他语言不一样，标准格式很奇怪<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">BookInfo</span> = <span class="type">Book</span> <span class="type">Int</span> <span class="type">String</span> [<span class="type">String</span>]</span></div><div class="line">                                <span class="keyword">deriving</span> (<span class="type">Show</span>)</div></pre></td></tr></table></figure></p>
<p>BookInfo就是类型的名字（类型构造器），Book是值构造器的名字，后面是成员；两者名字可以一致；</p>
<p>这样访问属性还要写专门的函数（模式匹配），很蛋疼，所以有个惯用法（标准称呼是<strong>记录</strong>）：<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">BookInfo</span> = <span class="type">BookInfo</span> &#123;</span></div><div class="line">    <span class="title">price</span>   :: <span class="type">Int</span>,</div><div class="line">    <span class="title">author</span>  :: <span class="type">String</span>,</div><div class="line">    <span class="title">buyer</span>   :: [<span class="type">String</span>]</div><div class="line">&#125; <span class="keyword">deriving</span> (<span class="title">show</span>)</div></pre></td></tr></table></figure></p>
<p>这些成员当然也可以是函数。</p>
<p>递归定义也是很常见的，比如一个二叉树：<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Node</span> a (<span class="type">Node</span> <span class="title">a</span>) (<span class="type">Node</span> <span class="title">a</span>)</span></div></pre></td></tr></table></figure></p>
<p>这里a是类型参数。</p>
<p>关键字<code>type</code>类似C++中的<code>typedef</code>，用于定义类型的别名。</p>
<p>此外<code>newtype</code>也可以自定结构，不过有很多约束。<code>newtype</code>关键字给现有类型一个不同的身份，因此只能有一个值构造器，并且这个构造器只能有一个字段。</p>
<p>由<code>data</code>关键字创建的类型在运行时有一个记录开销，如记录某个值是用哪个构造器创建的。而<code>newtype</code>只有一个构造器，所以不需要这个额外开销。这使得它在运行时更省时间和空间。由<code>newtype</code>的构造器只在编译时使用，运行时甚至不存在。</p>
<h3 id="typeclass"><a href="#typeclass" class="headerlink" title="typeclass"></a>typeclass</h3><p>就是其他语言中的类型类/接口/模板，语法是<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">BasicEq</span> a <span class="keyword">where</span></span></div><div class="line">    isEqual:: a -&gt; a -&gt; <span class="type">Bool</span></div></pre></td></tr></table></figure></p>
<p>实例是<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">BasicEq</span> bool <span class="keyword">where</span></span></div><div class="line">    isEqual <span class="type">True</span> <span class="type">True</span> = <span class="type">True</span></div><div class="line">    isEqual <span class="type">False</span> <span class="type">False</span> = <span class="type">True</span></div><div class="line">    isEqual _ _ = <span class="type">False</span></div></pre></td></tr></table></figure></p>
<ul>
<li>常见的Typeclass包括<code>Eq</code>, <code>Ord</code>(可比较), <code>Show</code>(可以转换为字符串), <code>Read</code>可以被<code>String</code>转换(可以用<code>::</code>显式指定类型)，<code>Enum</code>（可以被迭代)，<code>Bounded</code>(有上下限），<code>Num</code>(有数字特征，必须实现<code>Eq</code>和<code>Show</code>)，<code>Integral</code>, <code>Floating</code></li>
<li><code>fromIntegral</code>可以将整数转换成浮点数（根据后续操作转换）</li>
<li>默认情况下，Haskell不支持模板特化（重载）。可以通过语言扩展<code>FlexibleInstances</code>取消这个限制。</li>
<li>扩展<code>OverlappingInstances</code>可以允许重叠实例。</li>
<li>在文件最前面加上<code>{-# LANGUAGE TypeSynonymInstances, OverlappingInstances #-}</code>即可打开编译器扩展；</li>
<li>在<code>RWH</code>上面提到了单一同态错误问题，经过我的测试，在最新的(8.0.1)的GHC中这个问题已经不存在了；</li>
<li>同C++的模板一样，允许多参数类型类（MultiParamTypeClasses），多参数之间可以定义条件约束表明多个参数之间的关系</li>
<li>多参数类型类比较复杂，谨慎使用</li>
</ul>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>使用 error 函数输出错误<br>避免抛出错误，使用<code>Maybe</code>, <code>Just</code>和<code>Nothing</code></p>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><blockquote>
<p>Haskell 依据缩进来解析代码块。这种用排版来表达逻辑结构的方式通常被称作缩进规则。在源码文件开始的那一行，首个顶级声明或者定义可以从该行的任意一列开始，Haskell 编译器或解释器将记住这个缩进级别，并且随后出现的所有顶级声明也必须使用相同的缩进。<br>let 表达式和 where 从句的规则与此类似。一旦 Haskell 编译器或解释器遇到一个 let 或 where 关键字，就会记住接下来第一个标记（token）的缩进位置。然后如果紧跟着的行是空白行或向右缩进更深，则被视作是前一行的延续。而如果其缩进和前一行相同，则被视作是同一区块内的新的一行。</p>
</blockquote>
<p>也可以使用显式语法结构（使用花括弧代替缩进），不过一般不这么做</p>
<h3 id="节"><a href="#节" class="headerlink" title="节"></a>节</h3><p>节其实是高阶函数的一种形式（语法糖），如<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">test</span> = (+<span class="number">2</span>)</div><div class="line">// test <span class="number">3</span> = <span class="number">5</span></div></pre></td></tr></table></figure></p>
<h3 id="As模式"><a href="#As模式" class="headerlink" title="As模式"></a>As模式</h3><blockquote>
<p>模式 <code>xs@(_:xs&#39;)</code> 被称为 as-模式，它的意思是：如果输入值能匹配 @ 符号右边的模式（这里是 <code>(_:xs&#39;)</code> ），那么就将这个值绑定到 @ 符号左边的变量中（这里是 xs ）。</p>
</blockquote>
<p>除了增强可读性外，可以简化代码，减少内存分配</p>
<h3 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h3><ul>
<li><code>foldl</code>，接受一个初始值，一个步进函数，对一个列表进行迭代求职，显然<code>sum = foldl (+) 0</code></li>
<li><code>foldr</code>，格式同上，从右侧开始折叠。</li>
</ul>
<blockquote>
<p>一种思考 foldr 的方式是，将它看成是对输入列表的一种转换（transform）：它的第一个参数决定了该怎么处理列表的 head 和 tail 部分；而它的第二个参数则决定了，当遇到空列表时，该用什么值来代替这个空列表。</p>
</blockquote>
<ul>
<li>千万不要把 foldl 用在实际使用中，这是因为会发生内存泄露（因为惰性求值的关系</li>
<li>真正的情况使用的是<code>foldl&#39;</code>，<code>foldr&#39;</code> (Data.List)</li>
<li><code>foldl</code>的步进函数格式是 <code>step acc x</code>, <code>foldr</code>的则是<code>step x acc</code>，对于list <code>(x:xs)</code>而言，从左折叠第一个元素是<code>x</code>，从右折叠第一个元素是<code>[]</code>；</li>
</ul>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>module的规定类似java，名字必须和文件名一致，首字母必须大写；<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">module</span> SimpleJSON(</div><div class="line">    <span class="type">Xxxx</span>,   //导出部分，如果省略则全部导出</div><div class="line">) <span class="keyword">where</span></div></pre></td></tr></table></figure></p>
<p>显然入口模块应该是<code>Main.hs</code></p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>单文件可以用<code>runghc</code>命令运行，相当于脚本；也可以在ghci里面<code>:l</code>外部文件进行测试；<br>编译则需要使用<code>stack ghc</code>命令；</p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul>
<li>IO是有副作用的（非幂等的），因此Haskell中的IO和非IO函数一般严格分开。</li>
<li>IO动作可以被创建，赋值和传递到任何地方，但是仅能在另一个IO动作里被执行</li>
<li><code>&lt;-</code>运算符从I/O中抽出结果并保存到一个变量中</li>
<li>当有多个动作时，使用<code>do</code>引入代码块</li>
<li>在<code>do</code>中，使用命令式语言的语法完成一系列操作（赋值用<code>let</code>）</li>
<li><code>do</code> 代码块中的每一个声明，除了 <code>let</code> ，都要产生一个I/O操作，这个操作在将来被执行（惰性）</li>
<li>IO相关函数被定义在<code>System.IO</code>中</li>
<li><code>return</code>的作用和<code>&lt;-</code>相反，将一个纯值包装进IO，可以把IO想象成一个流。<code>return</code>入流后，将来可以通过<code>-&gt;</code>取出来赋值；</li>
<li>除了普通IO以外，haskell还有自己特色的惰性IO，<code>hGetContents</code>就是惰性的</li>
<li>除了<code>openFile</code>和<code>hClose</code>外，使用<code>readFile</code>也可以，同时可以避免忘记关掉<code>hClose</code>的问题</li>
<li>对于指定的模式，比如打开文件流，做一些变化，再输出到流，可以用<code>interact</code></li>
<li>IO与普通函数的联系通过<code>Monad</code>实现，或者说IO是一种Monad</li>
<li>命名习惯： <code>mapM</code>返回一个IO动作，<code>mapM_</code>完成IO，但是不返回任何值，<code>M</code>的后缀表示<code>Monad</code></li>
<li><code>map</code>不能执行操作（纯函数），这就是<code>mapM</code>存在的意义</li>
<li><code>forM</code>意思与<code>mapM</code>相反，第一个参数是列表，第二个是动作，存在的意义是更干净的代码</li>
<li><code>do</code>代码块实际上是把操作连接在一起的快捷记号，可以用<code>&gt;&gt;</code>和<code>&gt;&gt;=</code>代替</li>
<li><code>&gt;&gt;</code> 运算符把两个操作串联在一起：第一个操作先运行，然后是第二个，整个计算的结果是最后运算的结果</li>
<li><code>&gt;&gt;=</code> 运算符运行一个操作，然后把它的结果传递给一个返回操作的函数。类似linux 管道操作</li>
<li>类似地，还有<code>=&lt;&lt;</code>运算符，将右边的动作传递给左边</li>
<li>换句话说，<code>do</code>块的最后一个操作的值就是整个<code>do</code>的值。如果以<code>return</code>结尾，返回一个<code>Monad</code>，比如整个函数的返回值是<code>IO()</code>，最后多半就是以<code>return</code>结尾。这种函数的返回值只能在另一个Monad函数中重新读出，不能直接用于任何操作。</li>
<li>Haskell中的纯代码不能运行那些能触发副作用的命令。纯函数不能修改全局变量，请求I/O，或者运行一条关闭系统的命令</li>
</ul>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul>
<li>默认的String类型速度堪忧，可以用<code>bytestring</code>库代替。<code>Data.ByteString</code>和<code>Data.ByteString.Lazy</code>分别代表了惰性和普通模式的情况；</li>
<li>不要在类型定义上加类型约束，在需要它们的函数上加；</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>除了<code>List</code>和<code>Tuple</code>, Haskell自带了其他的一些常见的数据结构；</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li>关联列表也可以当作字典用，但是效率比较低。使用<code>lookup</code>可以在关联列表中查询数据；</li>
<li><code>Data.Map</code>，不同于大部分语言，这个<code>Map</code>是用平衡二叉树实现的，而不是哈希表。这和haskell的不可变性有关；</li>
<li>常用函数：<code>fromList</code>(通过关联列表转换)，<code>insert</code>（插入新值返回新的<code>Map</code>）</li>
<li>虽然是二叉树实现的，这个<code>Map</code>仍然是无序的（有点奇怪）</li>
</ul>
<h2 id="通用序列"><a href="#通用序列" class="headerlink" title="通用序列"></a>通用序列</h2><p><code>Data.Sequence</code>提供了比默认<code>list</code>更好的效率</p>
<ul>
<li>使用<code>fromList</code>创建，或者用<code>empty</code>和<code>singleton</code>函数创建</li>
<li>使用<code>|&gt;</code>, <code>&lt;|</code>和<code>&gt;&lt;</code> 添加元素，箭头指向被添加的元素</li>
<li>使用<code>Foldable.toList</code>将<code>Sequence</code>转回list</li>
</ul>
<h2 id="Functor（函子）"><a href="#Functor（函子）" class="headerlink" title="Functor（函子）"></a>Functor（函子）</h2><p>对于一个递归的数据结构，对于应用于其上的函数也很可能是同构递归的。书中的例子是将一棵字符串树转变为包含字符串长度的树，也就是说，树的结构不变，但是元素变成长度：</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">treeLengths</span>:: <span class="type">Tree</span> -&gt; <span class="type">Tree</span></div><div class="line"><span class="title">treeLengths</span> (<span class="type">Leaf</span> s) = <span class="type">Leaf</span> (treeLengths s)</div><div class="line"><span class="title">treeLengths</span> (<span class="type">Node</span> l r) = <span class="type">Node</span> (treeLengths l) (treeLengths r)</div></pre></td></tr></table></figure>
<p>这种能够同构映射的，满足类型类<code>Functor</code>，映射函数即<code>fmap</code>：</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></div><div class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</div></pre></td></tr></table></figure>
<p><code>Functor</code>是非常重要的一类class，有几个基本原则进行约束。首先，<code>fmap id</code>必须返回相同的值，其次，<code>Functor</code>必须是可组合的，换句话说，<code>fmap a . fmap b</code> == <code>fmap (a . b)</code>应该成立。</p>
<p>编译器不会检查这些规则，程序员需要自己保证这些规则成立。这些规则是函子在范畴论中的数学约束。</p>
<h2 id="幺半群"><a href="#幺半群" class="headerlink" title="幺半群"></a>幺半群</h2><p>在范畴论中，有一类简单的抽象结构被称为幺半群。许多数学结构都是幺半群，因为成为幺半群的要求非常低。 一个结构只要满足两个性质便可称为幺半群：</p>
<ul>
<li>一个满足结合律的二元操作符。我们称之为 <code>(*)</code>：表达式 <code>a * (b * c)</code> 和 <code>(a * b) * c</code> 结果必须相同。</li>
<li>一个单位元素。我们称之为 <code>e</code>，它必须遵守两条法则：<code>a * e == a</code> 和 <code>e * a == a</code>。</li>
</ul>
<p>即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Monoid a where</div><div class="line">    mempty  :: a                -- the identity</div><div class="line">    mappend :: a -&gt; a -&gt; a      -- associative binary operator</div></pre></td></tr></table></figure></p>
<p>如果我们真的需要在同一个类型上实现多个 Monoid 实例，我们可以用 newtype 创建不同的类型来达到目的。</p>
<h2 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h2><p><code>Monad</code>（单子）是Haskell最难理解的东西之一，这个概念和上文中的幺半群有关，<a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="external">这里</a>有一些辅助理解的漫画。</p>
<p>一个Monad由以下几个构造元素：</p>
<ul>
<li>一个类型构造器 m</li>
<li>一个用于把某个函数的输出串联到另外一个函数输入上的函数，它的类型是 <code>m a -&gt; (a -&gt; m b) -&gt; m b</code></li>
<li>一个类型为 <code>a -&gt; m a</code> 的函数，它把普通值注入到调用链里面，也就是说，它把类型 a 用类型构造器 m 包装起来。</li>
</ul>
<p>标准的monad定义为：<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span></div><div class="line">    <span class="comment">-- chain</span></div><div class="line">    (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</div><div class="line">    <span class="comment">-- inject</span></div><div class="line">    return :: a -&gt; m a</div></pre></td></tr></table></figure></p>
<p>显然<code>&gt;&gt;=</code>就是串联函数，<code>return</code>是注入函数（IO monad就是把普通值放入IO），类型构造器就是<code>m</code>本身。除此之外，还有<code>&gt;&gt;</code>函数用户忽略返回值的过程（即按步骤一步步来），以及<code>fail</code>函数接受一个错误消息让整个调用链失败（默认使用<code>error</code>函数）。</p>
<p>下面是具体的解析：</p>
<ul>
<li>如漫画里所述，单子、函子、态射都是对普通值一种包装(context)，由于haskell里值是不可变的，所以都可以重新用构造器进行匹配解析。</li>
<li>对于函子，是这样一种类型类（接口），存在<code>fmap</code>函数，可以让让普通函数与该类型类的实例进行运算，最简单的来讲<code>fmap (+3) (Just 5)</code>应该是<code>Just 8</code>；函子的中缀形式是<code>&lt;$&gt;</code>；</li>
<li>对于普通的函子，<code>fmap</code>仅能将函数应用于被包装的数据。对于<code>Applicative</code>这种，则可以将函数应用于被包装的函数。<code>import Control.Applicative</code>以后，可以使用<code>(Just (+3)) &lt;*&gt; (Just (+5))</code>，这将会生成一个<code>Just (+8)</code>的函数；这是因为函数也可以是函子的实例。因为函子的约束只有<code>可以应用fmap</code>这一个而已.</li>
<li>单子与上面的两个函子很类似，单子主要定义了<code>&gt;&gt;=</code>（bind）和<code>return</code>这两个函数，前者用于连接包装值和接受普通值作为参数的函数，该函数返回一个包装值。换句话说，Monad定义了一种行为，如何将包装值分解为普通值行为，最后再返回包装值。也就是<code>M a -&gt; (a -&gt; M b) -&gt; M b</code>.</li>
<li>单子的<code>return</code>其实就是将任意普通值包装起来；</li>
<li>有了上面两个性质，Monad就可以类似管道一样将普通函数串接起来使用了；</li>
</ul>
<hr>
<ul>
<li><p><code>Monad</code> class里面没有提供任何函数可以使一个<code>monadic</code>的值还原成一个普通值，这需要写代码的人自己定义。</p>
</li>
<li><p>我们经常需要将数据从<code>Monad</code>中取出来，然后使用纯函数进行计算，最后再用原来的类型构造器重新包围这个计算的结果,这种需求被称为<code>lifting</code>.对于<code>Monad</code>而言，已经定义了<code>&gt;&gt;=</code>和<code>return</code>，所以很容易得出：</p>
</li>
</ul>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">liftM</span> :: (<span class="type">Monad</span> m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b</div><div class="line"><span class="title">liftM</span> f m = m &gt;&gt;= \i -&gt;</div><div class="line">    return (f i)</div></pre></td></tr></table></figure>
<p>该函数被定义在<code>Control.Monad</code>中。比如我们要计算<code>Just (1 + 3)</code>，就可以用<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- Just 4</span></div><div class="line">( <span class="number">1</span> + ) `liftM` (<span class="type">Just</span> <span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p>这与 <code>Just 3 &gt;&gt;= \x -&gt; Just (x+1)</code>等价。</p>
<p>另外，从函子的角度，这个也可以写作<code>(1+) &lt;$&gt; (Just 3)</code></p>
<p>如果函数<code>f</code>有多余一个参数，<code>Control.Monad</code>中也有对应的<code>liftM2</code>~<code>liftM5</code></p>
<ul>
<li>在<code>Control.Monad</code>中定义<code>ap</code>函数，其签名为：<br><code>ap :: Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b</code><br>解读一下：第一个参数是一个被Monad包装的函数，第二个参数是一个普通的Monad值，这个值的类型与第一个参数中被包装的函数的参数相同（很拗口）。我们知道标准库总只定义了几个常见的<code>liftM</code>，如果我们需要大量链式调用，除了<code>&lt;*&gt;</code>外，还可以组合<code>liftM</code>和<code>ap</code>. 举个例子，定义</li>
</ul>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">fee</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></div><div class="line"><span class="title">fee</span> a b = a + b</div></pre></td></tr></table></figure>
<p>那么 <code>liftM fee</code>的类型为：</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Monad</span> m =&gt; m <span class="type">Int</span> -&gt; m (<span class="type">Int</span> -&gt; <span class="type">Int</span>)</div></pre></td></tr></table></figure>
<p>显然这个函数的返回值满足<code>ap</code>的参数需求， 所以以下两个表达式相等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fee `liftM` (Just 1) `ap` (Just 1)</div><div class="line">fee `liftM` (Just 1) &lt;*&gt; (Just 1)</div><div class="line">liftM2 fee (Just 1) (Just 1)</div></pre></td></tr></table></figure>
<ul>
<li><code>join</code>函数也很常用：</li>
</ul>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">join</span> :: <span class="type">Monad</span> m =&gt; m (m a) -&gt; m a</div><div class="line"><span class="title">join</span> x = x &gt;&gt;= id</div></pre></td></tr></table></figure>
<p>用来移除一层Monad，<code>join (Just (Just a))</code>就是<code>Just a</code></p>
<ul>
<li>Monad的三个约束（数学意义上），类似Functor，Monad也有一些潜在的约束：<ul>
<li><code>return x &gt;&gt;= f</code> == <code>f x</code></li>
<li><code>m &gt;&gt;= return</code> == <code>m</code></li>
<li><code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code> === <code>(m &gt;&gt;= f) &gt;&gt;= g</code></li>
</ul>
</li>
</ul>
<p>第三条是结合律，如果我们把一个大的action分解成一系列的子action，只要我们保证子action的顺序，把哪些子action提取出来组合成一个新action对求值结果是没有影响的。</p>
<ul>
<li><code>Control.Monad</code>里面定义了<code>MonadPlus</code>，这其实是短路求值。</li>
</ul>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadPlus</span> m <span class="keyword">where</span></span></div><div class="line">    mzero :: m a</div><div class="line">    mplus :: m a -&gt; m a -&gt; m a</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">MonadPlus</span> [] <span class="keyword">where</span></div><div class="line">    mzero = []</div><div class="line">    mplus = (++)</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">MonadPlus</span> <span class="type">Maybe</span> <span class="keyword">where</span></div><div class="line">    mzero = <span class="type">Nothing</span></div><div class="line">    <span class="type">Nothing</span> `mplus` ys = ys</div><div class="line">    xs `mplus` _ = xs</div></pre></td></tr></table></figure>
<ul>
<li><p>在<code>Control.Monad</code>中定义了标准函数<code>guard</code>：</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">guard</span> :: (<span class="type">MonadPlus</span> m) =&gt; <span class="type">Bool</span> -&gt; m()</div><div class="line"><span class="title">guard</span> <span class="type">True</span>  = return ()</div><div class="line"><span class="title">guard</span> <span class="type">False</span> = mzero</div></pre></td></tr></table></figure>
</li>
<li><p>在<code>Control.Arrow</code>中定义了函数<code>first</code>和<code>second</code>用于将普通函数应用到<code>Pair</code>中去</p>
</li>
</ul>
<h2 id="Monad变换器"><a href="#Monad变换器" class="headerlink" title="Monad变换器"></a>Monad变换器</h2><p>Monad变换器主要用来修改已经存在的Monad，以<code>T</code>结尾。大量Monad变换器进行叠加，就可以得到拥有多种功能的Monad.</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>讨论一些常用的haskell处理方式：<code>Maybe</code>, <code>Either</code>和<code>Exception</code>，一般都使用Monad配合。</p>
<p>再往后就是一些实际使用的例子了。</p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-06-12T16:21:47.000Z" itemprop="dateUpdated">2017-06-13 00:21:47</time>
</span><br>


        
        <a href="/2017/06/12/重拾Haskell/" target="_blank" rel="external">http://YiuTerran.github.io/2017/06/12/重拾Haskell/</a>
        
    </div>
    <footer>
        <a href="http://YiuTerran.github.io">
            <img src="/img/avatar.png" alt="tryao">
            tryao
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FP/">FP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Haskell/">Haskell</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://YiuTerran.github.io/2017/06/12/重拾Haskell/&title=《重拾Haskell》 — 无心呢喃&pic=http://YiuTerran.github.io/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://YiuTerran.github.io/2017/06/12/重拾Haskell/&title=《重拾Haskell》 — 无心呢喃&source=个人技术类感悟、笔记等，非技术类见微信公众号“叶囊”" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://YiuTerran.github.io/2017/06/12/重拾Haskell/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《重拾Haskell》 — 无心呢喃&url=http://YiuTerran.github.io/2017/06/12/重拾Haskell/&via=http://YiuTerran.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://YiuTerran.github.io/2017/06/12/重拾Haskell/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/06/12/java并发编程实战读书笔记/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">java并发编程实战读书笔记</h4>
      </a>
    </div>
  

  
</nav>



    




<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'yiuterran';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <ul class="reward-items">
        
        <li>
            <img src="/img/wechat.png" title="微信打赏二维码" alt="微信打赏二维码">
            <p>微信</p>
        </li>
        

        
        <li>
            <img src="/img/alipay.png" title="支付宝打赏二维码" alt="支付宝打赏二维码">
            <p>支付宝</p>
        </li>
        
    </ul>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
            <span>tryao &copy; 2017</span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://YiuTerran.github.io/2017/06/12/重拾Haskell/&title=《重拾Haskell》 — 无心呢喃&pic=http://YiuTerran.github.io/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://YiuTerran.github.io/2017/06/12/重拾Haskell/&title=《重拾Haskell》 — 无心呢喃&source=个人技术类感悟、笔记等，非技术类见微信公众号“叶囊”" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://YiuTerran.github.io/2017/06/12/重拾Haskell/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《重拾Haskell》 — 无心呢喃&url=http://YiuTerran.github.io/2017/06/12/重拾Haskell/&via=http://YiuTerran.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://YiuTerran.github.io/2017/06/12/重拾Haskell/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACI0lEQVR42u3aS47DIBAFwNz/0pltpJHR64ZEAsqrkZPgLi8Y+vN6xdf73/V5f/z9p28+3Xlac8GFgYGxLeM9vBLGGFNdYfyrxydiYGBcwEiCWPWrfOXkKRgYGBjjTTBfp7rJYmBgYKxiJMHld6pJMgYGxm2M3nJjWM7+aS6OgYGxISOvuv/+76/0NzAwMLZivIvXTHGt1zyIosLAwDiakW9w+cGxGm5v2AIDA+M2RrWsn7cek7CqRb3CGRYDA+MIRm/oId8u1zYGHtfBwMC4hlE4fgWwXjKcvCwMDIzbGNVC/DdGK3pHSQwMjNsYvQRypjQ2FWjvTWNgYBzNyJPYvEiXr5x/ioGBcSqjl3bmLYGZka8CCQMD42jGTDuzN0aWPGX8sgpHRgwMjCMYyZbaC7SHybf48jwIBgbG5oy1wxbVo96CdBcDA+MCRtJWnCmi9cpwhaQXAwPjaEZOmmlt5nd6yS0GBsYNjCTcXpm+N1TRbAlgYGBcwKgGvaqpMNMweGwPYGBgHM3oJbq9wYukqFdIpzEwMK5hVNuTvc2xN5zR/L+BgYGxOWPVmNeqwlyS3JbPthgYGJszZjqDvaJbMmzROyxiYGCczaiW2/LNuvfm8himGgMYGBgbMgpZ73Qo5RDzXBwDAwMjbiRUE938+8s2XAwMjCsZa4c2yq8AAwPjAkYvEa2WxnothMXlNgwMjA0ZU6ljsdyfkL6XWmNgYGzI+ANDVWqYiBfDRAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };



</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
